import { TARGET } from '../../constants/target';
import { camelToKebabCase } from '../../functions/camel-to-kebab-case';
// eslint-disable-next-line @typescript-eslint/ban-types
function throttle(func, wait, options = {}) {
    let context;
    let args;
    let result;
    let timeout = null;
    let previous = 0;
    const later = function () {
        previous = options.leading === false ? 0 : Date.now();
        timeout = null;
        result = func.apply(context, args);
        if (!timeout)
            context = args = null;
    };
    return function () {
        const now = Date.now();
        if (!previous && options.leading === false)
            previous = now;
        const remaining = wait - (now - previous);
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        context = this;
        // eslint-disable-next-line prefer-rest-params
        args = arguments;
        if (remaining <= 0 || remaining > wait) {
            if (timeout) {
                clearTimeout(timeout);
                timeout = null;
            }
            previous = now;
            result = func.apply(context, args);
            if (!timeout)
                context = args = null;
        }
        else if (!timeout && options.trailing !== false) {
            timeout = setTimeout(later, remaining);
        }
        return result;
    };
}
function assign(target, ..._args) {
    const to = Object(target);
    for (let index = 1; index < arguments.length; index++) {
        // eslint-disable-next-line prefer-rest-params
        const nextSource = arguments[index];
        if (nextSource != null) {
            // Skip over if undefined or null
            for (const nextKey in nextSource) {
                // Avoid bugs when hasOwnProperty is shadowed
                if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                    to[nextKey] = nextSource[nextKey];
                }
            }
        }
    }
    return to;
}
export function bindAnimations(animations) {
    if (TARGET === 'reactNative') {
        return;
    }
    for (const animation of animations) {
        switch (animation.trigger) {
            case 'pageLoad':
                triggerAnimation(animation);
                break;
            case 'scrollInView':
                bindScrollInViewAnimation(animation);
                break;
        }
    }
}
function warnElementNotPresent(id) {
    console.warn(`Cannot animate element: element with ID ${id} not found!`);
}
function augmentAnimation(animation, element) {
    const stylesUsed = getAllStylesUsed(animation);
    const computedStyle = getComputedStyle(element);
    // const computedStyle = getComputedStyle(element);
    // // FIXME: this will break if original load is in one reponsive size then resize to another hmmm
    // Need to use transform instead of left since left can change on screen sizes
    const firstStyles = animation.steps[0].styles;
    const lastStyles = animation.steps[animation.steps.length - 1].styles;
    const bothStyles = [firstStyles, lastStyles];
    // FIXME: this won't work as expected for augmented animations - may need the editor itself to manage this
    for (const styles of bothStyles) {
        for (const style of stylesUsed) {
            if (!(style in styles)) {
                styles[style] = computedStyle[style];
            }
        }
    }
}
function getAllStylesUsed(animation) {
    const properties = [];
    for (const step of animation.steps) {
        for (const key in step.styles) {
            if (properties.indexOf(key) === -1) {
                properties.push(key);
            }
        }
    }
    return properties;
}
export function triggerAnimation(animation) {
    // TODO: do for ALL elements
    const elements = Array.prototype.slice.call(document.getElementsByClassName(animation.elementId || animation.id || ''));
    if (!elements.length) {
        warnElementNotPresent(animation.elementId || animation.id || '');
        return;
    }
    Array.from(elements).forEach(element => {
        augmentAnimation(animation, element);
        // TODO: do this properly, may have other animations of different properties
        // TODO: only override the properties
        // TODO: if there is an entrance and hover animation, the transition duration will get effed
        // element.setAttribute('style', '');
        // const styledUsed = this.getAllStylesUsed(animation);
        element.style.transition = 'none';
        element.style.transitionDelay = '0';
        assign(element.style, animation.steps[0].styles);
        // TODO: queue/batch these timeouts
        // TODO: only include properties explicitly set in the animation
        // using Object.keys(styles)
        setTimeout(() => {
            element.style.transition = `all ${animation.duration}s ${camelToKebabCase(animation.easing)}`;
            if (animation.delay) {
                element.style.transitionDelay = animation.delay + 's';
            }
            assign(element.style, animation.steps[1].styles);
            // TODO: maybe remove/reset transitoin property after animation duration
            // TODO: queue timers
            setTimeout(() => {
                // TODO: what if has other transition (reset back to what it was)
                element.style.transition = '';
                element.style.transitionDelay = '';
            }, (animation.delay || 0) * 1000 + animation.duration * 1000 + 100);
        });
    });
}
// TODO: unbind on element remove
export function bindScrollInViewAnimation(animation) {
    // TODO: apply to ALL matching elements
    const elements = Array.prototype.slice.call(document.getElementsByClassName(animation.elementId || animation.id || ''));
    if (!elements.length) {
        warnElementNotPresent(animation.elementId || animation.id || '');
        return;
    }
    // TODO: if server side rendered and scrolled into view don't animate...
    Array.from(elements).forEach(element => {
        augmentAnimation(animation, element);
        let triggered = false;
        let pendingAnimation = false;
        function immediateOnScroll() {
            if (!triggered && isScrolledIntoView(element)) {
                triggered = true;
                pendingAnimation = true;
                setTimeout(() => {
                    assign(element.style, animation.steps[1].styles);
                    if (!animation.repeat) {
                        document.removeEventListener('scroll', onScroll);
                    }
                    setTimeout(() => {
                        pendingAnimation = false;
                        if (!animation.repeat) {
                            element.style.transition = '';
                            element.style.transitionDelay = '';
                        }
                    }, (animation.duration + (animation.delay || 0)) * 1000 + 100);
                });
            }
            else if (animation.repeat && triggered && !pendingAnimation && !isScrolledIntoView(element)) {
                // we want to repeat the animation every time the the element is out of view and back again
                triggered = false;
                assign(element.style, animation.steps[0].styles);
            }
        }
        // TODO: roll all of these in one for more efficiency of checking all the rects
        const onScroll = throttle(immediateOnScroll, 200, {
            leading: false
        });
        // TODO: fully in view or partially
        function isScrolledIntoView(elem) {
            const rect = elem.getBoundingClientRect();
            const windowHeight = window.innerHeight;
            const thresholdPercent = (animation.thresholdPercent || 0) / 100;
            const threshold = thresholdPercent * windowHeight;
            // TODO: partial in view? or what if element is larger than screen itself
            return rect.bottom > threshold && rect.top < windowHeight - threshold // Element is peeking top or bottom
            ;
        }
        const defaultState = animation.steps[0].styles;
        function attachDefaultState() {
            assign(element.style, defaultState);
        }
        attachDefaultState();
        // TODO: queue/batch these timeouts!
        setTimeout(() => {
            element.style.transition = `all ${animation.duration}s ${camelToKebabCase(animation.easing)}`;
            if (animation.delay) {
                element.style.transitionDelay = animation.delay + 's';
            }
        });
        // TODO: one listener for everything
        document.addEventListener('scroll', onScroll, {
            capture: true,
            passive: true
        });
        // Do an initial check
        immediateOnScroll();
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5pbWF0b3IuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvY29tcG9uZW50cy9ibG9jay9hbmltYXRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDaEQsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0scUNBQXFDLENBQUM7QUFHdkUsd0RBQXdEO0FBQ3hELFNBQVMsUUFBUSxDQUFDLElBQWMsRUFBRSxJQUFZLEVBQUUsVUFBZSxFQUFFO0lBQy9ELElBQUksT0FBWSxDQUFDO0lBQ2pCLElBQUksSUFBUyxDQUFDO0lBQ2QsSUFBSSxNQUFXLENBQUM7SUFDaEIsSUFBSSxPQUFPLEdBQUksSUFBWSxDQUFDO0lBQzVCLElBQUksUUFBUSxHQUFHLENBQUMsQ0FBQztJQUNqQixNQUFNLEtBQUssR0FBRztRQUNaLFFBQVEsR0FBRyxPQUFPLENBQUMsT0FBTyxLQUFLLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDdEQsT0FBTyxHQUFHLElBQUksQ0FBQztRQUNmLE1BQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQztRQUNuQyxJQUFJLENBQUMsT0FBTztZQUFFLE9BQU8sR0FBRyxJQUFJLEdBQUcsSUFBSSxDQUFDO0lBQ3RDLENBQUMsQ0FBQztJQUNGLE9BQU87UUFDTCxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDdkIsSUFBSSxDQUFDLFFBQVEsSUFBSSxPQUFPLENBQUMsT0FBTyxLQUFLLEtBQUs7WUFBRSxRQUFRLEdBQUcsR0FBRyxDQUFDO1FBQzNELE1BQU0sU0FBUyxHQUFHLElBQUksR0FBRyxDQUFDLEdBQUcsR0FBRyxRQUFRLENBQUMsQ0FBQztRQUMxQyw0REFBNEQ7UUFDNUQs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RUFBeUU7WUFDekUsT0FBTyxJQUFJLENBQUMsTUFBTSxHQUFHLFNBQVMsSUFBSSxJQUFJLENBQUMsR0FBRyxHQUFHLFlBQVksR0FBRyxTQUFTLENBQUMsbUNBQW1DO2FBR3hHO1FBQ0gsQ0FBQztRQUNELE1BQU0sWUFBWSxHQUFHLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDO1FBQy9DLFNBQVMsa0JBQWtCO1lBQ3pCLE1BQU0sQ0FBQyxPQUFRLENBQUMsS0FBSyxFQUFFLFlBQVksQ0FBQyxDQUFDO1FBQ3ZDLENBQUM7UUFDRCxrQkFBa0IsRUFBRSxDQUFDO1FBRXJCLG9DQUFvQztRQUNwQyxVQUFVLENBQUMsR0FBRyxFQUFFO1lBQ2QsT0FBTyxDQUFDLEtBQUssQ0FBQyxVQUFVLEdBQUcsT0FBTyxTQUFTLENBQUMsUUFBUSxLQUFLLGdCQUFnQixDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDO1lBQzlGLElBQUksU0FBUyxDQUFDLEtBQUssRUFBRTtnQkFDbkIsT0FBTyxDQUFDLEtBQUssQ0FBQyxlQUFlLEdBQUcsU0FBUyxDQUFDLEtBQUssR0FBRyxHQUFHLENBQUM7YUFDdkQ7UUFDSCxDQUFDLENBQUMsQ0FBQztRQUVILG9DQUFvQztRQUNwQyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxFQUFFLFFBQVEsRUFBRztZQUM3QyxPQUFPLEVBQUUsSUFBSTtZQUNiLE9BQU8sRUFBRSxJQUFJO1NBQ04sQ0FBQyxDQUFDO1FBRVgsc0JBQXNCO1FBQ3RCLGlCQUFpQixFQUFFLENBQUM7SUFDdEIsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVEFSR0VUIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzL3RhcmdldCc7XG5pbXBvcnQgeyBjYW1lbFRvS2ViYWJDYXNlIH0gZnJvbSAnLi4vLi4vZnVuY3Rpb25zL2NhbWVsLXRvLWtlYmFiLWNhc2UnO1xuaW1wb3J0IHR5cGUgeyBCdWlsZGVyQW5pbWF0aW9uIH0gZnJvbSAnLi4vLi4vdHlwZXMvYnVpbGRlci1ibG9jayc7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG5mdW5jdGlvbiB0aHJvdHRsZShmdW5jOiBGdW5jdGlvbiwgd2FpdDogbnVtYmVyLCBvcHRpb25zOiBhbnkgPSB7fSkge1xuICBsZXQgY29udGV4dDogYW55O1xuICBsZXQgYXJnczogYW55O1xuICBsZXQgcmVzdWx0OiBhbnk7XG4gIGxldCB0aW1lb3V0ID0gKG51bGwgYXMgYW55KTtcbiAgbGV0IHByZXZpb3VzID0gMDtcbiAgY29uc3QgbGF0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcHJldmlvdXMgPSBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlID8gMCA6IERhdGUubm93KCk7XG4gICAgdGltZW91dCA9IG51bGw7XG4gICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgfTtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0aGlzOiBhbnkpIHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGlmICghcHJldmlvdXMgJiYgb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSkgcHJldmlvdXMgPSBub3c7XG4gICAgY29uc3QgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXG4gICAgY29udGV4dCA9IHRoaXM7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1yZXN0LXBhcmFtc1xuICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgaWYgKHJlbWFpbmluZyA8PSAwIHx8IHJlbWFpbmluZyA+IHdhaXQpIHtcbiAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICB9XG4gICAgICBwcmV2aW91cyA9IG5vdztcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKCF0aW1lb3V0ICYmIG9wdGlvbnMudHJhaWxpbmcgIT09IGZhbHNlKSB7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgcmVtYWluaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cbmZ1bmN0aW9uIGFzc2lnbih0YXJnZXQ6IG9iamVjdCwgLi4uX2FyZ3M6IGFueVtdKSB7XG4gIGNvbnN0IHRvID0gT2JqZWN0KHRhcmdldCk7XG4gIGZvciAobGV0IGluZGV4ID0gMTsgaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1yZXN0LXBhcmFtc1xuICAgIGNvbnN0IG5leHRTb3VyY2UgPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgIGlmIChuZXh0U291cmNlICE9IG51bGwpIHtcbiAgICAgIC8vIFNraXAgb3ZlciBpZiB1bmRlZmluZWQgb3IgbnVsbFxuICAgICAgZm9yIChjb25zdCBuZXh0S2V5IGluIG5leHRTb3VyY2UpIHtcbiAgICAgICAgLy8gQXZvaWQgYnVncyB3aGVuIGhhc093blByb3BlcnR5IGlzIHNoYWRvd2VkXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobmV4dFNvdXJjZSwgbmV4dEtleSkpIHtcbiAgICAgICAgICB0b1tuZXh0S2V5XSA9IG5leHRTb3VyY2VbbmV4dEtleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJpbmRBbmltYXRpb25zKGFuaW1hdGlvbnM6IEJ1aWxkZXJBbmltYXRpb25bXSkge1xuICBpZiAoVEFSR0VUID09PSAncmVhY3ROYXRpdmUnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAoY29uc3QgYW5pbWF0aW9uIG9mIGFuaW1hdGlvbnMpIHtcbiAgICBzd2l0Y2ggKGFuaW1hdGlvbi50cmlnZ2VyKSB7XG4gICAgICBjYXNlICdwYWdlTG9hZCc6XG4gICAgICAgIHRyaWdnZXJBbmltYXRpb24oYW5pbWF0aW9uKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzY3JvbGxJblZpZXcnOlxuICAgICAgICBiaW5kU2Nyb2xsSW5WaWV3QW5pbWF0aW9uKGFuaW1hdGlvbik7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gd2FybkVsZW1lbnROb3RQcmVzZW50KGlkOiBzdHJpbmcpIHtcbiAgY29uc29sZS53YXJuKGBDYW5ub3QgYW5pbWF0ZSBlbGVtZW50OiBlbGVtZW50IHdpdGggSUQgJHtpZH0gbm90IGZvdW5kIWApO1xufVxuZnVuY3Rpb24gYXVnbWVudEFuaW1hdGlvbihhbmltYXRpb246IEJ1aWxkZXJBbmltYXRpb24sIGVsZW1lbnQ6IEhUTUxFbGVtZW50KSB7XG4gIGNvbnN0IHN0eWxlc1VzZWQgPSBnZXRBbGxTdHlsZXNVc2VkKGFuaW1hdGlvbik7XG4gIGNvbnN0IGNvbXB1dGVkU3R5bGU6IGFueSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIC8vIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAvLyAvLyBGSVhNRTogdGhpcyB3aWxsIGJyZWFrIGlmIG9yaWdpbmFsIGxvYWQgaXMgaW4gb25lIHJlcG9uc2l2ZSBzaXplIHRoZW4gcmVzaXplIHRvIGFub3RoZXIgaG1tbVxuICAvLyBOZWVkIHRvIHVzZSB0cmFuc2Zvcm0gaW5zdGVhZCBvZiBsZWZ0IHNpbmNlIGxlZnQgY2FuIGNoYW5nZSBvbiBzY3JlZW4gc2l6ZXNcbiAgY29uc3QgZmlyc3RTdHlsZXMgPSBhbmltYXRpb24uc3RlcHNbMF0uc3R5bGVzO1xuICBjb25zdCBsYXN0U3R5bGVzID0gYW5pbWF0aW9uLnN0ZXBzW2FuaW1hdGlvbi5zdGVwcy5sZW5ndGggLSAxXSEuc3R5bGVzO1xuICBjb25zdCBib3RoU3R5bGVzID0gW2ZpcnN0U3R5bGVzLCBsYXN0U3R5bGVzXTtcblxuICAvLyBGSVhNRTogdGhpcyB3b24ndCB3b3JrIGFzIGV4cGVjdGVkIGZvciBhdWdtZW50ZWQgYW5pbWF0aW9ucyAtIG1heSBuZWVkIHRoZSBlZGl0b3IgaXRzZWxmIHRvIG1hbmFnZSB0aGlzXG4gIGZvciAoY29uc3Qgc3R5bGVzIG9mIGJvdGhTdHlsZXMpIHtcbiAgICBmb3IgKGNvbnN0IHN0eWxlIG9mIHN0eWxlc1VzZWQpIHtcbiAgICAgIGlmICghKHN0eWxlIGluIHN0eWxlcykpIHtcbiAgICAgICAgc3R5bGVzWyhzdHlsZSBhcyBhbnkpXSA9IGNvbXB1dGVkU3R5bGVbc3R5bGVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0QWxsU3R5bGVzVXNlZChhbmltYXRpb246IEJ1aWxkZXJBbmltYXRpb24pIHtcbiAgY29uc3QgcHJvcGVydGllczogKGtleW9mIENTU1N0eWxlRGVjbGFyYXRpb24pW10gPSBbXTtcbiAgZm9yIChjb25zdCBzdGVwIG9mIGFuaW1hdGlvbi5zdGVwcykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHN0ZXAuc3R5bGVzKSB7XG4gICAgICBpZiAocHJvcGVydGllcy5pbmRleE9mKChrZXkgYXMgYW55KSkgPT09IC0xKSB7XG4gICAgICAgIHByb3BlcnRpZXMucHVzaCgoa2V5IGFzIGFueSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcHJvcGVydGllcztcbn1cbmV4cG9ydCBmdW5jdGlvbiB0cmlnZ2VyQW5pbWF0aW9uKGFuaW1hdGlvbjogQnVpbGRlckFuaW1hdGlvbikge1xuICAvLyBUT0RPOiBkbyBmb3IgQUxMIGVsZW1lbnRzXG4gIGNvbnN0IGVsZW1lbnRzID0gKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoYW5pbWF0aW9uLmVsZW1lbnRJZCB8fCBhbmltYXRpb24uaWQgfHwgJycpKSBhcyBIVE1MRWxlbWVudFtdKTtcbiAgaWYgKCFlbGVtZW50cy5sZW5ndGgpIHtcbiAgICB3YXJuRWxlbWVudE5vdFByZXNlbnQoYW5pbWF0aW9uLmVsZW1lbnRJZCB8fCBhbmltYXRpb24uaWQgfHwgJycpO1xuICAgIHJldHVybjtcbiAgfVxuICBBcnJheS5mcm9tKGVsZW1lbnRzKS5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgIGF1Z21lbnRBbmltYXRpb24oYW5pbWF0aW9uLCBlbGVtZW50KTtcbiAgICAvLyBUT0RPOiBkbyB0aGlzIHByb3Blcmx5LCBtYXkgaGF2ZSBvdGhlciBhbmltYXRpb25zIG9mIGRpZmZlcmVudCBwcm9wZXJ0aWVzXG5cbiAgICAvLyBUT0RPOiBvbmx5IG92ZXJyaWRlIHRoZSBwcm9wZXJ0aWVzXG4gICAgLy8gVE9ETzogaWYgdGhlcmUgaXMgYW4gZW50cmFuY2UgYW5kIGhvdmVyIGFuaW1hdGlvbiwgdGhlIHRyYW5zaXRpb24gZHVyYXRpb24gd2lsbCBnZXQgZWZmZWRcbiAgICAvLyBlbGVtZW50LnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnJyk7XG5cbiAgICAvLyBjb25zdCBzdHlsZWRVc2VkID0gdGhpcy5nZXRBbGxTdHlsZXNVc2VkKGFuaW1hdGlvbik7XG4gICAgZWxlbWVudC5zdHlsZS50cmFuc2l0aW9uID0gJ25vbmUnO1xuICAgIGVsZW1lbnQuc3R5bGUudHJhbnNpdGlvbkRlbGF5ID0gJzAnO1xuICAgIGFzc2lnbihlbGVtZW50LnN0eWxlLCBhbmltYXRpb24uc3RlcHNbMF0uc3R5bGVzKTtcbiAgICAvLyBUT0RPOiBxdWV1ZS9iYXRjaCB0aGVzZSB0aW1lb3V0c1xuICAgIC8vIFRPRE86IG9ubHkgaW5jbHVkZSBwcm9wZXJ0aWVzIGV4cGxpY2l0bHkgc2V0IGluIHRoZSBhbmltYXRpb25cbiAgICAvLyB1c2luZyBPYmplY3Qua2V5cyhzdHlsZXMpXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBlbGVtZW50LnN0eWxlLnRyYW5zaXRpb24gPSBgYWxsICR7YW5pbWF0aW9uLmR1cmF0aW9ufXMgJHtjYW1lbFRvS2ViYWJDYXNlKGFuaW1hdGlvbi5lYXNpbmcpfWA7XG4gICAgICBpZiAoYW5pbWF0aW9uLmRlbGF5KSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUudHJhbnNpdGlvbkRlbGF5ID0gYW5pbWF0aW9uLmRlbGF5ICsgJ3MnO1xuICAgICAgfVxuICAgICAgYXNzaWduKGVsZW1lbnQuc3R5bGUsIGFuaW1hdGlvbi5zdGVwc1sxXS5zdHlsZXMpO1xuICAgICAgLy8gVE9ETzogbWF5YmUgcmVtb3ZlL3Jlc2V0IHRyYW5zaXRvaW4gcHJvcGVydHkgYWZ0ZXIgYW5pbWF0aW9uIGR1cmF0aW9uXG5cbiAgICAgIC8vIFRPRE86IHF1ZXVlIHRpbWVyc1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIC8vIFRPRE86IHdoYXQgaWYgaGFzIG90aGVyIHRyYW5zaXRpb24gKHJlc2V0IGJhY2sgdG8gd2hhdCBpdCB3YXMpXG4gICAgICAgIGVsZW1lbnQuc3R5bGUudHJhbnNpdGlvbiA9ICcnO1xuICAgICAgICBlbGVtZW50LnN0eWxlLnRyYW5zaXRpb25EZWxheSA9ICcnO1xuICAgICAgfSwgKGFuaW1hdGlvbi5kZWxheSB8fCAwKSAqIDEwMDAgKyBhbmltYXRpb24uZHVyYXRpb24gKiAxMDAwICsgMTAwKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8vIFRPRE86IHVuYmluZCBvbiBlbGVtZW50IHJlbW92ZVxuZXhwb3J0IGZ1bmN0aW9uIGJpbmRTY3JvbGxJblZpZXdBbmltYXRpb24oYW5pbWF0aW9uOiBCdWlsZGVyQW5pbWF0aW9uKSB7XG4gIC8vIFRPRE86IGFwcGx5IHRvIEFMTCBtYXRjaGluZyBlbGVtZW50c1xuICBjb25zdCBlbGVtZW50cyA9IChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGFuaW1hdGlvbi5lbGVtZW50SWQgfHwgYW5pbWF0aW9uLmlkIHx8ICcnKSkgYXMgSFRNTEVsZW1lbnRbXSk7XG4gIGlmICghZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgd2FybkVsZW1lbnROb3RQcmVzZW50KGFuaW1hdGlvbi5lbGVtZW50SWQgfHwgYW5pbWF0aW9uLmlkIHx8ICcnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBUT0RPOiBpZiBzZXJ2ZXIgc2lkZSByZW5kZXJlZCBhbmQgc2Nyb2xsZWQgaW50byB2aWV3IGRvbid0IGFuaW1hdGUuLi5cbiAgQXJyYXkuZnJvbShlbGVtZW50cykuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICBhdWdtZW50QW5pbWF0aW9uKGFuaW1hdGlvbiwgZWxlbWVudCk7XG4gICAgbGV0IHRyaWdnZXJlZCA9IGZhbHNlO1xuICAgIGxldCBwZW5kaW5nQW5pbWF0aW9uID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gaW1tZWRpYXRlT25TY3JvbGwoKSB7XG4gICAgICBpZiAoIXRyaWdnZXJlZCAmJiBpc1Njcm9sbGVkSW50b1ZpZXcoZWxlbWVudCkpIHtcbiAgICAgICAgdHJpZ2dlcmVkID0gdHJ1ZTtcbiAgICAgICAgcGVuZGluZ0FuaW1hdGlvbiA9IHRydWU7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGFzc2lnbihlbGVtZW50IS5zdHlsZSwgYW5pbWF0aW9uLnN0ZXBzWzFdLnN0eWxlcyk7XG4gICAgICAgICAgaWYgKCFhbmltYXRpb24ucmVwZWF0KSB7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBvblNjcm9sbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgcGVuZGluZ0FuaW1hdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKCFhbmltYXRpb24ucmVwZWF0KSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUudHJhbnNpdGlvbiA9ICcnO1xuICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLnRyYW5zaXRpb25EZWxheSA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIChhbmltYXRpb24uZHVyYXRpb24gKyAoYW5pbWF0aW9uLmRlbGF5IHx8IDApKSAqIDEwMDAgKyAxMDApO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoYW5pbWF0aW9uLnJlcGVhdCAmJiB0cmlnZ2VyZWQgJiYgIXBlbmRpbmdBbmltYXRpb24gJiYgIWlzU2Nyb2xsZWRJbnRvVmlldyhlbGVtZW50KSkge1xuICAgICAgICAvLyB3ZSB3YW50IHRvIHJlcGVhdCB0aGUgYW5pbWF0aW9uIGV2ZXJ5IHRpbWUgdGhlIHRoZSBlbGVtZW50IGlzIG91dCBvZiB2aWV3IGFuZCBiYWNrIGFnYWluXG4gICAgICAgIHRyaWdnZXJlZCA9IGZhbHNlO1xuICAgICAgICBhc3NpZ24oZWxlbWVudCEuc3R5bGUsIGFuaW1hdGlvbi5zdGVwc1swXS5zdHlsZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE86IHJvbGwgYWxsIG9mIHRoZXNlIGluIG9uZSBmb3IgbW9yZSBlZmZpY2llbmN5IG9mIGNoZWNraW5nIGFsbCB0aGUgcmVjdHNcbiAgICBjb25zdCBvblNjcm9sbCA9IHRocm90dGxlKGltbWVkaWF0ZU9uU2Nyb2xsLCAyMDAsIHtcbiAgICAgIGxlYWRpbmc6IGZhbHNlXG4gICAgfSk7XG5cbiAgICAvLyBUT0RPOiBmdWxseSBpbiB2aWV3IG9yIHBhcnRpYWxseVxuICAgIGZ1bmN0aW9uIGlzU2Nyb2xsZWRJbnRvVmlldyhlbGVtOiBIVE1MRWxlbWVudCkge1xuICAgICAgY29uc3QgcmVjdCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCB3aW5kb3dIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICBjb25zdCB0aHJlc2hvbGRQZXJjZW50ID0gKGFuaW1hdGlvbi50aHJlc2hvbGRQZXJjZW50IHx8IDApIC8gMTAwO1xuICAgICAgY29uc3QgdGhyZXNob2xkID0gdGhyZXNob2xkUGVyY2VudCAqIHdpbmRvd0hlaWdodDtcblxuICAgICAgLy8gVE9ETzogcGFydGlhbCBpbiB2aWV3PyBvciB3aGF0IGlmIGVsZW1lbnQgaXMgbGFyZ2VyIHRoYW4gc2NyZWVuIGl0c2VsZlxuICAgICAgcmV0dXJuIHJlY3QuYm90dG9tID4gdGhyZXNob2xkICYmIHJlY3QudG9wIDwgd2luZG93SGVpZ2h0IC0gdGhyZXNob2xkIC8vIEVsZW1lbnQgaXMgcGVla2luZyB0b3Agb3IgYm90dG9tXG4gICAgICAvLyAocmVjdC50b3AgPiAwICYmIHJlY3QuYm90dG9tIDwgd2luZG93LmlubmVySGVpZ2h0KSB8fCAvLyBlbGVtZW50IGZpdHMgd2l0aGluIHRoZSBzY3JlZW4gYW5kIGlzIGZ1bGx5IG9uIHNjcmVlbiAobm90IGhhbmdpbmcgb2ZmIGF0IGFsbClcbiAgICAgIC8vIChyZWN0LnRvcCA8IDAgJiYgcmVjdC5ib3R0b20gPiB3aW5kb3cuaW5uZXJIZWlnaHQpIC8vIGVsZW1lbnQgaXMgbGFyZ2VyIHRoYW4gdGhlIHNjcmVlbiBhbmQgaGFuZ3Mgb3ZlciB0aGUgdG9wIGFuZCBib3R0b21cbiAgICAgIDtcbiAgICB9XG4gICAgY29uc3QgZGVmYXVsdFN0YXRlID0gYW5pbWF0aW9uLnN0ZXBzWzBdLnN0eWxlcztcbiAgICBmdW5jdGlvbiBhdHRhY2hEZWZhdWx0U3RhdGUoKSB7XG4gICAgICBhc3NpZ24oZWxlbWVudCEuc3R5bGUsIGRlZmF1bHRTdGF0ZSk7XG4gICAgfVxuICAgIGF0dGFjaERlZmF1bHRTdGF0ZSgpO1xuXG4gICAgLy8gVE9ETzogcXVldWUvYmF0Y2ggdGhlc2UgdGltZW91dHMhXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBlbGVtZW50LnN0eWxlLnRyYW5zaXRpb24gPSBgYWxsICR7YW5pbWF0aW9uLmR1cmF0aW9ufXMgJHtjYW1lbFRvS2ViYWJDYXNlKGFuaW1hdGlvbi5lYXNpbmcpfWA7XG4gICAgICBpZiAoYW5pbWF0aW9uLmRlbGF5KSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUudHJhbnNpdGlvbkRlbGF5ID0gYW5pbWF0aW9uLmRlbGF5ICsgJ3MnO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gVE9ETzogb25lIGxpc3RlbmVyIGZvciBldmVyeXRoaW5nXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgb25TY3JvbGwsICh7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgIH0gYXMgYW55KSk7XG5cbiAgICAvLyBEbyBhbiBpbml0aWFsIGNoZWNrXG4gICAgaW1tZWRpYXRlT25TY3JvbGwoKTtcbiAgfSk7XG59Il19