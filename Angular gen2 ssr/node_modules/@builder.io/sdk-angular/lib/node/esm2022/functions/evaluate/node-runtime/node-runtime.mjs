import { SDK_NAME } from '../../../constants/sdk-name';
import { MSG_PREFIX, logger } from '../../../helpers/logger';
import { fastClone } from '../../fast-clone';
import { set } from '../../set';
import { getFunctionArguments } from '../helpers';
import { safeDynamicRequire } from './safeDynamicRequire';
const getSyncValName = (key) => `bldr_${key}_sync`;
const BUILDER_SET_STATE_NAME = 'BUILDER_SET_STATE';
const INJECTED_IVM_GLOBAL = 'BUILDER_IVM';
// Convert all argument references to proxies, and pass `copySync` method to target object, to return a copy of the original JS object
// https://github.com/laverdet/isolated-vm#referencecopysync
const REF_TO_PROXY_FN = `
var refToProxy = (obj) => {
  if (typeof obj !== 'object' || obj === null) {
    return obj;
  }
  return new Proxy({}, {
    get(target, key) {
        if (key === 'copySync') {
          return () => obj.copySync();
        }
        const val = obj.getSync(key);
        if (typeof val?.getSync === 'function') {
            return refToProxy(val);
        }
        return val;
    },
    set(target, key, value) {
        const v = typeof value === 'object' ? new ${INJECTED_IVM_GLOBAL}.Reference(value) : value;
        obj.setSync(key, v);
        ${BUILDER_SET_STATE_NAME}(key, value)
    },
    deleteProperty(target, key) {
        obj.deleteSync(key);
    }
  })
}
`;
const processCode = ({ code, args }) => {
    const fnArgs = args.map(([name]) => `var ${name} = refToProxy(${getSyncValName(name)}); `).join('');
    // the output is stringified and parsed back to the parent isolate if needed (when it's an `object`)
    return `
${REF_TO_PROXY_FN}
${fnArgs}
function theFunction() {
  ${code}
}

const output = theFunction()

if (typeof output === 'object' && output !== null) {
  return JSON.stringify(output.copySync ? output.copySync() : output);
} else {
  return output;
}
`;
};
let IVM_INSTANCE = null;
let IVM_CONTEXT = null;
/**
 * Set the `isolated-vm` instance to be used by the node runtime.
 * This is useful for environments that are not able to rely on our
 * `safeDynamicRequire` trick to import the `isolated-vm` package.
 */
export const setIvm = (ivm, options = {}) => {
    if (IVM_INSTANCE)
        return;
    IVM_INSTANCE = ivm;
    setIsolateContext(options);
};
// only mention the script for SDKs that have it.
const SHOULD_MENTION_INITIALIZE_SCRIPT = SDK_NAME === '@builder.io/sdk-react-nextjs' || SDK_NAME === '@builder.io/sdk-react' || SDK_NAME === '@builder.io/sdk-qwik' || SDK_NAME === '@builder.io/sdk-vue';
const getIvm = () => {
    try {
        if (IVM_INSTANCE)
            return IVM_INSTANCE;
        const dynRequiredIvm = safeDynamicRequire('isolated-vm');
        if (dynRequiredIvm)
            return dynRequiredIvm;
    }
    catch (error) {
        logger.error('isolated-vm import error.', error);
    }
    const ERROR_MESSAGE = `${MSG_PREFIX}could not import \`isolated-vm\` module for safe script execution on a Node server.
    
    SOLUTION: In a server-only execution path within your application, do one of the following:
  
    ${SHOULD_MENTION_INITIALIZE_SCRIPT ? `- import and call \`initializeNodeRuntime()\` from "${SDK_NAME}/node/init".` : ''}
    - add the following import: \`await import('isolated-vm')\`.

    For more information, visit https://builder.io/c/docs/integration-tips#enabling-data-bindings-in-node-environments`;
    throw new Error(ERROR_MESSAGE);
};
function setIsolateContext(options = {
    memoryLimit: 128
}) {
    if (IVM_CONTEXT)
        return IVM_CONTEXT;
    const ivm = getIvm();
    const isolate = new ivm.Isolate(options);
    const context = isolate.createContextSync();
    const jail = context.global;
    // This makes the global object available in the context as `global`. We use `derefInto()` here
    // because otherwise `global` would actually be a Reference{} object in the new isolate.
    jail.setSync('global', jail.derefInto());
    // We will create a basic `log` function for the new isolate to use.
    jail.setSync('log', function (...logArgs) {
        console.log(...logArgs);
    });
    jail.setSync(INJECTED_IVM_GLOBAL, ivm);
    IVM_CONTEXT = context;
    return context;
}
const getIsolateContext = () => {
    return setIsolateContext();
};
export const runInNode = ({ code, builder, context, event, localState, rootSetState, rootState }) => {
    const ivm = getIvm();
    const state = fastClone({
        ...rootState,
        ...localState
    });
    const args = getFunctionArguments({
        builder,
        context,
        event,
        state
    });
    const isolateContext = getIsolateContext();
    const jail = isolateContext.global;
    /**
     * Propagate state changes back to the reactive root state.
     */
    jail.setSync(BUILDER_SET_STATE_NAME, function (key, value) {
        // mutate the `rootState` object itself. Important for cases where we do not have `rootSetState`
        // like Qwik.
        set(rootState, key, value);
        // call the `rootSetState` function if it exists
        rootSetState?.(rootState);
    });
    args.forEach(([key, arg]) => {
        const val = typeof arg === 'object' ? new ivm.Reference(
        // workaround: methods with default values for arguments is not being cloned over
        key === 'builder' ? {
            ...arg,
            getUserAttributes: () => arg.getUserAttributes()
        } : arg) : null;
        jail.setSync(getSyncValName(key), val);
    });
    const evalStr = processCode({
        code,
        args
    });
    const resultStr = isolateContext.evalClosureSync(evalStr);
    try {
        // returning objects throw errors in isolated vm, so we stringify it and parse it back
        const res = JSON.parse(resultStr);
        return res;
    }
    catch (_error) {
        return resultStr;
    }
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZS1ydW50aW1lLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vc3JjL2Z1bmN0aW9ucy9ldmFsdWF0ZS9ub2RlLXJ1bnRpbWUvbm9kZS1ydW50aW1lLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSw2QkFBNkIsQ0FBQztBQUN2RCxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQzdELE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUM3QyxPQUFPLEVBQUUsR0FBRyxFQUFFLE1BQU0sV0FBVyxDQUFDO0FBRWhDLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLFlBQVksQ0FBQztBQUNsRCxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUMxRCxNQUFNLGNBQWMsR0FBRyxDQUFDLEdBQVcsRUFBRSxFQUFFLENBQUMsUUFBUSxHQUFHLE9BQU8sQ0FBQztBQUMzRCxNQUFNLHNCQUFzQixHQUFHLG1CQUFtQixDQUFDO0FBQ25ELE1BQU0sbUJBQW1CLEdBQUcsYUFBYSxDQUFDO0FBRTFDLHNJQUFzSTtBQUN0SSw0REFBNEQ7QUFDNUQsTUFBTSxlQUFlLEdBQUc7Ozs7Ozs7Ozs7Ozs7Ozs7O29EQWlCNEIsbUJBQW1COztVQUU3RCxzQkFBc0I7Ozs7Ozs7Q0FPL0IsQ0FBQztBQUNGLE1BQU0sV0FBVyxHQUFHLENBQUMsRUFDbkIsSUFBSSxFQUNKLElBQUksRUFJTCxFQUFFLEVBQUU7SUFDSCxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsT0FBTyxJQUFJLGlCQUFpQixjQUFjLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUVwRyxvR0FBb0c7SUFD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O1FBQ3RGLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDbEMsT0FBTyxHQUFHLENBQUM7S0FDWjtJQUFDLE9BQU8sTUFBVyxFQUFFO1FBQ3BCLE9BQU8sU0FBUyxDQUFDO0tBQ2xCO0FBQ0gsQ0FBQyxDQUFBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBDb250ZXh0LCBJc29sYXRlT3B0aW9ucyB9IGZyb20gJ2lzb2xhdGVkLXZtJztcbmltcG9ydCB7IFNES19OQU1FIH0gZnJvbSAnLi4vLi4vLi4vY29uc3RhbnRzL3Nkay1uYW1lJztcbmltcG9ydCB7IE1TR19QUkVGSVgsIGxvZ2dlciB9IGZyb20gJy4uLy4uLy4uL2hlbHBlcnMvbG9nZ2VyJztcbmltcG9ydCB7IGZhc3RDbG9uZSB9IGZyb20gJy4uLy4uL2Zhc3QtY2xvbmUnO1xuaW1wb3J0IHsgc2V0IH0gZnJvbSAnLi4vLi4vc2V0JztcbmltcG9ydCB0eXBlIHsgQnVpbGRlckdsb2JhbHMsIEV4ZWN1dG9yQXJncywgRnVuY3Rpb25Bcmd1bWVudHMgfSBmcm9tICcuLi9oZWxwZXJzJztcbmltcG9ydCB7IGdldEZ1bmN0aW9uQXJndW1lbnRzIH0gZnJvbSAnLi4vaGVscGVycyc7XG5pbXBvcnQgeyBzYWZlRHluYW1pY1JlcXVpcmUgfSBmcm9tICcuL3NhZmVEeW5hbWljUmVxdWlyZSc7XG5jb25zdCBnZXRTeW5jVmFsTmFtZSA9IChrZXk6IHN0cmluZykgPT4gYGJsZHJfJHtrZXl9X3N5bmNgO1xuY29uc3QgQlVJTERFUl9TRVRfU1RBVEVfTkFNRSA9ICdCVUlMREVSX1NFVF9TVEFURSc7XG5jb25zdCBJTkpFQ1RFRF9JVk1fR0xPQkFMID0gJ0JVSUxERVJfSVZNJztcblxuLy8gQ29udmVydCBhbGwgYXJndW1lbnQgcmVmZXJlbmNlcyB0byBwcm94aWVzLCBhbmQgcGFzcyBgY29weVN5bmNgIG1ldGhvZCB0byB0YXJnZXQgb2JqZWN0LCB0byByZXR1cm4gYSBjb3B5IG9mIHRoZSBvcmlnaW5hbCBKUyBvYmplY3Rcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9sYXZlcmRldC9pc29sYXRlZC12bSNyZWZlcmVuY2Vjb3B5c3luY1xuY29uc3QgUkVGX1RPX1BST1hZX0ZOID0gYFxudmFyIHJlZlRvUHJveHkgPSAob2JqKSA9PiB7XG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG4gIHJldHVybiBuZXcgUHJveHkoe30sIHtcbiAgICBnZXQodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gJ2NvcHlTeW5jJykge1xuICAgICAgICAgIHJldHVybiAoKSA9PiBvYmouY29weVN5bmMoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWwgPSBvYmouZ2V0U3luYyhrZXkpO1xuICAgICAgICBpZiAodHlwZW9mIHZhbD8uZ2V0U3luYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIHJlZlRvUHJveHkodmFsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH0sXG4gICAgc2V0KHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgICAgICBjb25zdCB2ID0gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyA/IG5ldyAke0lOSkVDVEVEX0lWTV9HTE9CQUx9LlJlZmVyZW5jZSh2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgb2JqLnNldFN5bmMoa2V5LCB2KTtcbiAgICAgICAgJHtCVUlMREVSX1NFVF9TVEFURV9OQU1FfShrZXksIHZhbHVlKVxuICAgIH0sXG4gICAgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgb2JqLmRlbGV0ZVN5bmMoa2V5KTtcbiAgICB9XG4gIH0pXG59XG5gO1xuY29uc3QgcHJvY2Vzc0NvZGUgPSAoe1xuICBjb2RlLFxuICBhcmdzXG59OiB7XG4gIGNvZGU6IHN0cmluZztcbiAgYXJnczogRnVuY3Rpb25Bcmd1bWVudHM7XG59KSA9PiB7XG4gIGNvbnN0IGZuQXJncyA9IGFyZ3MubWFwKChbbmFtZV0pID0+IGB2YXIgJHtuYW1lfSA9IHJlZlRvUHJveHkoJHtnZXRTeW5jVmFsTmFtZShuYW1lKX0pOyBgKS5qb2luKCcnKTtcblxuICAvLyB0aGUgb3V0cHV0IGlzIHN0cmluZ2lmaWVkIGFuZCBwYXJzZWQgYmFjayB0byB0aGUgcGFyZW50IGlzb2xhdGUgaWYgbmVlZGVkICh3aGVuIGl0J3MgYW4gYG9iamVjdGApXG4gIHJldHVybiBgXG4ke1JFRl9UT19QUk9YWV9GTn1cbiR7Zm5BcmdzfVxuZnVuY3Rpb24gdGhlRnVuY3Rpb24oKSB7XG4gICR7Y29kZX1cbn1cblxuY29uc3Qgb3V0cHV0ID0gdGhlRnVuY3Rpb24oKVxuXG5pZiAodHlwZW9mIG91dHB1dCA9PT0gJ29iamVjdCcgJiYgb3V0cHV0ICE9PSBudWxsKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShvdXRwdXQuY29weVN5bmMgPyBvdXRwdXQuY29weVN5bmMoKSA6IG91dHB1dCk7XG59IGVsc2Uge1xuICByZXR1cm4gb3V0cHV0O1xufVxuYDtcbn07XG50eXBlIElzb2xhdGVkVk1JbXBvcnQgPSB0eXBlb2YgaW1wb3J0KCdpc29sYXRlZC12bScpO1xubGV0IElWTV9JTlNUQU5DRTogSXNvbGF0ZWRWTUltcG9ydCB8IG51bGwgPSBudWxsO1xubGV0IElWTV9DT05URVhUOiBDb250ZXh0IHwgbnVsbCA9IG51bGw7XG5cbi8qKlxuICogU2V0IHRoZSBgaXNvbGF0ZWQtdm1gIGluc3RhbmNlIHRvIGJlIHVzZWQgYnkgdGhlIG5vZGUgcnVudGltZS5cbiAqIFRoaXMgaXMgdXNlZnVsIGZvciBlbnZpcm9ubWVudHMgdGhhdCBhcmUgbm90IGFibGUgdG8gcmVseSBvbiBvdXJcbiAqIGBzYWZlRHluYW1pY1JlcXVpcmVgIHRyaWNrIHRvIGltcG9ydCB0aGUgYGlzb2xhdGVkLXZtYCBwYWNrYWdlLlxuICovXG5leHBvcnQgY29uc3Qgc2V0SXZtID0gKGl2bTogSXNvbGF0ZWRWTUltcG9ydCwgb3B0aW9uczogSXNvbGF0ZU9wdGlvbnMgPSB7fSkgPT4ge1xuICBpZiAoSVZNX0lOU1RBTkNFKSByZXR1cm47XG4gIElWTV9JTlNUQU5DRSA9IGl2bTtcbiAgc2V0SXNvbGF0ZUNvbnRleHQob3B0aW9ucyk7XG59O1xuXG4vLyBvbmx5IG1lbnRpb24gdGhlIHNjcmlwdCBmb3IgU0RLcyB0aGF0IGhhdmUgaXQuXG5jb25zdCBTSE9VTERfTUVOVElPTl9JTklUSUFMSVpFX1NDUklQVCA9IFNES19OQU1FID09PSAnQGJ1aWxkZXIuaW8vc2RrLXJlYWN0LW5leHRqcycgfHwgU0RLX05BTUUgPT09ICdAYnVpbGRlci5pby9zZGstcmVhY3QnIHx8IFNES19OQU1FID09PSAnQGJ1aWxkZXIuaW8vc2RrLXF3aWsnIHx8IFNES19OQU1FID09PSAnQGJ1aWxkZXIuaW8vc2RrLXZ1ZSc7XG5jb25zdCBnZXRJdm0gPSAoKTogSXNvbGF0ZWRWTUltcG9ydCA9PiB7XG4gIHRyeSB7XG4gICAgaWYgKElWTV9JTlNUQU5DRSkgcmV0dXJuIElWTV9JTlNUQU5DRTtcbiAgICBjb25zdCBkeW5SZXF1aXJlZEl2bSA9IHNhZmVEeW5hbWljUmVxdWlyZSgnaXNvbGF0ZWQtdm0nKTtcbiAgICBpZiAoZHluUmVxdWlyZWRJdm0pIHJldHVybiBkeW5SZXF1aXJlZEl2bTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBsb2dnZXIuZXJyb3IoJ2lzb2xhdGVkLXZtIGltcG9ydCBlcnJvci4nLCBlcnJvcik7XG4gIH1cbiAgY29uc3QgRVJST1JfTUVTU0FHRSA9IGAke01TR19QUkVGSVh9Y291bGQgbm90IGltcG9ydCBcXGBpc29sYXRlZC12bVxcYCBtb2R1bGUgZm9yIHNhZmUgc2NyaXB0IGV4ZWN1dGlvbiBvbiBhIE5vZGUgc2VydmVyLlxuICAgIFxuICAgIFNPTFVUSU9OOiBJbiBhIHNlcnZlci1vbmx5IGV4ZWN1dGlvbiBwYXRoIHdpdGhpbiB5b3VyIGFwcGxpY2F0aW9uLCBkbyBvbmUgb2YgdGhlIGZvbGxvd2luZzpcbiAgXG4gICAgJHtTSE9VTERfTUVOVElPTl9JTklUSUFMSVpFX1NDUklQVCA/IGAtIGltcG9ydCBhbmQgY2FsbCBcXGBpbml0aWFsaXplTm9kZVJ1bnRpbWUoKVxcYCBmcm9tIFwiJHtTREtfTkFNRX0vbm9kZS9pbml0XCIuYCA6ICcnfVxuICAgIC0gYWRkIHRoZSBmb2xsb3dpbmcgaW1wb3J0OiBcXGBhd2FpdCBpbXBvcnQoJ2lzb2xhdGVkLXZtJylcXGAuXG5cbiAgICBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgdmlzaXQgaHR0cHM6Ly9idWlsZGVyLmlvL2MvZG9jcy9pbnRlZ3JhdGlvbi10aXBzI2VuYWJsaW5nLWRhdGEtYmluZGluZ3MtaW4tbm9kZS1lbnZpcm9ubWVudHNgO1xuICB0aHJvdyBuZXcgRXJyb3IoRVJST1JfTUVTU0FHRSk7XG59O1xuZnVuY3Rpb24gc2V0SXNvbGF0ZUNvbnRleHQob3B0aW9uczogSXNvbGF0ZU9wdGlvbnMgPSB7XG4gIG1lbW9yeUxpbWl0OiAxMjhcbn0pIHtcbiAgaWYgKElWTV9DT05URVhUKSByZXR1cm4gSVZNX0NPTlRFWFQ7XG4gIGNvbnN0IGl2bSA9IGdldEl2bSgpO1xuICBjb25zdCBpc29sYXRlID0gbmV3IGl2bS5Jc29sYXRlKG9wdGlvbnMpO1xuICBjb25zdCBjb250ZXh0ID0gaXNvbGF0ZS5jcmVhdGVDb250ZXh0U3luYygpO1xuICBjb25zdCBqYWlsID0gY29udGV4dC5nbG9iYWw7XG5cbiAgLy8gVGhpcyBtYWtlcyB0aGUgZ2xvYmFsIG9iamVjdCBhdmFpbGFibGUgaW4gdGhlIGNvbnRleHQgYXMgYGdsb2JhbGAuIFdlIHVzZSBgZGVyZWZJbnRvKClgIGhlcmVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2UgYGdsb2JhbGAgd291bGQgYWN0dWFsbHkgYmUgYSBSZWZlcmVuY2V7fSBvYmplY3QgaW4gdGhlIG5ldyBpc29sYXRlLlxuICBqYWlsLnNldFN5bmMoJ2dsb2JhbCcsIGphaWwuZGVyZWZJbnRvKCkpO1xuXG4gIC8vIFdlIHdpbGwgY3JlYXRlIGEgYmFzaWMgYGxvZ2AgZnVuY3Rpb24gZm9yIHRoZSBuZXcgaXNvbGF0ZSB0byB1c2UuXG4gIGphaWwuc2V0U3luYygnbG9nJywgZnVuY3Rpb24gKC4uLmxvZ0FyZ3M6IGFueVtdKSB7XG4gICAgY29uc29sZS5sb2coLi4ubG9nQXJncyk7XG4gIH0pO1xuICBqYWlsLnNldFN5bmMoSU5KRUNURURfSVZNX0dMT0JBTCwgaXZtKTtcbiAgSVZNX0NPTlRFWFQgPSBjb250ZXh0O1xuICByZXR1cm4gY29udGV4dDtcbn1cbmNvbnN0IGdldElzb2xhdGVDb250ZXh0ID0gKCkgPT4ge1xuICByZXR1cm4gc2V0SXNvbGF0ZUNvbnRleHQoKTtcbn07XG5leHBvcnQgY29uc3QgcnVuSW5Ob2RlID0gKHtcbiAgY29kZSxcbiAgYnVpbGRlcixcbiAgY29udGV4dCxcbiAgZXZlbnQsXG4gIGxvY2FsU3RhdGUsXG4gIHJvb3RTZXRTdGF0ZSxcbiAgcm9vdFN0YXRlXG59OiBFeGVjdXRvckFyZ3MpID0+IHtcbiAgY29uc3QgaXZtID0gZ2V0SXZtKCk7XG4gIGNvbnN0IHN0YXRlID0gZmFzdENsb25lKHtcbiAgICAuLi5yb290U3RhdGUsXG4gICAgLi4ubG9jYWxTdGF0ZVxuICB9KTtcbiAgY29uc3QgYXJncyA9IGdldEZ1bmN0aW9uQXJndW1lbnRzKHtcbiAgICBidWlsZGVyLFxuICAgIGNvbnRleHQsXG4gICAgZXZlbnQsXG4gICAgc3RhdGVcbiAgfSk7XG4gIGNvbnN0IGlzb2xhdGVDb250ZXh0ID0gZ2V0SXNvbGF0ZUNvbnRleHQoKTtcbiAgY29uc3QgamFpbCA9IGlzb2xhdGVDb250ZXh0Lmdsb2JhbDtcblxuICAvKipcbiAgICogUHJvcGFnYXRlIHN0YXRlIGNoYW5nZXMgYmFjayB0byB0aGUgcmVhY3RpdmUgcm9vdCBzdGF0ZS5cbiAgICovXG4gIGphaWwuc2V0U3luYyhCVUlMREVSX1NFVF9TVEFURV9OQU1FLCBmdW5jdGlvbiAoa2V5OiBzdHJpbmcsIHZhbHVlOiBhbnkpIHtcbiAgICAvLyBtdXRhdGUgdGhlIGByb290U3RhdGVgIG9iamVjdCBpdHNlbGYuIEltcG9ydGFudCBmb3IgY2FzZXMgd2hlcmUgd2UgZG8gbm90IGhhdmUgYHJvb3RTZXRTdGF0ZWBcbiAgICAvLyBsaWtlIFF3aWsuXG4gICAgc2V0KHJvb3RTdGF0ZSwga2V5LCB2YWx1ZSk7XG4gICAgLy8gY2FsbCB0aGUgYHJvb3RTZXRTdGF0ZWAgZnVuY3Rpb24gaWYgaXQgZXhpc3RzXG4gICAgcm9vdFNldFN0YXRlPy4ocm9vdFN0YXRlKTtcbiAgfSk7XG4gIGFyZ3MuZm9yRWFjaCgoW2tleSwgYXJnXSkgPT4ge1xuICAgIGNvbnN0IHZhbCA9IHR5cGVvZiBhcmcgPT09ICdvYmplY3QnID8gbmV3IGl2bS5SZWZlcmVuY2UoXG4gICAgLy8gd29ya2Fyb3VuZDogbWV0aG9kcyB3aXRoIGRlZmF1bHQgdmFsdWVzIGZvciBhcmd1bWVudHMgaXMgbm90IGJlaW5nIGNsb25lZCBvdmVyXG4gICAga2V5ID09PSAnYnVpbGRlcicgPyB7XG4gICAgICAuLi5hcmcsXG4gICAgICBnZXRVc2VyQXR0cmlidXRlczogKCkgPT4gKGFyZyBhcyBCdWlsZGVyR2xvYmFscykuZ2V0VXNlckF0dHJpYnV0ZXMoKVxuICAgIH0gOiBhcmcpIDogbnVsbDtcbiAgICBqYWlsLnNldFN5bmMoZ2V0U3luY1ZhbE5hbWUoa2V5KSwgdmFsKTtcbiAgfSk7XG4gIGNvbnN0IGV2YWxTdHIgPSBwcm9jZXNzQ29kZSh7XG4gICAgY29kZSxcbiAgICBhcmdzXG4gIH0pO1xuICBjb25zdCByZXN1bHRTdHIgPSBpc29sYXRlQ29udGV4dC5ldmFsQ2xvc3VyZVN5bmMoZXZhbFN0cik7XG4gIHRyeSB7XG4gICAgLy8gcmV0dXJuaW5nIG9iamVjdHMgdGhyb3cgZXJyb3JzIGluIGlzb2xhdGVkIHZtLCBzbyB3ZSBzdHJpbmdpZnkgaXQgYW5kIHBhcnNlIGl0IGJhY2tcbiAgICBjb25zdCByZXMgPSBKU09OLnBhcnNlKHJlc3VsdFN0cik7XG4gICAgcmV0dXJuIHJlcztcbiAgfSBjYXRjaCAoX2Vycm9yOiBhbnkpIHtcbiAgICByZXR1cm4gcmVzdWx0U3RyO1xuICB9XG59Il19