import { logger } from '../../helpers/logger';
import { get } from '../get';
import { chooseBrowserOrServerEval } from './choose-eval';
import { getBuilderGlobals, parseCode } from './helpers';
/**
 * handles multi-level gets on state: `state.x.y.z`
 * does not handle bracket notation
 * see https://regexr.com/87a9j
 */
const STATE_GETTER_REGEX = /^(return )?(\s*)?state(?<getPath>(\.\w+)+)(\s*);?$/;
/**
 * Handles multi-level gets on state transpiled by rollup with virtual index.
 * see https://regexr.com/87ai4
 */
const VIRTUAL_INDEX_REGEX = /(\s)*var(\s)+_virtual_index(\s)*=(\s)*state(?<getPath>(\.\w+)+)(\s*);?(\s)*return(\s)*_virtual_index(\s)*/;
export const getSimpleExpressionGetPath = (code) => {
    return STATE_GETTER_REGEX.exec(code.trim())?.groups?.getPath?.slice(1) || VIRTUAL_INDEX_REGEX.exec(code.trim())?.groups?.getPath?.slice(1);
};
export function evaluate({ code, context, localState, rootState, rootSetState, event, isExpression = true }) {
    if (code.trim() === '') {
        return undefined;
    }
    /**
     * For very simple expressions like "state.foo" we can optimize by skipping
     * the executor altogether.
     * We try not to take many risks with this optimizations, so we only do it for
     * `state.{path}` expressions.
     */
    const getPath = getSimpleExpressionGetPath(code.trim());
    if (getPath) {
        return get({
            ...rootState,
            ...localState
        }, getPath);
    }
    const args = {
        code: parseCode(code, {
            isExpression
        }),
        builder: getBuilderGlobals(),
        context,
        event,
        rootSetState,
        rootState,
        localState
    };
    try {
        const newEval = chooseBrowserOrServerEval(args);
        return newEval;
    }
    catch (e) {
        logger.error('Failed code evaluation: ' + e.message, {
            code
        });
        return undefined;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXZhbHVhdGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvZnVuY3Rpb25zL2V2YWx1YXRlL2V2YWx1YXRlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUM5QyxPQUFPLEVBQUUsR0FBRyxFQUFFLE1BQU0sUUFBUSxDQUFDO0FBQzdCLE9BQU8sRUFBRSx5QkFBeUIsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUUxRCxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsU0FBUyxFQUFFLE1BQU0sV0FBVyxDQUFDO0FBR3pEOzs7O0dBSUc7QUFDSCxNQUFNLGtCQUFrQixHQUFHLG9EQUFvRCxDQUFDO0FBRWhGOzs7R0FHRztBQUNILE1BQU0sbUJBQW1CLEdBQUcsMkdBQTJHLENBQUM7QUFDeEksTUFBTSxDQUFDLE1BQU0sMEJBQTBCLEdBQUcsQ0FBQyxJQUFZLEVBQUUsRUFBRTtJQUN6RCxPQUFPLGtCQUFrQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRSxNQUFNLEVBQUUsT0FBTyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDN0ksQ0FBQyxDQUFDO0FBQ0YsTUFBTSxVQUFVLFFBQVEsQ0FBQyxFQUN2QixJQUFJLEVBQ0osT0FBTyxFQUNQLFVBQVUsRUFDVixTQUFTLEVBQ1QsWUFBWSxFQUNaLEtBQUssRUFDTCxZQUFZLEdBQUcsSUFBSSxFQUNMO0lBQ2QsSUFBSSxJQUFJLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxFQUFFO1FBQ3RCLE9BQU8sU0FBUyxDQUFDO0tBQ2xCO0lBRUQ7Ozs7O09BS0c7SUFDSCxNQUFNLE9BQU8sR0FBRywwQkFBMEIsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQztJQUN4RCxJQUFJLE9BQU8sRUFBRTtRQUNYLE9BQU8sR0FBRyxDQUFDO1lBQ1QsR0FBRyxTQUFTO1lBQ1osR0FBRyxVQUFVO1NBQ2QsRUFBRSxPQUFPLENBQUMsQ0FBQztLQUNiO0lBQ0QsTUFBTSxJQUFJLEdBQWlCO1FBQ3pCLElBQUksRUFBRSxTQUFTLENBQUMsSUFBSSxFQUFFO1lBQ3BCLFlBQVk7U0FDYixDQUFDO1FBQ0YsT0FBTyxFQUFFLGlCQUFpQixFQUFFO1FBQzVCLE9BQU87UUFDUCxLQUFLO1FBQ0wsWUFBWTtRQUNaLFNBQVM7UUFDVCxVQUFVO0tBQ1gsQ0FBQztJQUNGLElBQUk7UUFDRixNQUFNLE9BQU8sR0FBRyx5QkFBeUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNoRCxPQUFPLE9BQU8sQ0FBQztLQUNoQjtJQUFDLE9BQU8sQ0FBTSxFQUFFO1FBQ2YsTUFBTSxDQUFDLEtBQUssQ0FBQywwQkFBMEIsR0FBRyxDQUFDLENBQUMsT0FBTyxFQUFFO1lBQ25ELElBQUk7U0FDTCxDQUFDLENBQUM7UUFDSCxPQUFPLFNBQVMsQ0FBQztLQUNsQjtBQUNILENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi8uLi9oZWxwZXJzL2xvZ2dlcic7XG5pbXBvcnQgeyBnZXQgfSBmcm9tICcuLi9nZXQnO1xuaW1wb3J0IHsgY2hvb3NlQnJvd3Nlck9yU2VydmVyRXZhbCB9IGZyb20gJy4vY2hvb3NlLWV2YWwnO1xuaW1wb3J0IHR5cGUgeyBFdmFsdWF0b3JBcmdzLCBFeGVjdXRvckFyZ3MgfSBmcm9tICcuL2hlbHBlcnMnO1xuaW1wb3J0IHsgZ2V0QnVpbGRlckdsb2JhbHMsIHBhcnNlQ29kZSB9IGZyb20gJy4vaGVscGVycyc7XG50eXBlIEV2YWxWYWx1ZSA9IHVua25vd247XG5cbi8qKlxuICogaGFuZGxlcyBtdWx0aS1sZXZlbCBnZXRzIG9uIHN0YXRlOiBgc3RhdGUueC55LnpgXG4gKiBkb2VzIG5vdCBoYW5kbGUgYnJhY2tldCBub3RhdGlvblxuICogc2VlIGh0dHBzOi8vcmVnZXhyLmNvbS84N2E5alxuICovXG5jb25zdCBTVEFURV9HRVRURVJfUkVHRVggPSAvXihyZXR1cm4gKT8oXFxzKik/c3RhdGUoPzxnZXRQYXRoPihcXC5cXHcrKSspKFxccyopOz8kLztcblxuLyoqXG4gKiBIYW5kbGVzIG11bHRpLWxldmVsIGdldHMgb24gc3RhdGUgdHJhbnNwaWxlZCBieSByb2xsdXAgd2l0aCB2aXJ0dWFsIGluZGV4LlxuICogc2VlIGh0dHBzOi8vcmVnZXhyLmNvbS84N2FpNFxuICovXG5jb25zdCBWSVJUVUFMX0lOREVYX1JFR0VYID0gLyhcXHMpKnZhcihcXHMpK192aXJ0dWFsX2luZGV4KFxccykqPShcXHMpKnN0YXRlKD88Z2V0UGF0aD4oXFwuXFx3KykrKShcXHMqKTs/KFxccykqcmV0dXJuKFxccykqX3ZpcnR1YWxfaW5kZXgoXFxzKSovO1xuZXhwb3J0IGNvbnN0IGdldFNpbXBsZUV4cHJlc3Npb25HZXRQYXRoID0gKGNvZGU6IHN0cmluZykgPT4ge1xuICByZXR1cm4gU1RBVEVfR0VUVEVSX1JFR0VYLmV4ZWMoY29kZS50cmltKCkpPy5ncm91cHM/LmdldFBhdGg/LnNsaWNlKDEpIHx8IFZJUlRVQUxfSU5ERVhfUkVHRVguZXhlYyhjb2RlLnRyaW0oKSk/Lmdyb3Vwcz8uZ2V0UGF0aD8uc2xpY2UoMSk7XG59O1xuZXhwb3J0IGZ1bmN0aW9uIGV2YWx1YXRlKHtcbiAgY29kZSxcbiAgY29udGV4dCxcbiAgbG9jYWxTdGF0ZSxcbiAgcm9vdFN0YXRlLFxuICByb290U2V0U3RhdGUsXG4gIGV2ZW50LFxuICBpc0V4cHJlc3Npb24gPSB0cnVlXG59OiBFdmFsdWF0b3JBcmdzKTogRXZhbFZhbHVlIHtcbiAgaWYgKGNvZGUudHJpbSgpID09PSAnJykge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogRm9yIHZlcnkgc2ltcGxlIGV4cHJlc3Npb25zIGxpa2UgXCJzdGF0ZS5mb29cIiB3ZSBjYW4gb3B0aW1pemUgYnkgc2tpcHBpbmdcbiAgICogdGhlIGV4ZWN1dG9yIGFsdG9nZXRoZXIuXG4gICAqIFdlIHRyeSBub3QgdG8gdGFrZSBtYW55IHJpc2tzIHdpdGggdGhpcyBvcHRpbWl6YXRpb25zLCBzbyB3ZSBvbmx5IGRvIGl0IGZvclxuICAgKiBgc3RhdGUue3BhdGh9YCBleHByZXNzaW9ucy5cbiAgICovXG4gIGNvbnN0IGdldFBhdGggPSBnZXRTaW1wbGVFeHByZXNzaW9uR2V0UGF0aChjb2RlLnRyaW0oKSk7XG4gIGlmIChnZXRQYXRoKSB7XG4gICAgcmV0dXJuIGdldCh7XG4gICAgICAuLi5yb290U3RhdGUsXG4gICAgICAuLi5sb2NhbFN0YXRlXG4gICAgfSwgZ2V0UGF0aCk7XG4gIH1cbiAgY29uc3QgYXJnczogRXhlY3V0b3JBcmdzID0ge1xuICAgIGNvZGU6IHBhcnNlQ29kZShjb2RlLCB7XG4gICAgICBpc0V4cHJlc3Npb25cbiAgICB9KSxcbiAgICBidWlsZGVyOiBnZXRCdWlsZGVyR2xvYmFscygpLFxuICAgIGNvbnRleHQsXG4gICAgZXZlbnQsXG4gICAgcm9vdFNldFN0YXRlLFxuICAgIHJvb3RTdGF0ZSxcbiAgICBsb2NhbFN0YXRlXG4gIH07XG4gIHRyeSB7XG4gICAgY29uc3QgbmV3RXZhbCA9IGNob29zZUJyb3dzZXJPclNlcnZlckV2YWwoYXJncyk7XG4gICAgcmV0dXJuIG5ld0V2YWw7XG4gIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgIGxvZ2dlci5lcnJvcignRmFpbGVkIGNvZGUgZXZhbHVhdGlvbjogJyArIGUubWVzc2FnZSwge1xuICAgICAgY29kZVxuICAgIH0pO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn0iXX0=