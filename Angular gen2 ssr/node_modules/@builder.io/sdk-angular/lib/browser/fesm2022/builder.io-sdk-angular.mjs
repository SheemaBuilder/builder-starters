import * as i0 from '@angular/core';
import { Component, Input, ViewChild, ElementRef, Injectable, Inject, reflectComponentType, forwardRef, PLATFORM_ID, ChangeDetectionStrategy } from '@angular/core';
import * as i1 from '@angular/common';
import { CommonModule, DOCUMENT, isPlatformBrowser } from '@angular/common';
import * as i1$1 from '@angular/platform-browser';

// no-op
// this file exists in case a target needs to add logic to the top of the index file in an
// override.
var undefined$1 = undefined;

/**
 * https://developer.mozilla.org/en-US/docs/Glossary/Empty_element
 */
const EMPTY_HTML_ELEMENTS = new Set(['area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr']);
const isEmptyElement = (tagName) => {
    return typeof tagName === 'string' && EMPTY_HTML_ELEMENTS.has(tagName.toLowerCase());
};

class DynamicRenderer {
    useTypeOf(obj) {
        return typeof obj;
    }
    constructor(vcRef) {
        this.vcRef = vcRef;
        this.isEmptyElement = isEmptyElement;
    }
    ngOnInit() {
        if (typeof this.TagName === 'string') {
            switch (this.TagName) {
                case 'a':
                    this.TagName = DynamicA;
                    break;
                case 'button':
                    this.TagName = DynamicButton;
                    break;
                case 'div':
                    this.TagName = DynamicDiv$1;
                    break;
                case 'span':
                    this.TagName = DynamicSpan;
                    break;
                case 'p':
                    this.TagName = DynamicP;
                    break;
                case 'img':
                    this.TagName = DynamicImg;
                    break;
                case 'input':
                    this.TagName = DynamicInput;
                    break;
                case 'textarea':
                    this.TagName = DynamicTextarea;
                    break;
                case 'select':
                    this.TagName = DynamicSelect;
                    break;
                case 'option':
                    this.TagName = DynamicOption;
                    break;
                case 'form':
                    this.TagName = DynamicForm;
                    break;
                case 'label':
                    this.TagName = DynamicLabel;
                    break;
                case 'ul':
                    this.TagName = DynamicUl;
                    break;
                case 'li':
                    this.TagName = DynamicLi;
                    break;
                case 'table':
                    this.TagName = DynamicTable;
                    break;
                case 'tr':
                    this.TagName = DynamicTr;
                    break;
                case 'td':
                    this.TagName = DynamicTd;
                    break;
                case 'th':
                    this.TagName = DynamicTh;
                    break;
                case 'thead':
                    this.TagName = DynamicThead;
                    break;
                case 'tbody':
                    this.TagName = DynamicTbody;
                    break;
                case 'footer':
                    this.TagName = DynamicFooter;
                    break;
                case 'header':
                    this.TagName = DynamicHeader;
                    break;
                case 'nav':
                    this.TagName = DynamicNav;
                    break;
                case 'section':
                    this.TagName = DynamicSection;
                    break;
                case 'article':
                    this.TagName = DynamicArticle;
                    break;
                case 'aside':
                    this.TagName = DynamicAside;
                    break;
                case 'h1':
                    this.TagName = DynamicH1;
                    break;
                case 'h2':
                    this.TagName = DynamicH2;
                    break;
                case 'h3':
                    this.TagName = DynamicH3;
                    break;
                case 'h4':
                    this.TagName = DynamicH4;
                    break;
                case 'h5':
                    this.TagName = DynamicH5;
                    break;
                case 'h6':
                    this.TagName = DynamicH6;
                    break;
                case 'blockquote':
                    this.TagName = DynamicBlockquote;
                    break;
                case 'code':
                    this.TagName = DynamicCode;
                    break;
                case 'pre':
                    this.TagName = DynamicPre;
                    break;
                case 'figure':
                    this.TagName = DynamicFigure;
                    break;
                case 'figcaption':
                    this.TagName = DynamicFigcaption;
                    break;
                case 'video':
                    this.TagName = DynamicVideo;
                    break;
                case 'audio':
                    this.TagName = DynamicAudio;
                    break;
                case 'canvas':
                    this.TagName = DynamicCanvas;
                    break;
                case 'iframe':
                    this.TagName = DynamicIframe;
                    break;
                default:
                    break;
            }
        }
        this.myContent = [this.vcRef.createEmbeddedView(this.tagnameTemplateRef).rootNodes];
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicRenderer, deps: [{ token: i0.ViewContainerRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DynamicRenderer, isStandalone: true, selector: "dynamic-renderer, DynamicRenderer", inputs: { TagName: "TagName", attributes: "attributes", actionAttributes: "actionAttributes" }, viewQueries: [{ propertyName: "tagnameTemplateRef", first: true, predicate: ["tagnameTemplate"], descendants: true, static: true }], ngImport: i0, template: `
    <ng-template #tagnameTemplate><ng-content></ng-content></ng-template>
    <ng-container *ngIf="!isEmptyElement(TagName)">
      <ng-container *ngIf="useTypeOf(TagName) === 'string'">
        <ng-container
          *ngComponentOutlet="
            TagName;
            inputs: {
              attributes: attributes,
              actionAttributes: actionAttributes
            };
            content: myContent
          "
        ></ng-container>
      </ng-container>
      <ng-container *ngIf="!(useTypeOf(TagName) === 'string')">
        <ng-container
          *ngComponentOutlet="
            TagName;
            inputs: {
              attributes: attributes,
              actionAttributes: actionAttributes
            };
            content: myContent
          "
        ></ng-container>
      </ng-container>
    </ng-container>
    <ng-container *ngIf="!!isEmptyElement(TagName)">
      <ng-container
        *ngComponentOutlet="
          TagName;
          inputs: {
            attributes: attributes,
            actionAttributes: actionAttributes
          };
          content: myContent
        "
      ></ng-container>
    </ng-container>
  `, isInline: true, styles: [":host{display:contents}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgComponentOutlet, selector: "[ngComponentOutlet]", inputs: ["ngComponentOutlet", "ngComponentOutletInputs", "ngComponentOutletInjector", "ngComponentOutletContent", "ngComponentOutletNgModule", "ngComponentOutletNgModuleFactory"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicRenderer, decorators: [{
            type: Component,
            args: [{ selector: 'dynamic-renderer, DynamicRenderer', template: `
    <ng-template #tagnameTemplate><ng-content></ng-content></ng-template>
    <ng-container *ngIf="!isEmptyElement(TagName)">
      <ng-container *ngIf="useTypeOf(TagName) === 'string'">
        <ng-container
          *ngComponentOutlet="
            TagName;
            inputs: {
              attributes: attributes,
              actionAttributes: actionAttributes
            };
            content: myContent
          "
        ></ng-container>
      </ng-container>
      <ng-container *ngIf="!(useTypeOf(TagName) === 'string')">
        <ng-container
          *ngComponentOutlet="
            TagName;
            inputs: {
              attributes: attributes,
              actionAttributes: actionAttributes
            };
            content: myContent
          "
        ></ng-container>
      </ng-container>
    </ng-container>
    <ng-container *ngIf="!!isEmptyElement(TagName)">
      <ng-container
        *ngComponentOutlet="
          TagName;
          inputs: {
            attributes: attributes,
            actionAttributes: actionAttributes
          };
          content: myContent
        "
      ></ng-container>
    </ng-container>
  `, standalone: true, imports: [CommonModule], styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.ViewContainerRef }]; }, propDecorators: { TagName: [{
                type: Input
            }], attributes: [{
                type: Input
            }], actionAttributes: [{
                type: Input
            }], tagnameTemplateRef: [{
                type: ViewChild,
                args: ['tagnameTemplate', { static: true }]
            }] } });
class DynamicA {
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
    }
    setAttributes(el, value, changes) {
        if (!el)
            return;
        const target = changes ? changes : value;
        Object.keys(target).forEach((key) => {
            if (key.startsWith('on')) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace('on', '').toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key, target[key] ?? '');
            }
        });
    }
    ngAfterViewInit() {
        this.setAttributes(this.v?.nativeElement, this.attributes);
    }
    ngOnChanges(changes) {
        if (changes.attributes) {
            this.setAttributes(this.v?.nativeElement, this.attributes, changes.attributes.currentValue);
        }
    }
    ngOnDestroy() {
        this._listenerFns.forEach(fn => fn());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicA, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DynamicA, isStandalone: true, selector: "dynamic-a, DynamicA", inputs: { attributes: "attributes", actionAttributes: "actionAttributes" }, viewQueries: [{ propertyName: "v", first: true, predicate: ["v"], descendants: true, read: ElementRef }], usesOnChanges: true, ngImport: i0, template: ` <a #v ><ng-content></ng-content></a> `, isInline: true, styles: [":host{display:contents}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicA, decorators: [{
            type: Component,
            args: [{ selector: 'dynamic-a, DynamicA', template: ` <a #v ><ng-content></ng-content></a> `, standalone: true, styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { attributes: [{
                type: Input
            }], actionAttributes: [{
                type: Input
            }], v: [{
                type: ViewChild,
                args: ['v', { read: ElementRef }]
            }] } });
class DynamicButton {
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
    }
    setAttributes(el, value, changes) {
        if (!el)
            return;
        const target = changes ? changes : value;
        Object.keys(target).forEach((key) => {
            if (key.startsWith('on')) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace('on', '').toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key, target[key] ?? '');
            }
        });
    }
    ngAfterViewInit() {
        this.setAttributes(this.v?.nativeElement, this.attributes);
    }
    ngOnChanges(changes) {
        if (changes.attributes) {
            this.setAttributes(this.v?.nativeElement, this.attributes, changes.attributes.currentValue);
        }
    }
    ngOnDestroy() {
        this._listenerFns.forEach(fn => fn());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicButton, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DynamicButton, isStandalone: true, selector: "dynamic-button, DynamicButton", inputs: { attributes: "attributes", actionAttributes: "actionAttributes" }, viewQueries: [{ propertyName: "v", first: true, predicate: ["v"], descendants: true, read: ElementRef }], usesOnChanges: true, ngImport: i0, template: ` <button #v ><ng-content></ng-content></button> `, isInline: true, styles: [":host{display:contents}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicButton, decorators: [{
            type: Component,
            args: [{ selector: 'dynamic-button, DynamicButton', template: ` <button #v ><ng-content></ng-content></button> `, standalone: true, styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { attributes: [{
                type: Input
            }], actionAttributes: [{
                type: Input
            }], v: [{
                type: ViewChild,
                args: ['v', { read: ElementRef }]
            }] } });
let DynamicDiv$1 = class DynamicDiv {
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
    }
    setAttributes(el, value, changes) {
        if (!el)
            return;
        const target = changes ? changes : value;
        Object.keys(target).forEach((key) => {
            if (key.startsWith('on')) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace('on', '').toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key, target[key] ?? '');
            }
        });
    }
    ngAfterViewInit() {
        this.setAttributes(this.v?.nativeElement, this.attributes);
    }
    ngOnChanges(changes) {
        if (changes.attributes) {
            this.setAttributes(this.v?.nativeElement, this.attributes, changes.attributes.currentValue);
        }
    }
    ngOnDestroy() {
        this._listenerFns.forEach(fn => fn());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicDiv, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DynamicDiv, isStandalone: true, selector: "dynamic-div, DynamicDiv", inputs: { attributes: "attributes", actionAttributes: "actionAttributes" }, viewQueries: [{ propertyName: "v", first: true, predicate: ["v"], descendants: true, read: ElementRef }], usesOnChanges: true, ngImport: i0, template: ` <div #v ><ng-content></ng-content></div> `, isInline: true, styles: [":host{display:contents}\n"] }); }
};
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicDiv$1, decorators: [{
            type: Component,
            args: [{ selector: 'dynamic-div, DynamicDiv', template: ` <div #v ><ng-content></ng-content></div> `, standalone: true, styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { attributes: [{
                type: Input
            }], actionAttributes: [{
                type: Input
            }], v: [{
                type: ViewChild,
                args: ['v', { read: ElementRef }]
            }] } });
class DynamicSpan {
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
    }
    setAttributes(el, value, changes) {
        if (!el)
            return;
        const target = changes ? changes : value;
        Object.keys(target).forEach((key) => {
            if (key.startsWith('on')) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace('on', '').toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key, target[key] ?? '');
            }
        });
    }
    ngAfterViewInit() {
        this.setAttributes(this.v?.nativeElement, this.attributes);
    }
    ngOnChanges(changes) {
        if (changes.attributes) {
            this.setAttributes(this.v?.nativeElement, this.attributes, changes.attributes.currentValue);
        }
    }
    ngOnDestroy() {
        this._listenerFns.forEach(fn => fn());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicSpan, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DynamicSpan, isStandalone: true, selector: "dynamic-span, DynamicSpan", inputs: { attributes: "attributes", actionAttributes: "actionAttributes" }, viewQueries: [{ propertyName: "v", first: true, predicate: ["v"], descendants: true, read: ElementRef }], usesOnChanges: true, ngImport: i0, template: ` <span #v ><ng-content></ng-content></span> `, isInline: true, styles: [":host{display:contents}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicSpan, decorators: [{
            type: Component,
            args: [{ selector: 'dynamic-span, DynamicSpan', template: ` <span #v ><ng-content></ng-content></span> `, standalone: true, styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { attributes: [{
                type: Input
            }], actionAttributes: [{
                type: Input
            }], v: [{
                type: ViewChild,
                args: ['v', { read: ElementRef }]
            }] } });
class DynamicP {
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
    }
    setAttributes(el, value, changes) {
        if (!el)
            return;
        const target = changes ? changes : value;
        Object.keys(target).forEach((key) => {
            if (key.startsWith('on')) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace('on', '').toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key, target[key] ?? '');
            }
        });
    }
    ngAfterViewInit() {
        this.setAttributes(this.v?.nativeElement, this.attributes);
    }
    ngOnChanges(changes) {
        if (changes.attributes) {
            this.setAttributes(this.v?.nativeElement, this.attributes, changes.attributes.currentValue);
        }
    }
    ngOnDestroy() {
        this._listenerFns.forEach(fn => fn());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicP, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DynamicP, isStandalone: true, selector: "dynamic-p, DynamicP", inputs: { attributes: "attributes", actionAttributes: "actionAttributes" }, viewQueries: [{ propertyName: "v", first: true, predicate: ["v"], descendants: true, read: ElementRef }], usesOnChanges: true, ngImport: i0, template: ` <p #v ><ng-content></ng-content></p> `, isInline: true, styles: [":host{display:contents}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicP, decorators: [{
            type: Component,
            args: [{ selector: 'dynamic-p, DynamicP', template: ` <p #v ><ng-content></ng-content></p> `, standalone: true, styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { attributes: [{
                type: Input
            }], actionAttributes: [{
                type: Input
            }], v: [{
                type: ViewChild,
                args: ['v', { read: ElementRef }]
            }] } });
class DynamicImg {
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
    }
    setAttributes(el, value, changes) {
        if (!el)
            return;
        const target = changes ? changes : value;
        Object.keys(target).forEach((key) => {
            if (key.startsWith('on')) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace('on', '').toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key, target[key] ?? '');
            }
        });
    }
    ngAfterViewInit() {
        this.setAttributes(this.v?.nativeElement, this.attributes);
    }
    ngOnChanges(changes) {
        if (changes.attributes) {
            this.setAttributes(this.v?.nativeElement, this.attributes, changes.attributes.currentValue);
        }
    }
    ngOnDestroy() {
        this._listenerFns.forEach(fn => fn());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicImg, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DynamicImg, isStandalone: true, selector: "dynamic-img, DynamicImg", inputs: { attributes: "attributes", actionAttributes: "actionAttributes" }, viewQueries: [{ propertyName: "v", first: true, predicate: ["v"], descendants: true, read: ElementRef }], usesOnChanges: true, ngImport: i0, template: ` <img #v /> `, isInline: true, styles: [":host{display:contents}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicImg, decorators: [{
            type: Component,
            args: [{ selector: 'dynamic-img, DynamicImg', template: ` <img #v /> `, standalone: true, styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { attributes: [{
                type: Input
            }], actionAttributes: [{
                type: Input
            }], v: [{
                type: ViewChild,
                args: ['v', { read: ElementRef }]
            }] } });
class DynamicInput {
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
    }
    setAttributes(el, value, changes) {
        if (!el)
            return;
        const target = changes ? changes : value;
        Object.keys(target).forEach((key) => {
            if (key.startsWith('on')) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace('on', '').toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key, target[key] ?? '');
            }
        });
    }
    ngAfterViewInit() {
        this.setAttributes(this.v?.nativeElement, this.attributes);
    }
    ngOnChanges(changes) {
        if (changes.attributes) {
            this.setAttributes(this.v?.nativeElement, this.attributes, changes.attributes.currentValue);
        }
    }
    ngOnDestroy() {
        this._listenerFns.forEach(fn => fn());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicInput, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DynamicInput, isStandalone: true, selector: "dynamic-input, DynamicInput", inputs: { attributes: "attributes", actionAttributes: "actionAttributes" }, viewQueries: [{ propertyName: "v", first: true, predicate: ["v"], descendants: true, read: ElementRef }], usesOnChanges: true, ngImport: i0, template: ` <input #v /> `, isInline: true, styles: [":host{display:contents}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicInput, decorators: [{
            type: Component,
            args: [{ selector: 'dynamic-input, DynamicInput', template: ` <input #v /> `, standalone: true, styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { attributes: [{
                type: Input
            }], actionAttributes: [{
                type: Input
            }], v: [{
                type: ViewChild,
                args: ['v', { read: ElementRef }]
            }] } });
class DynamicTextarea {
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
    }
    setAttributes(el, value, changes) {
        if (!el)
            return;
        const target = changes ? changes : value;
        Object.keys(target).forEach((key) => {
            if (key.startsWith('on')) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace('on', '').toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key, target[key] ?? '');
            }
        });
    }
    ngAfterViewInit() {
        this.setAttributes(this.v?.nativeElement, this.attributes);
    }
    ngOnChanges(changes) {
        if (changes.attributes) {
            this.setAttributes(this.v?.nativeElement, this.attributes, changes.attributes.currentValue);
        }
    }
    ngOnDestroy() {
        this._listenerFns.forEach(fn => fn());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicTextarea, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DynamicTextarea, isStandalone: true, selector: "dynamic-textarea, DynamicTextarea", inputs: { attributes: "attributes", actionAttributes: "actionAttributes" }, viewQueries: [{ propertyName: "v", first: true, predicate: ["v"], descendants: true, read: ElementRef }], usesOnChanges: true, ngImport: i0, template: ` <textarea #v ><ng-content></ng-content></textarea> `, isInline: true, styles: [":host{display:contents}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicTextarea, decorators: [{
            type: Component,
            args: [{ selector: 'dynamic-textarea, DynamicTextarea', template: ` <textarea #v ><ng-content></ng-content></textarea> `, standalone: true, styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { attributes: [{
                type: Input
            }], actionAttributes: [{
                type: Input
            }], v: [{
                type: ViewChild,
                args: ['v', { read: ElementRef }]
            }] } });
class DynamicSelect {
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
    }
    setAttributes(el, value, changes) {
        if (!el)
            return;
        const target = changes ? changes : value;
        Object.keys(target).forEach((key) => {
            if (key.startsWith('on')) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace('on', '').toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key, target[key] ?? '');
            }
        });
    }
    ngAfterViewInit() {
        this.setAttributes(this.v?.nativeElement, this.attributes);
    }
    ngOnChanges(changes) {
        if (changes.attributes) {
            this.setAttributes(this.v?.nativeElement, this.attributes, changes.attributes.currentValue);
        }
    }
    ngOnDestroy() {
        this._listenerFns.forEach(fn => fn());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicSelect, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DynamicSelect, isStandalone: true, selector: "dynamic-select, DynamicSelect", inputs: { attributes: "attributes", actionAttributes: "actionAttributes" }, viewQueries: [{ propertyName: "v", first: true, predicate: ["v"], descendants: true, read: ElementRef }], usesOnChanges: true, ngImport: i0, template: ` <select #v ><ng-content></ng-content></select> `, isInline: true, styles: [":host{display:contents}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicSelect, decorators: [{
            type: Component,
            args: [{ selector: 'dynamic-select, DynamicSelect', template: ` <select #v ><ng-content></ng-content></select> `, standalone: true, styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { attributes: [{
                type: Input
            }], actionAttributes: [{
                type: Input
            }], v: [{
                type: ViewChild,
                args: ['v', { read: ElementRef }]
            }] } });
class DynamicOption {
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
    }
    setAttributes(el, value, changes) {
        if (!el)
            return;
        const target = changes ? changes : value;
        Object.keys(target).forEach((key) => {
            if (key.startsWith('on')) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace('on', '').toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key, target[key] ?? '');
            }
        });
    }
    ngAfterViewInit() {
        this.setAttributes(this.v?.nativeElement, this.attributes);
    }
    ngOnChanges(changes) {
        if (changes.attributes) {
            this.setAttributes(this.v?.nativeElement, this.attributes, changes.attributes.currentValue);
        }
    }
    ngOnDestroy() {
        this._listenerFns.forEach(fn => fn());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicOption, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DynamicOption, isStandalone: true, selector: "dynamic-option, DynamicOption", inputs: { attributes: "attributes", actionAttributes: "actionAttributes" }, viewQueries: [{ propertyName: "v", first: true, predicate: ["v"], descendants: true, read: ElementRef }], usesOnChanges: true, ngImport: i0, template: ` <option #v ><ng-content></ng-content></option> `, isInline: true, styles: [":host{display:contents}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicOption, decorators: [{
            type: Component,
            args: [{ selector: 'dynamic-option, DynamicOption', template: ` <option #v ><ng-content></ng-content></option> `, standalone: true, styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { attributes: [{
                type: Input
            }], actionAttributes: [{
                type: Input
            }], v: [{
                type: ViewChild,
                args: ['v', { read: ElementRef }]
            }] } });
class DynamicForm {
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
    }
    setAttributes(el, value, changes) {
        if (!el)
            return;
        const target = changes ? changes : value;
        Object.keys(target).forEach((key) => {
            if (key.startsWith('on')) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace('on', '').toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key, target[key] ?? '');
            }
        });
    }
    ngAfterViewInit() {
        this.setAttributes(this.v?.nativeElement, this.attributes);
    }
    ngOnChanges(changes) {
        if (changes.attributes) {
            this.setAttributes(this.v?.nativeElement, this.attributes, changes.attributes.currentValue);
        }
    }
    ngOnDestroy() {
        this._listenerFns.forEach(fn => fn());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicForm, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DynamicForm, isStandalone: true, selector: "dynamic-form, DynamicForm", inputs: { attributes: "attributes", actionAttributes: "actionAttributes" }, viewQueries: [{ propertyName: "v", first: true, predicate: ["v"], descendants: true, read: ElementRef }], usesOnChanges: true, ngImport: i0, template: ` <form #v ><ng-content></ng-content></form> `, isInline: true, styles: [":host{display:contents}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicForm, decorators: [{
            type: Component,
            args: [{ selector: 'dynamic-form, DynamicForm', template: ` <form #v ><ng-content></ng-content></form> `, standalone: true, styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { attributes: [{
                type: Input
            }], actionAttributes: [{
                type: Input
            }], v: [{
                type: ViewChild,
                args: ['v', { read: ElementRef }]
            }] } });
class DynamicLabel {
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
    }
    setAttributes(el, value, changes) {
        if (!el)
            return;
        const target = changes ? changes : value;
        Object.keys(target).forEach((key) => {
            if (key.startsWith('on')) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace('on', '').toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key, target[key] ?? '');
            }
        });
    }
    ngAfterViewInit() {
        this.setAttributes(this.v?.nativeElement, this.attributes);
    }
    ngOnChanges(changes) {
        if (changes.attributes) {
            this.setAttributes(this.v?.nativeElement, this.attributes, changes.attributes.currentValue);
        }
    }
    ngOnDestroy() {
        this._listenerFns.forEach(fn => fn());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicLabel, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DynamicLabel, isStandalone: true, selector: "dynamic-label, DynamicLabel", inputs: { attributes: "attributes", actionAttributes: "actionAttributes" }, viewQueries: [{ propertyName: "v", first: true, predicate: ["v"], descendants: true, read: ElementRef }], usesOnChanges: true, ngImport: i0, template: ` <label #v ><ng-content></ng-content></label> `, isInline: true, styles: [":host{display:contents}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicLabel, decorators: [{
            type: Component,
            args: [{ selector: 'dynamic-label, DynamicLabel', template: ` <label #v ><ng-content></ng-content></label> `, standalone: true, styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { attributes: [{
                type: Input
            }], actionAttributes: [{
                type: Input
            }], v: [{
                type: ViewChild,
                args: ['v', { read: ElementRef }]
            }] } });
class DynamicUl {
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
    }
    setAttributes(el, value, changes) {
        if (!el)
            return;
        const target = changes ? changes : value;
        Object.keys(target).forEach((key) => {
            if (key.startsWith('on')) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace('on', '').toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key, target[key] ?? '');
            }
        });
    }
    ngAfterViewInit() {
        this.setAttributes(this.v?.nativeElement, this.attributes);
    }
    ngOnChanges(changes) {
        if (changes.attributes) {
            this.setAttributes(this.v?.nativeElement, this.attributes, changes.attributes.currentValue);
        }
    }
    ngOnDestroy() {
        this._listenerFns.forEach(fn => fn());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicUl, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DynamicUl, isStandalone: true, selector: "dynamic-ul, DynamicUl", inputs: { attributes: "attributes", actionAttributes: "actionAttributes" }, viewQueries: [{ propertyName: "v", first: true, predicate: ["v"], descendants: true, read: ElementRef }], usesOnChanges: true, ngImport: i0, template: ` <ul #v ><ng-content></ng-content></ul> `, isInline: true, styles: [":host{display:contents}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicUl, decorators: [{
            type: Component,
            args: [{ selector: 'dynamic-ul, DynamicUl', template: ` <ul #v ><ng-content></ng-content></ul> `, standalone: true, styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { attributes: [{
                type: Input
            }], actionAttributes: [{
                type: Input
            }], v: [{
                type: ViewChild,
                args: ['v', { read: ElementRef }]
            }] } });
class DynamicLi {
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
    }
    setAttributes(el, value, changes) {
        if (!el)
            return;
        const target = changes ? changes : value;
        Object.keys(target).forEach((key) => {
            if (key.startsWith('on')) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace('on', '').toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key, target[key] ?? '');
            }
        });
    }
    ngAfterViewInit() {
        this.setAttributes(this.v?.nativeElement, this.attributes);
    }
    ngOnChanges(changes) {
        if (changes.attributes) {
            this.setAttributes(this.v?.nativeElement, this.attributes, changes.attributes.currentValue);
        }
    }
    ngOnDestroy() {
        this._listenerFns.forEach(fn => fn());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicLi, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DynamicLi, isStandalone: true, selector: "dynamic-li, DynamicLi", inputs: { attributes: "attributes", actionAttributes: "actionAttributes" }, viewQueries: [{ propertyName: "v", first: true, predicate: ["v"], descendants: true, read: ElementRef }], usesOnChanges: true, ngImport: i0, template: ` <li #v ><ng-content></ng-content></li> `, isInline: true, styles: [":host{display:contents}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicLi, decorators: [{
            type: Component,
            args: [{ selector: 'dynamic-li, DynamicLi', template: ` <li #v ><ng-content></ng-content></li> `, standalone: true, styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { attributes: [{
                type: Input
            }], actionAttributes: [{
                type: Input
            }], v: [{
                type: ViewChild,
                args: ['v', { read: ElementRef }]
            }] } });
class DynamicTable {
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
    }
    setAttributes(el, value, changes) {
        if (!el)
            return;
        const target = changes ? changes : value;
        Object.keys(target).forEach((key) => {
            if (key.startsWith('on')) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace('on', '').toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key, target[key] ?? '');
            }
        });
    }
    ngAfterViewInit() {
        this.setAttributes(this.v?.nativeElement, this.attributes);
    }
    ngOnChanges(changes) {
        if (changes.attributes) {
            this.setAttributes(this.v?.nativeElement, this.attributes, changes.attributes.currentValue);
        }
    }
    ngOnDestroy() {
        this._listenerFns.forEach(fn => fn());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicTable, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DynamicTable, isStandalone: true, selector: "dynamic-table, DynamicTable", inputs: { attributes: "attributes", actionAttributes: "actionAttributes" }, viewQueries: [{ propertyName: "v", first: true, predicate: ["v"], descendants: true, read: ElementRef }], usesOnChanges: true, ngImport: i0, template: ` <table #v ><ng-content></ng-content></table> `, isInline: true, styles: [":host{display:contents}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicTable, decorators: [{
            type: Component,
            args: [{ selector: 'dynamic-table, DynamicTable', template: ` <table #v ><ng-content></ng-content></table> `, standalone: true, styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { attributes: [{
                type: Input
            }], actionAttributes: [{
                type: Input
            }], v: [{
                type: ViewChild,
                args: ['v', { read: ElementRef }]
            }] } });
class DynamicTr {
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
    }
    setAttributes(el, value, changes) {
        if (!el)
            return;
        const target = changes ? changes : value;
        Object.keys(target).forEach((key) => {
            if (key.startsWith('on')) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace('on', '').toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key, target[key] ?? '');
            }
        });
    }
    ngAfterViewInit() {
        this.setAttributes(this.v?.nativeElement, this.attributes);
    }
    ngOnChanges(changes) {
        if (changes.attributes) {
            this.setAttributes(this.v?.nativeElement, this.attributes, changes.attributes.currentValue);
        }
    }
    ngOnDestroy() {
        this._listenerFns.forEach(fn => fn());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicTr, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DynamicTr, isStandalone: true, selector: "dynamic-tr, DynamicTr", inputs: { attributes: "attributes", actionAttributes: "actionAttributes" }, viewQueries: [{ propertyName: "v", first: true, predicate: ["v"], descendants: true, read: ElementRef }], usesOnChanges: true, ngImport: i0, template: ` <tr #v ><ng-content></ng-content></tr> `, isInline: true, styles: [":host{display:contents}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicTr, decorators: [{
            type: Component,
            args: [{ selector: 'dynamic-tr, DynamicTr', template: ` <tr #v ><ng-content></ng-content></tr> `, standalone: true, styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { attributes: [{
                type: Input
            }], actionAttributes: [{
                type: Input
            }], v: [{
                type: ViewChild,
                args: ['v', { read: ElementRef }]
            }] } });
class DynamicTd {
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
    }
    setAttributes(el, value, changes) {
        if (!el)
            return;
        const target = changes ? changes : value;
        Object.keys(target).forEach((key) => {
            if (key.startsWith('on')) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace('on', '').toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key, target[key] ?? '');
            }
        });
    }
    ngAfterViewInit() {
        this.setAttributes(this.v?.nativeElement, this.attributes);
    }
    ngOnChanges(changes) {
        if (changes.attributes) {
            this.setAttributes(this.v?.nativeElement, this.attributes, changes.attributes.currentValue);
        }
    }
    ngOnDestroy() {
        this._listenerFns.forEach(fn => fn());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicTd, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DynamicTd, isStandalone: true, selector: "dynamic-td, DynamicTd", inputs: { attributes: "attributes", actionAttributes: "actionAttributes" }, viewQueries: [{ propertyName: "v", first: true, predicate: ["v"], descendants: true, read: ElementRef }], usesOnChanges: true, ngImport: i0, template: ` <td #v ><ng-content></ng-content></td> `, isInline: true, styles: [":host{display:contents}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicTd, decorators: [{
            type: Component,
            args: [{ selector: 'dynamic-td, DynamicTd', template: ` <td #v ><ng-content></ng-content></td> `, standalone: true, styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { attributes: [{
                type: Input
            }], actionAttributes: [{
                type: Input
            }], v: [{
                type: ViewChild,
                args: ['v', { read: ElementRef }]
            }] } });
class DynamicTh {
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
    }
    setAttributes(el, value, changes) {
        if (!el)
            return;
        const target = changes ? changes : value;
        Object.keys(target).forEach((key) => {
            if (key.startsWith('on')) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace('on', '').toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key, target[key] ?? '');
            }
        });
    }
    ngAfterViewInit() {
        this.setAttributes(this.v?.nativeElement, this.attributes);
    }
    ngOnChanges(changes) {
        if (changes.attributes) {
            this.setAttributes(this.v?.nativeElement, this.attributes, changes.attributes.currentValue);
        }
    }
    ngOnDestroy() {
        this._listenerFns.forEach(fn => fn());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicTh, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DynamicTh, isStandalone: true, selector: "dynamic-th, DynamicTh", inputs: { attributes: "attributes", actionAttributes: "actionAttributes" }, viewQueries: [{ propertyName: "v", first: true, predicate: ["v"], descendants: true, read: ElementRef }], usesOnChanges: true, ngImport: i0, template: ` <th #v ><ng-content></ng-content></th> `, isInline: true, styles: [":host{display:contents}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicTh, decorators: [{
            type: Component,
            args: [{ selector: 'dynamic-th, DynamicTh', template: ` <th #v ><ng-content></ng-content></th> `, standalone: true, styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { attributes: [{
                type: Input
            }], actionAttributes: [{
                type: Input
            }], v: [{
                type: ViewChild,
                args: ['v', { read: ElementRef }]
            }] } });
class DynamicThead {
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
    }
    setAttributes(el, value, changes) {
        if (!el)
            return;
        const target = changes ? changes : value;
        Object.keys(target).forEach((key) => {
            if (key.startsWith('on')) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace('on', '').toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key, target[key] ?? '');
            }
        });
    }
    ngAfterViewInit() {
        this.setAttributes(this.v?.nativeElement, this.attributes);
    }
    ngOnChanges(changes) {
        if (changes.attributes) {
            this.setAttributes(this.v?.nativeElement, this.attributes, changes.attributes.currentValue);
        }
    }
    ngOnDestroy() {
        this._listenerFns.forEach(fn => fn());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicThead, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DynamicThead, isStandalone: true, selector: "dynamic-thead, DynamicThead", inputs: { attributes: "attributes", actionAttributes: "actionAttributes" }, viewQueries: [{ propertyName: "v", first: true, predicate: ["v"], descendants: true, read: ElementRef }], usesOnChanges: true, ngImport: i0, template: ` <thead #v ><ng-content></ng-content></thead> `, isInline: true, styles: [":host{display:contents}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicThead, decorators: [{
            type: Component,
            args: [{ selector: 'dynamic-thead, DynamicThead', template: ` <thead #v ><ng-content></ng-content></thead> `, standalone: true, styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { attributes: [{
                type: Input
            }], actionAttributes: [{
                type: Input
            }], v: [{
                type: ViewChild,
                args: ['v', { read: ElementRef }]
            }] } });
class DynamicTbody {
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
    }
    setAttributes(el, value, changes) {
        if (!el)
            return;
        const target = changes ? changes : value;
        Object.keys(target).forEach((key) => {
            if (key.startsWith('on')) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace('on', '').toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key, target[key] ?? '');
            }
        });
    }
    ngAfterViewInit() {
        this.setAttributes(this.v?.nativeElement, this.attributes);
    }
    ngOnChanges(changes) {
        if (changes.attributes) {
            this.setAttributes(this.v?.nativeElement, this.attributes, changes.attributes.currentValue);
        }
    }
    ngOnDestroy() {
        this._listenerFns.forEach(fn => fn());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicTbody, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DynamicTbody, isStandalone: true, selector: "dynamic-tbody, DynamicTbody", inputs: { attributes: "attributes", actionAttributes: "actionAttributes" }, viewQueries: [{ propertyName: "v", first: true, predicate: ["v"], descendants: true, read: ElementRef }], usesOnChanges: true, ngImport: i0, template: ` <tbody #v ><ng-content></ng-content></tbody> `, isInline: true, styles: [":host{display:contents}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicTbody, decorators: [{
            type: Component,
            args: [{ selector: 'dynamic-tbody, DynamicTbody', template: ` <tbody #v ><ng-content></ng-content></tbody> `, standalone: true, styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { attributes: [{
                type: Input
            }], actionAttributes: [{
                type: Input
            }], v: [{
                type: ViewChild,
                args: ['v', { read: ElementRef }]
            }] } });
class DynamicFooter {
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
    }
    setAttributes(el, value, changes) {
        if (!el)
            return;
        const target = changes ? changes : value;
        Object.keys(target).forEach((key) => {
            if (key.startsWith('on')) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace('on', '').toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key, target[key] ?? '');
            }
        });
    }
    ngAfterViewInit() {
        this.setAttributes(this.v?.nativeElement, this.attributes);
    }
    ngOnChanges(changes) {
        if (changes.attributes) {
            this.setAttributes(this.v?.nativeElement, this.attributes, changes.attributes.currentValue);
        }
    }
    ngOnDestroy() {
        this._listenerFns.forEach(fn => fn());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicFooter, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DynamicFooter, isStandalone: true, selector: "dynamic-footer, DynamicFooter", inputs: { attributes: "attributes", actionAttributes: "actionAttributes" }, viewQueries: [{ propertyName: "v", first: true, predicate: ["v"], descendants: true, read: ElementRef }], usesOnChanges: true, ngImport: i0, template: ` <footer #v ><ng-content></ng-content></footer> `, isInline: true, styles: [":host{display:contents}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicFooter, decorators: [{
            type: Component,
            args: [{ selector: 'dynamic-footer, DynamicFooter', template: ` <footer #v ><ng-content></ng-content></footer> `, standalone: true, styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { attributes: [{
                type: Input
            }], actionAttributes: [{
                type: Input
            }], v: [{
                type: ViewChild,
                args: ['v', { read: ElementRef }]
            }] } });
class DynamicHeader {
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
    }
    setAttributes(el, value, changes) {
        if (!el)
            return;
        const target = changes ? changes : value;
        Object.keys(target).forEach((key) => {
            if (key.startsWith('on')) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace('on', '').toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key, target[key] ?? '');
            }
        });
    }
    ngAfterViewInit() {
        this.setAttributes(this.v?.nativeElement, this.attributes);
    }
    ngOnChanges(changes) {
        if (changes.attributes) {
            this.setAttributes(this.v?.nativeElement, this.attributes, changes.attributes.currentValue);
        }
    }
    ngOnDestroy() {
        this._listenerFns.forEach(fn => fn());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicHeader, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DynamicHeader, isStandalone: true, selector: "dynamic-header, DynamicHeader", inputs: { attributes: "attributes", actionAttributes: "actionAttributes" }, viewQueries: [{ propertyName: "v", first: true, predicate: ["v"], descendants: true, read: ElementRef }], usesOnChanges: true, ngImport: i0, template: ` <header #v ><ng-content></ng-content></header> `, isInline: true, styles: [":host{display:contents}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicHeader, decorators: [{
            type: Component,
            args: [{ selector: 'dynamic-header, DynamicHeader', template: ` <header #v ><ng-content></ng-content></header> `, standalone: true, styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { attributes: [{
                type: Input
            }], actionAttributes: [{
                type: Input
            }], v: [{
                type: ViewChild,
                args: ['v', { read: ElementRef }]
            }] } });
class DynamicNav {
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
    }
    setAttributes(el, value, changes) {
        if (!el)
            return;
        const target = changes ? changes : value;
        Object.keys(target).forEach((key) => {
            if (key.startsWith('on')) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace('on', '').toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key, target[key] ?? '');
            }
        });
    }
    ngAfterViewInit() {
        this.setAttributes(this.v?.nativeElement, this.attributes);
    }
    ngOnChanges(changes) {
        if (changes.attributes) {
            this.setAttributes(this.v?.nativeElement, this.attributes, changes.attributes.currentValue);
        }
    }
    ngOnDestroy() {
        this._listenerFns.forEach(fn => fn());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicNav, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DynamicNav, isStandalone: true, selector: "dynamic-nav, DynamicNav", inputs: { attributes: "attributes", actionAttributes: "actionAttributes" }, viewQueries: [{ propertyName: "v", first: true, predicate: ["v"], descendants: true, read: ElementRef }], usesOnChanges: true, ngImport: i0, template: ` <nav #v ><ng-content></ng-content></nav> `, isInline: true, styles: [":host{display:contents}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicNav, decorators: [{
            type: Component,
            args: [{ selector: 'dynamic-nav, DynamicNav', template: ` <nav #v ><ng-content></ng-content></nav> `, standalone: true, styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { attributes: [{
                type: Input
            }], actionAttributes: [{
                type: Input
            }], v: [{
                type: ViewChild,
                args: ['v', { read: ElementRef }]
            }] } });
class DynamicSection {
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
    }
    setAttributes(el, value, changes) {
        if (!el)
            return;
        const target = changes ? changes : value;
        Object.keys(target).forEach((key) => {
            if (key.startsWith('on')) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace('on', '').toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key, target[key] ?? '');
            }
        });
    }
    ngAfterViewInit() {
        this.setAttributes(this.v?.nativeElement, this.attributes);
    }
    ngOnChanges(changes) {
        if (changes.attributes) {
            this.setAttributes(this.v?.nativeElement, this.attributes, changes.attributes.currentValue);
        }
    }
    ngOnDestroy() {
        this._listenerFns.forEach(fn => fn());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicSection, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DynamicSection, isStandalone: true, selector: "dynamic-section, DynamicSection", inputs: { attributes: "attributes", actionAttributes: "actionAttributes" }, viewQueries: [{ propertyName: "v", first: true, predicate: ["v"], descendants: true, read: ElementRef }], usesOnChanges: true, ngImport: i0, template: ` <section #v ><ng-content></ng-content></section> `, isInline: true, styles: [":host{display:contents}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicSection, decorators: [{
            type: Component,
            args: [{ selector: 'dynamic-section, DynamicSection', template: ` <section #v ><ng-content></ng-content></section> `, standalone: true, styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { attributes: [{
                type: Input
            }], actionAttributes: [{
                type: Input
            }], v: [{
                type: ViewChild,
                args: ['v', { read: ElementRef }]
            }] } });
class DynamicArticle {
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
    }
    setAttributes(el, value, changes) {
        if (!el)
            return;
        const target = changes ? changes : value;
        Object.keys(target).forEach((key) => {
            if (key.startsWith('on')) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace('on', '').toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key, target[key] ?? '');
            }
        });
    }
    ngAfterViewInit() {
        this.setAttributes(this.v?.nativeElement, this.attributes);
    }
    ngOnChanges(changes) {
        if (changes.attributes) {
            this.setAttributes(this.v?.nativeElement, this.attributes, changes.attributes.currentValue);
        }
    }
    ngOnDestroy() {
        this._listenerFns.forEach(fn => fn());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicArticle, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DynamicArticle, isStandalone: true, selector: "dynamic-article, DynamicArticle", inputs: { attributes: "attributes", actionAttributes: "actionAttributes" }, viewQueries: [{ propertyName: "v", first: true, predicate: ["v"], descendants: true, read: ElementRef }], usesOnChanges: true, ngImport: i0, template: ` <article #v ><ng-content></ng-content></article> `, isInline: true, styles: [":host{display:contents}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicArticle, decorators: [{
            type: Component,
            args: [{ selector: 'dynamic-article, DynamicArticle', template: ` <article #v ><ng-content></ng-content></article> `, standalone: true, styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { attributes: [{
                type: Input
            }], actionAttributes: [{
                type: Input
            }], v: [{
                type: ViewChild,
                args: ['v', { read: ElementRef }]
            }] } });
class DynamicAside {
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
    }
    setAttributes(el, value, changes) {
        if (!el)
            return;
        const target = changes ? changes : value;
        Object.keys(target).forEach((key) => {
            if (key.startsWith('on')) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace('on', '').toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key, target[key] ?? '');
            }
        });
    }
    ngAfterViewInit() {
        this.setAttributes(this.v?.nativeElement, this.attributes);
    }
    ngOnChanges(changes) {
        if (changes.attributes) {
            this.setAttributes(this.v?.nativeElement, this.attributes, changes.attributes.currentValue);
        }
    }
    ngOnDestroy() {
        this._listenerFns.forEach(fn => fn());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicAside, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DynamicAside, isStandalone: true, selector: "dynamic-aside, DynamicAside", inputs: { attributes: "attributes", actionAttributes: "actionAttributes" }, viewQueries: [{ propertyName: "v", first: true, predicate: ["v"], descendants: true, read: ElementRef }], usesOnChanges: true, ngImport: i0, template: ` <aside #v ><ng-content></ng-content></aside> `, isInline: true, styles: [":host{display:contents}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicAside, decorators: [{
            type: Component,
            args: [{ selector: 'dynamic-aside, DynamicAside', template: ` <aside #v ><ng-content></ng-content></aside> `, standalone: true, styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { attributes: [{
                type: Input
            }], actionAttributes: [{
                type: Input
            }], v: [{
                type: ViewChild,
                args: ['v', { read: ElementRef }]
            }] } });
class DynamicH1 {
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
    }
    setAttributes(el, value, changes) {
        if (!el)
            return;
        const target = changes ? changes : value;
        Object.keys(target).forEach((key) => {
            if (key.startsWith('on')) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace('on', '').toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key, target[key] ?? '');
            }
        });
    }
    ngAfterViewInit() {
        this.setAttributes(this.v?.nativeElement, this.attributes);
    }
    ngOnChanges(changes) {
        if (changes.attributes) {
            this.setAttributes(this.v?.nativeElement, this.attributes, changes.attributes.currentValue);
        }
    }
    ngOnDestroy() {
        this._listenerFns.forEach(fn => fn());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicH1, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DynamicH1, isStandalone: true, selector: "dynamic-h1, DynamicH1", inputs: { attributes: "attributes", actionAttributes: "actionAttributes" }, viewQueries: [{ propertyName: "v", first: true, predicate: ["v"], descendants: true, read: ElementRef }], usesOnChanges: true, ngImport: i0, template: ` <h1 #v ><ng-content></ng-content></h1> `, isInline: true, styles: [":host{display:contents}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicH1, decorators: [{
            type: Component,
            args: [{ selector: 'dynamic-h1, DynamicH1', template: ` <h1 #v ><ng-content></ng-content></h1> `, standalone: true, styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { attributes: [{
                type: Input
            }], actionAttributes: [{
                type: Input
            }], v: [{
                type: ViewChild,
                args: ['v', { read: ElementRef }]
            }] } });
class DynamicH2 {
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
    }
    setAttributes(el, value, changes) {
        if (!el)
            return;
        const target = changes ? changes : value;
        Object.keys(target).forEach((key) => {
            if (key.startsWith('on')) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace('on', '').toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key, target[key] ?? '');
            }
        });
    }
    ngAfterViewInit() {
        this.setAttributes(this.v?.nativeElement, this.attributes);
    }
    ngOnChanges(changes) {
        if (changes.attributes) {
            this.setAttributes(this.v?.nativeElement, this.attributes, changes.attributes.currentValue);
        }
    }
    ngOnDestroy() {
        this._listenerFns.forEach(fn => fn());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicH2, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DynamicH2, isStandalone: true, selector: "dynamic-h2, DynamicH2", inputs: { attributes: "attributes", actionAttributes: "actionAttributes" }, viewQueries: [{ propertyName: "v", first: true, predicate: ["v"], descendants: true, read: ElementRef }], usesOnChanges: true, ngImport: i0, template: ` <h2 #v ><ng-content></ng-content></h2> `, isInline: true, styles: [":host{display:contents}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicH2, decorators: [{
            type: Component,
            args: [{ selector: 'dynamic-h2, DynamicH2', template: ` <h2 #v ><ng-content></ng-content></h2> `, standalone: true, styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { attributes: [{
                type: Input
            }], actionAttributes: [{
                type: Input
            }], v: [{
                type: ViewChild,
                args: ['v', { read: ElementRef }]
            }] } });
class DynamicH3 {
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
    }
    setAttributes(el, value, changes) {
        if (!el)
            return;
        const target = changes ? changes : value;
        Object.keys(target).forEach((key) => {
            if (key.startsWith('on')) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace('on', '').toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key, target[key] ?? '');
            }
        });
    }
    ngAfterViewInit() {
        this.setAttributes(this.v?.nativeElement, this.attributes);
    }
    ngOnChanges(changes) {
        if (changes.attributes) {
            this.setAttributes(this.v?.nativeElement, this.attributes, changes.attributes.currentValue);
        }
    }
    ngOnDestroy() {
        this._listenerFns.forEach(fn => fn());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicH3, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DynamicH3, isStandalone: true, selector: "dynamic-h3, DynamicH3", inputs: { attributes: "attributes", actionAttributes: "actionAttributes" }, viewQueries: [{ propertyName: "v", first: true, predicate: ["v"], descendants: true, read: ElementRef }], usesOnChanges: true, ngImport: i0, template: ` <h3 #v ><ng-content></ng-content></h3> `, isInline: true, styles: [":host{display:contents}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicH3, decorators: [{
            type: Component,
            args: [{ selector: 'dynamic-h3, DynamicH3', template: ` <h3 #v ><ng-content></ng-content></h3> `, standalone: true, styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { attributes: [{
                type: Input
            }], actionAttributes: [{
                type: Input
            }], v: [{
                type: ViewChild,
                args: ['v', { read: ElementRef }]
            }] } });
class DynamicH4 {
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
    }
    setAttributes(el, value, changes) {
        if (!el)
            return;
        const target = changes ? changes : value;
        Object.keys(target).forEach((key) => {
            if (key.startsWith('on')) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace('on', '').toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key, target[key] ?? '');
            }
        });
    }
    ngAfterViewInit() {
        this.setAttributes(this.v?.nativeElement, this.attributes);
    }
    ngOnChanges(changes) {
        if (changes.attributes) {
            this.setAttributes(this.v?.nativeElement, this.attributes, changes.attributes.currentValue);
        }
    }
    ngOnDestroy() {
        this._listenerFns.forEach(fn => fn());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicH4, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DynamicH4, isStandalone: true, selector: "dynamic-h4, DynamicH4", inputs: { attributes: "attributes", actionAttributes: "actionAttributes" }, viewQueries: [{ propertyName: "v", first: true, predicate: ["v"], descendants: true, read: ElementRef }], usesOnChanges: true, ngImport: i0, template: ` <h4 #v ><ng-content></ng-content></h4> `, isInline: true, styles: [":host{display:contents}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicH4, decorators: [{
            type: Component,
            args: [{ selector: 'dynamic-h4, DynamicH4', template: ` <h4 #v ><ng-content></ng-content></h4> `, standalone: true, styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { attributes: [{
                type: Input
            }], actionAttributes: [{
                type: Input
            }], v: [{
                type: ViewChild,
                args: ['v', { read: ElementRef }]
            }] } });
class DynamicH5 {
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
    }
    setAttributes(el, value, changes) {
        if (!el)
            return;
        const target = changes ? changes : value;
        Object.keys(target).forEach((key) => {
            if (key.startsWith('on')) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace('on', '').toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key, target[key] ?? '');
            }
        });
    }
    ngAfterViewInit() {
        this.setAttributes(this.v?.nativeElement, this.attributes);
    }
    ngOnChanges(changes) {
        if (changes.attributes) {
            this.setAttributes(this.v?.nativeElement, this.attributes, changes.attributes.currentValue);
        }
    }
    ngOnDestroy() {
        this._listenerFns.forEach(fn => fn());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicH5, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DynamicH5, isStandalone: true, selector: "dynamic-h5, DynamicH5", inputs: { attributes: "attributes", actionAttributes: "actionAttributes" }, viewQueries: [{ propertyName: "v", first: true, predicate: ["v"], descendants: true, read: ElementRef }], usesOnChanges: true, ngImport: i0, template: ` <h5 #v ><ng-content></ng-content></h5> `, isInline: true, styles: [":host{display:contents}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicH5, decorators: [{
            type: Component,
            args: [{ selector: 'dynamic-h5, DynamicH5', template: ` <h5 #v ><ng-content></ng-content></h5> `, standalone: true, styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { attributes: [{
                type: Input
            }], actionAttributes: [{
                type: Input
            }], v: [{
                type: ViewChild,
                args: ['v', { read: ElementRef }]
            }] } });
class DynamicH6 {
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
    }
    setAttributes(el, value, changes) {
        if (!el)
            return;
        const target = changes ? changes : value;
        Object.keys(target).forEach((key) => {
            if (key.startsWith('on')) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace('on', '').toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key, target[key] ?? '');
            }
        });
    }
    ngAfterViewInit() {
        this.setAttributes(this.v?.nativeElement, this.attributes);
    }
    ngOnChanges(changes) {
        if (changes.attributes) {
            this.setAttributes(this.v?.nativeElement, this.attributes, changes.attributes.currentValue);
        }
    }
    ngOnDestroy() {
        this._listenerFns.forEach(fn => fn());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicH6, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DynamicH6, isStandalone: true, selector: "dynamic-h6, DynamicH6", inputs: { attributes: "attributes", actionAttributes: "actionAttributes" }, viewQueries: [{ propertyName: "v", first: true, predicate: ["v"], descendants: true, read: ElementRef }], usesOnChanges: true, ngImport: i0, template: ` <h6 #v ><ng-content></ng-content></h6> `, isInline: true, styles: [":host{display:contents}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicH6, decorators: [{
            type: Component,
            args: [{ selector: 'dynamic-h6, DynamicH6', template: ` <h6 #v ><ng-content></ng-content></h6> `, standalone: true, styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { attributes: [{
                type: Input
            }], actionAttributes: [{
                type: Input
            }], v: [{
                type: ViewChild,
                args: ['v', { read: ElementRef }]
            }] } });
class DynamicBlockquote {
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
    }
    setAttributes(el, value, changes) {
        if (!el)
            return;
        const target = changes ? changes : value;
        Object.keys(target).forEach((key) => {
            if (key.startsWith('on')) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace('on', '').toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key, target[key] ?? '');
            }
        });
    }
    ngAfterViewInit() {
        this.setAttributes(this.v?.nativeElement, this.attributes);
    }
    ngOnChanges(changes) {
        if (changes.attributes) {
            this.setAttributes(this.v?.nativeElement, this.attributes, changes.attributes.currentValue);
        }
    }
    ngOnDestroy() {
        this._listenerFns.forEach(fn => fn());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicBlockquote, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DynamicBlockquote, isStandalone: true, selector: "dynamic-blockquote, DynamicBlockquote", inputs: { attributes: "attributes", actionAttributes: "actionAttributes" }, viewQueries: [{ propertyName: "v", first: true, predicate: ["v"], descendants: true, read: ElementRef }], usesOnChanges: true, ngImport: i0, template: ` <blockquote #v ><ng-content></ng-content></blockquote> `, isInline: true, styles: [":host{display:contents}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicBlockquote, decorators: [{
            type: Component,
            args: [{ selector: 'dynamic-blockquote, DynamicBlockquote', template: ` <blockquote #v ><ng-content></ng-content></blockquote> `, standalone: true, styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { attributes: [{
                type: Input
            }], actionAttributes: [{
                type: Input
            }], v: [{
                type: ViewChild,
                args: ['v', { read: ElementRef }]
            }] } });
class DynamicCode {
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
    }
    setAttributes(el, value, changes) {
        if (!el)
            return;
        const target = changes ? changes : value;
        Object.keys(target).forEach((key) => {
            if (key.startsWith('on')) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace('on', '').toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key, target[key] ?? '');
            }
        });
    }
    ngAfterViewInit() {
        this.setAttributes(this.v?.nativeElement, this.attributes);
    }
    ngOnChanges(changes) {
        if (changes.attributes) {
            this.setAttributes(this.v?.nativeElement, this.attributes, changes.attributes.currentValue);
        }
    }
    ngOnDestroy() {
        this._listenerFns.forEach(fn => fn());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicCode, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DynamicCode, isStandalone: true, selector: "dynamic-code, DynamicCode", inputs: { attributes: "attributes", actionAttributes: "actionAttributes" }, viewQueries: [{ propertyName: "v", first: true, predicate: ["v"], descendants: true, read: ElementRef }], usesOnChanges: true, ngImport: i0, template: ` <code #v ><ng-content></ng-content></code> `, isInline: true, styles: [":host{display:contents}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicCode, decorators: [{
            type: Component,
            args: [{ selector: 'dynamic-code, DynamicCode', template: ` <code #v ><ng-content></ng-content></code> `, standalone: true, styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { attributes: [{
                type: Input
            }], actionAttributes: [{
                type: Input
            }], v: [{
                type: ViewChild,
                args: ['v', { read: ElementRef }]
            }] } });
class DynamicPre {
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
    }
    setAttributes(el, value, changes) {
        if (!el)
            return;
        const target = changes ? changes : value;
        Object.keys(target).forEach((key) => {
            if (key.startsWith('on')) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace('on', '').toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key, target[key] ?? '');
            }
        });
    }
    ngAfterViewInit() {
        this.setAttributes(this.v?.nativeElement, this.attributes);
    }
    ngOnChanges(changes) {
        if (changes.attributes) {
            this.setAttributes(this.v?.nativeElement, this.attributes, changes.attributes.currentValue);
        }
    }
    ngOnDestroy() {
        this._listenerFns.forEach(fn => fn());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicPre, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DynamicPre, isStandalone: true, selector: "dynamic-pre, DynamicPre", inputs: { attributes: "attributes", actionAttributes: "actionAttributes" }, viewQueries: [{ propertyName: "v", first: true, predicate: ["v"], descendants: true, read: ElementRef }], usesOnChanges: true, ngImport: i0, template: ` <pre #v ><ng-content></ng-content></pre> `, isInline: true, styles: [":host{display:contents}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicPre, decorators: [{
            type: Component,
            args: [{ selector: 'dynamic-pre, DynamicPre', template: ` <pre #v ><ng-content></ng-content></pre> `, standalone: true, styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { attributes: [{
                type: Input
            }], actionAttributes: [{
                type: Input
            }], v: [{
                type: ViewChild,
                args: ['v', { read: ElementRef }]
            }] } });
class DynamicFigure {
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
    }
    setAttributes(el, value, changes) {
        if (!el)
            return;
        const target = changes ? changes : value;
        Object.keys(target).forEach((key) => {
            if (key.startsWith('on')) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace('on', '').toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key, target[key] ?? '');
            }
        });
    }
    ngAfterViewInit() {
        this.setAttributes(this.v?.nativeElement, this.attributes);
    }
    ngOnChanges(changes) {
        if (changes.attributes) {
            this.setAttributes(this.v?.nativeElement, this.attributes, changes.attributes.currentValue);
        }
    }
    ngOnDestroy() {
        this._listenerFns.forEach(fn => fn());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicFigure, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DynamicFigure, isStandalone: true, selector: "dynamic-figure, DynamicFigure", inputs: { attributes: "attributes", actionAttributes: "actionAttributes" }, viewQueries: [{ propertyName: "v", first: true, predicate: ["v"], descendants: true, read: ElementRef }], usesOnChanges: true, ngImport: i0, template: ` <figure #v ><ng-content></ng-content></figure> `, isInline: true, styles: [":host{display:contents}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicFigure, decorators: [{
            type: Component,
            args: [{ selector: 'dynamic-figure, DynamicFigure', template: ` <figure #v ><ng-content></ng-content></figure> `, standalone: true, styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { attributes: [{
                type: Input
            }], actionAttributes: [{
                type: Input
            }], v: [{
                type: ViewChild,
                args: ['v', { read: ElementRef }]
            }] } });
class DynamicFigcaption {
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
    }
    setAttributes(el, value, changes) {
        if (!el)
            return;
        const target = changes ? changes : value;
        Object.keys(target).forEach((key) => {
            if (key.startsWith('on')) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace('on', '').toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key, target[key] ?? '');
            }
        });
    }
    ngAfterViewInit() {
        this.setAttributes(this.v?.nativeElement, this.attributes);
    }
    ngOnChanges(changes) {
        if (changes.attributes) {
            this.setAttributes(this.v?.nativeElement, this.attributes, changes.attributes.currentValue);
        }
    }
    ngOnDestroy() {
        this._listenerFns.forEach(fn => fn());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicFigcaption, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DynamicFigcaption, isStandalone: true, selector: "dynamic-figcaption, DynamicFigcaption", inputs: { attributes: "attributes", actionAttributes: "actionAttributes" }, viewQueries: [{ propertyName: "v", first: true, predicate: ["v"], descendants: true, read: ElementRef }], usesOnChanges: true, ngImport: i0, template: ` <figcaption #v ><ng-content></ng-content></figcaption> `, isInline: true, styles: [":host{display:contents}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicFigcaption, decorators: [{
            type: Component,
            args: [{ selector: 'dynamic-figcaption, DynamicFigcaption', template: ` <figcaption #v ><ng-content></ng-content></figcaption> `, standalone: true, styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { attributes: [{
                type: Input
            }], actionAttributes: [{
                type: Input
            }], v: [{
                type: ViewChild,
                args: ['v', { read: ElementRef }]
            }] } });
class DynamicVideo {
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
    }
    setAttributes(el, value, changes) {
        if (!el)
            return;
        const target = changes ? changes : value;
        Object.keys(target).forEach((key) => {
            if (key.startsWith('on')) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace('on', '').toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key, target[key] ?? '');
            }
        });
    }
    ngAfterViewInit() {
        this.setAttributes(this.v?.nativeElement, this.attributes);
    }
    ngOnChanges(changes) {
        if (changes.attributes) {
            this.setAttributes(this.v?.nativeElement, this.attributes, changes.attributes.currentValue);
        }
    }
    ngOnDestroy() {
        this._listenerFns.forEach(fn => fn());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicVideo, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DynamicVideo, isStandalone: true, selector: "dynamic-video, DynamicVideo", inputs: { attributes: "attributes", actionAttributes: "actionAttributes" }, viewQueries: [{ propertyName: "v", first: true, predicate: ["v"], descendants: true, read: ElementRef }], usesOnChanges: true, ngImport: i0, template: ` <video #v ><ng-content></ng-content></video> `, isInline: true, styles: [":host{display:contents}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicVideo, decorators: [{
            type: Component,
            args: [{ selector: 'dynamic-video, DynamicVideo', template: ` <video #v ><ng-content></ng-content></video> `, standalone: true, styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { attributes: [{
                type: Input
            }], actionAttributes: [{
                type: Input
            }], v: [{
                type: ViewChild,
                args: ['v', { read: ElementRef }]
            }] } });
class DynamicAudio {
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
    }
    setAttributes(el, value, changes) {
        if (!el)
            return;
        const target = changes ? changes : value;
        Object.keys(target).forEach((key) => {
            if (key.startsWith('on')) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace('on', '').toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key, target[key] ?? '');
            }
        });
    }
    ngAfterViewInit() {
        this.setAttributes(this.v?.nativeElement, this.attributes);
    }
    ngOnChanges(changes) {
        if (changes.attributes) {
            this.setAttributes(this.v?.nativeElement, this.attributes, changes.attributes.currentValue);
        }
    }
    ngOnDestroy() {
        this._listenerFns.forEach(fn => fn());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicAudio, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DynamicAudio, isStandalone: true, selector: "dynamic-audio, DynamicAudio", inputs: { attributes: "attributes", actionAttributes: "actionAttributes" }, viewQueries: [{ propertyName: "v", first: true, predicate: ["v"], descendants: true, read: ElementRef }], usesOnChanges: true, ngImport: i0, template: ` <audio #v ><ng-content></ng-content></audio> `, isInline: true, styles: [":host{display:contents}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicAudio, decorators: [{
            type: Component,
            args: [{ selector: 'dynamic-audio, DynamicAudio', template: ` <audio #v ><ng-content></ng-content></audio> `, standalone: true, styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { attributes: [{
                type: Input
            }], actionAttributes: [{
                type: Input
            }], v: [{
                type: ViewChild,
                args: ['v', { read: ElementRef }]
            }] } });
class DynamicCanvas {
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
    }
    setAttributes(el, value, changes) {
        if (!el)
            return;
        const target = changes ? changes : value;
        Object.keys(target).forEach((key) => {
            if (key.startsWith('on')) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace('on', '').toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key, target[key] ?? '');
            }
        });
    }
    ngAfterViewInit() {
        this.setAttributes(this.v?.nativeElement, this.attributes);
    }
    ngOnChanges(changes) {
        if (changes.attributes) {
            this.setAttributes(this.v?.nativeElement, this.attributes, changes.attributes.currentValue);
        }
    }
    ngOnDestroy() {
        this._listenerFns.forEach(fn => fn());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicCanvas, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DynamicCanvas, isStandalone: true, selector: "dynamic-canvas, DynamicCanvas", inputs: { attributes: "attributes", actionAttributes: "actionAttributes" }, viewQueries: [{ propertyName: "v", first: true, predicate: ["v"], descendants: true, read: ElementRef }], usesOnChanges: true, ngImport: i0, template: ` <canvas #v ><ng-content></ng-content></canvas> `, isInline: true, styles: [":host{display:contents}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicCanvas, decorators: [{
            type: Component,
            args: [{ selector: 'dynamic-canvas, DynamicCanvas', template: ` <canvas #v ><ng-content></ng-content></canvas> `, standalone: true, styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { attributes: [{
                type: Input
            }], actionAttributes: [{
                type: Input
            }], v: [{
                type: ViewChild,
                args: ['v', { read: ElementRef }]
            }] } });
class DynamicIframe {
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
    }
    setAttributes(el, value, changes) {
        if (!el)
            return;
        const target = changes ? changes : value;
        Object.keys(target).forEach((key) => {
            if (key.startsWith('on')) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace('on', '').toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key, target[key] ?? '');
            }
        });
    }
    ngAfterViewInit() {
        this.setAttributes(this.v?.nativeElement, this.attributes);
    }
    ngOnChanges(changes) {
        if (changes.attributes) {
            this.setAttributes(this.v?.nativeElement, this.attributes, changes.attributes.currentValue);
        }
    }
    ngOnDestroy() {
        this._listenerFns.forEach(fn => fn());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicIframe, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DynamicIframe, isStandalone: true, selector: "dynamic-iframe, DynamicIframe", inputs: { attributes: "attributes", actionAttributes: "actionAttributes" }, viewQueries: [{ propertyName: "v", first: true, predicate: ["v"], descendants: true, read: ElementRef }], usesOnChanges: true, ngImport: i0, template: ` <iframe #v ><ng-content></ng-content></iframe> `, isInline: true, styles: [":host{display:contents}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicIframe, decorators: [{
            type: Component,
            args: [{ selector: 'dynamic-iframe, DynamicIframe', template: ` <iframe #v ><ng-content></ng-content></iframe> `, standalone: true, styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { attributes: [{
                type: Input
            }], actionAttributes: [{
                type: Input
            }], v: [{
                type: ViewChild,
                args: ['v', { read: ElementRef }]
            }] } });

/** This file should be overriden for each framework. Ideally this would be implemented in Mitosis.  */
const TARGET = 'angular';

const getClassPropName = () => {
    switch (TARGET) {
        case 'react':
        case 'reactNative':
        case 'rsc':
            return 'className';
        case 'svelte':
        case 'vue':
        case 'solid':
        case 'qwik':
        case 'angular':
            return 'class';
    }
};

class BuilderButton {
    constructor() {
        this.node_0_DynamicRenderer = null;
        this.node_1_DynamicRenderer = null;
    }
    attrs() {
        return {
            ...this.attributes,
            [getClassPropName()]: `${this.link ? "" : "builder-button"} ${this.attributes[getClassPropName()] || ""}`,
            ...(this.link
                ? {
                    href: this.link,
                    target: this.openLinkInNewTab ? "_blank" : undefined,
                    role: "link",
                }
                : {
                    role: "button",
                }),
        };
    }
    ngOnInit() {
        this.node_0_DynamicRenderer = this.attrs();
        this.node_1_DynamicRenderer = {};
    }
    ngOnChanges(changes) {
        if (typeof window !== "undefined") {
            this.node_0_DynamicRenderer = this.attrs();
            this.node_1_DynamicRenderer = {};
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: BuilderButton, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: BuilderButton, isStandalone: true, selector: "builder-button", inputs: { attributes: "attributes", link: "link", openLinkInNewTab: "openLinkInNewTab", builderLinkComponent: "builderLinkComponent", text: "text" }, usesOnChanges: true, ngImport: i0, template: `
    <dynamic-renderer
      [attributes]="node_0_DynamicRenderer"
      [TagName]="link ? builderLinkComponent || 'a' : 'button'"
      [actionAttributes]="node_1_DynamicRenderer"
    >
      {{text}}
    </dynamic-renderer>
  `, isInline: true, styles: [":host{display:contents}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "component", type: DynamicRenderer, selector: "dynamic-renderer, DynamicRenderer", inputs: ["TagName", "attributes", "actionAttributes"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: BuilderButton, decorators: [{
            type: Component,
            args: [{ selector: "builder-button", template: `
    <dynamic-renderer
      [attributes]="node_0_DynamicRenderer"
      [TagName]="link ? builderLinkComponent || 'a' : 'button'"
      [actionAttributes]="node_1_DynamicRenderer"
    >
      {{text}}
    </dynamic-renderer>
  `, standalone: true, imports: [CommonModule, DynamicRenderer], styles: [":host{display:contents}\n"] }]
        }], propDecorators: { attributes: [{
                type: Input
            }], link: [{
                type: Input
            }], openLinkInNewTab: [{
                type: Input
            }], builderLinkComponent: [{
                type: Input
            }], text: [{
                type: Input
            }] } });

class BuilderContext {
    rootSetState() { }
    constructor() {
        this.content = null;
        this.context = {};
        this.localState = undefined;
        this.rootState = {};
        this.apiKey = null;
        this.apiVersion = undefined;
        this.componentInfos = {};
        this.inheritedStyles = {};
        this.BlocksWrapper = "div";
        this.BlocksWrapperProps = {};
        this.nonce = "";
        this.model = "";
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: BuilderContext, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: BuilderContext, providedIn: "root" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: BuilderContext, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: "root",
                }]
        }], ctorParameters: function () { return []; } });

class ComponentsContext {
    constructor() {
        this.registeredComponents = {};
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ComponentsContext, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ComponentsContext, providedIn: "root" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ComponentsContext, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: "root",
                }]
        }], ctorParameters: function () { return []; } });

const MSG_PREFIX = '[Builder.io]: ';
const logger = {
    log: (...message) => console.log(MSG_PREFIX, ...message),
    error: (...message) => console.error(MSG_PREFIX, ...message),
    warn: (...message) => console.warn(MSG_PREFIX, ...message),
    debug: (...message) => console.debug(MSG_PREFIX, ...message)
};

const get = (obj, path, defaultValue) => {
    const result = String.prototype.split.call(path, /[,[\].]+?/).filter(Boolean).reduce((res, key) => res !== null && res !== undefined ? res[key] : res, obj);
    return result === undefined || result === obj ? defaultValue : result;
};

function isBrowser() {
    return typeof window !== 'undefined' && typeof document !== 'undefined';
}

const convertSearchParamsToQueryObject = (searchParams) => {
    const options = {};
    searchParams.forEach((value, key) => {
        options[key] = value;
    });
    return options;
};
const normalizeSearchParams = (searchParams) => searchParams instanceof URLSearchParams ? convertSearchParamsToQueryObject(searchParams) : searchParams;
const getSearchString = (search) => {
    if (typeof search === 'string') {
        return search;
    }
    else if (search instanceof URLSearchParams) {
        return search.toString();
    }
    return new URLSearchParams(search).toString();
};

function isIframe() {
    return isBrowser() && window.self !== window.top;
}

function isEditing(search) {
    return isIframe() && (TARGET === 'reactNative' ||
        // accessing window.location.search is safe here because `isIframe()` is only `true` if we're in a browser.
        getSearchString(search || window.location.search).indexOf('builder.frameEditing=') !== -1);
}

const getLocation = () => {
    if (TARGET === 'reactNative') {
        return null;
    }
    else if (isBrowser()) {
        const parsedLocation = new URL(location.href);
        // IE11 bug with parsed path being empty string
        // causes issues with our user targeting
        if (parsedLocation.pathname === '') {
            parsedLocation.pathname = '/';
        }
        return parsedLocation;
    }
    else {
        console.warn('Cannot get location for tracking in non-browser environment');
        return null;
    }
};
const getUserAgent = () => typeof navigator === 'object' && navigator.userAgent || '';
const getUserAttributes = () => {
    const userAgent = getUserAgent();
    const isMobile = {
        Android() {
            return userAgent.match(/Android/i);
        },
        BlackBerry() {
            return userAgent.match(/BlackBerry/i);
        },
        iOS() {
            return userAgent.match(/iPhone|iPod/i);
        },
        Opera() {
            return userAgent.match(/Opera Mini/i);
        },
        Windows() {
            return userAgent.match(/IEMobile/i) || userAgent.match(/WPDesktop/i);
        },
        any() {
            return isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Opera() || isMobile.Windows() || TARGET === 'reactNative';
        }
    };
    const isTablet = userAgent.match(/Tablet|iPad/i);
    const url = getLocation();
    return {
        urlPath: url?.pathname,
        host: url?.host || url?.hostname,
        device: isTablet ? 'tablet' : isMobile.any() ? 'mobile' : 'desktop'
    };
};

const getFunctionArguments = ({ builder, context, event, state }) => {
    return Object.entries({
        state,
        Builder: builder,
        // legacy
        builder,
        context,
        event
    });
};
const getBuilderGlobals = () => ({
    isEditing: isEditing(),
    isBrowser: isBrowser(),
    isServer: !isBrowser(),
    getUserAttributes: () => getUserAttributes()
});
const parseCode = (code, { isExpression = true }) => {
    // Be able to handle simple expressions like "state.foo" or "1 + 1"
    // as well as full blocks like "var foo = "bar"; return foo"
    const useReturn = 
    // we disable this for cases where we definitely don't want a return
    isExpression && !(code.includes(';') || code.includes(' return ') || code.trim().startsWith('return '));
    const useCode = useReturn ? `return (${code});` : code;
    return useCode;
};
function flattenState({ rootState, localState, rootSetState }) {
    return new Proxy(rootState, {
        get: (target, prop) => {
            if (localState && prop in localState) {
                return localState[prop];
            }
            const val = target[prop];
            if (typeof val === 'object' && val !== null) {
                return flattenState({
                    rootState: val,
                    localState: undefined,
                    rootSetState: rootSetState ? subState => {
                        target[prop] = subState;
                        rootSetState(target);
                    } : undefined
                });
            }
            return val;
        },
        set: (target, prop, value) => {
            if (localState && prop in localState) {
                throw new Error('Writing to local state is not allowed as it is read-only.');
            }
            target[prop] = value;
            rootSetState?.(target);
            return true;
        }
    });
}

const runInBrowser = ({ code, builder, context, event, localState, rootSetState, rootState }) => {
    const functionArgs = getFunctionArguments({
        builder,
        context,
        event,
        state: flattenState({
            rootState,
            localState,
            rootSetState
        })
    });
    return new Function(...functionArgs.map(([name]) => name), code)(...functionArgs.map(([, value]) => value));
};

const checkIsDefined = (maybeT) => maybeT !== null && maybeT !== undefined;

/**
 * Identifies node runtime
 */
function isNodeRuntime() {
    return typeof process !== 'undefined' && checkIsDefined(process?.versions?.node);
}

const shouldForceBrowserRuntimeInNode = ({ shouldLogWarning }) => {
    if (!isNodeRuntime())
        return false;
    const isArm64 = process.arch === 'arm64';
    const isNode20 = process.version.startsWith('v20');
    const hasNoNodeSnapshotNodeOption = process.env.NODE_OPTIONS?.includes('--no-node-snapshot');
    if (isArm64 && isNode20 && !hasNoNodeSnapshotNodeOption) {
        if (shouldLogWarning) {
            logger.log(`Skipping usage of \`isolated-vm\` to avoid crashes in Node v20 on an arm64 machine.
    If you would like to use the \`isolated-vm\` package on this machine, please provide the \`NODE_OPTIONS=--no-node-snapshot\` config to your Node process.
    See https://github.com/BuilderIO/builder/blob/main/packages/sdks/README.md#node-v20--m1-macs-apple-silicon-support for more information.
    `);
        }
        return true;
    }
    return false;
};

/*
 * THIS FILE IS EXPECTED TO EXIST WITH THIS EXACT NAME BY SUBSEQUENT BUNDLE STEPS THAT TRANSFORM IT.
 * DO NOT RENAME THIS FILE.
 */
/**
 * Even though we have separate runtimes for browser/node/edge, sometimes frameworks will
 * end up sending the server runtime code to the browser (most notably in dev mode).
 */
const chooseBrowserOrServerEval = (args) => isBrowser() || shouldForceBrowserRuntimeInNode({
    shouldLogWarning: true
}) ? runInBrowser(args) : runInBrowser(args);

/**
 * handles multi-level gets on state: `state.x.y.z`
 * does not handle bracket notation
 * see https://regexr.com/87a9j
 */
const STATE_GETTER_REGEX = /^(return )?(\s*)?state(?<getPath>(\.\w+)+)(\s*);?$/;
/**
 * Handles multi-level gets on state transpiled by rollup with virtual index.
 * see https://regexr.com/87ai4
 */
const VIRTUAL_INDEX_REGEX = /(\s)*var(\s)+_virtual_index(\s)*=(\s)*state(?<getPath>(\.\w+)+)(\s*);?(\s)*return(\s)*_virtual_index(\s)*/;
const getSimpleExpressionGetPath = (code) => {
    return STATE_GETTER_REGEX.exec(code.trim())?.groups?.getPath?.slice(1) || VIRTUAL_INDEX_REGEX.exec(code.trim())?.groups?.getPath?.slice(1);
};
function evaluate({ code, context, localState, rootState, rootSetState, event, isExpression = true }) {
    if (code.trim() === '') {
        return undefined;
    }
    /**
     * For very simple expressions like "state.foo" we can optimize by skipping
     * the executor altogether.
     * We try not to take many risks with this optimizations, so we only do it for
     * `state.{path}` expressions.
     */
    const getPath = getSimpleExpressionGetPath(code.trim());
    if (getPath) {
        return get({
            ...rootState,
            ...localState
        }, getPath);
    }
    const args = {
        code: parseCode(code, {
            isExpression
        }),
        builder: getBuilderGlobals(),
        context,
        event,
        rootSetState,
        rootState,
        localState
    };
    try {
        const newEval = chooseBrowserOrServerEval(args);
        return newEval;
    }
    catch (e) {
        logger.error('Failed code evaluation: ' + e.message, {
            code
        });
        return undefined;
    }
}

function getBlockComponentOptions(block, context) {
    return {
        ...block.component?.options,
        ...block.options,
        ...evaluateTextComponentTextOption(block, context)
    };
}
const evaluateTextComponentTextOption = (block, context) => {
    if (block.component?.name === 'Text' && block.component.options?.text && typeof block.component.options.text === 'string') {
        return {
            ...block.component.options,
            text: block.component.options.text.replace(/{{([^}]+)}}/g, (_match, group) => evaluate({
                code: group,
                context,
                localState: context.localState,
                rootState: context.rootState,
                rootSetState: context.rootSetState
            }))
        };
    }
};

function omit(obj, ...values) {
    const newObject = Object.assign({}, obj);
    for (const key of values) {
        delete newObject[key];
    }
    return newObject;
}

/**
 * Recursively traverses an object or array, invoking a callback on each value.
 *
 * @param {any} obj - The object or array to traverse. Can also handle primitives, null, or undefined.
 * @param {TraverseCallback} callback - The function to invoke on each value. Receives the current value
 * and an `update` function to modify the value in its parent container.
 * @param {any} [parent=null] - The parent object or array of the current value. Used internally.
 * @param {any} [key=null] - The key or index of the current value in its parent. Used internally.
 * @param {WeakSet} [visited=new WeakSet()] - Tracks visited objects to handle circular references. Used internally.
 *
 * @example
 * // Example: Doubling all numbers in an object
 * const obj = { a: 1, b: [2, 3, { c: 4 }] };
 * traverse(obj, (value, update) => {
 *   if (typeof value === 'number') {
 *     update(value * 2);
 *   }
 * });
 * console.log(obj); // { a: 2, b: [4, 6, { c: 8 }] }
 *
 * @example
 * // Example: Handling circular references
 * const obj = { a: 1 };
 * obj.self = obj;
 * traverse(obj, (value, update) => {
 *   if (typeof value === 'number') {
 *     update(value * 2);
 *   }
 * });
 * console.log(obj.a); // 2
 */
function traverse(obj, callback, parent = null, key = null, visited = new WeakSet()) {
    if (obj == null || typeof obj !== 'object') {
        callback(obj, (newValue) => {
            if (parent !== null && key !== null) {
                parent[key] = newValue;
            }
        });
        return;
    }
    if (visited.has(obj)) {
        return;
    }
    visited.add(obj);
    if (Array.isArray(obj)) {
        obj.forEach((item, index) => {
            const update = (newValue) => {
                obj[index] = newValue;
            };
            callback(item, update);
            traverse(item, callback, obj, index, visited);
        });
    }
    else {
        Object.entries(obj).forEach(([key, value]) => {
            const update = (newValue) => {
                obj[key] = newValue;
            };
            callback(value, update);
            traverse(value, callback, obj, key, visited);
        });
    }
}

function isLocalizedField(value) {
    return value && typeof value === 'object' && value['@type'] === '@builder.io/core:LocalizedValue';
}
function containsLocalizedValues(data) {
    if (!data || !Object.getOwnPropertyNames(data).length) {
        return false;
    }
    let hasLocalizedValues = false;
    traverse(data, value => {
        if (isLocalizedField(value)) {
            hasLocalizedValues = true;
            return;
        }
    });
    return hasLocalizedValues;
}
function extractLocalizedValues(data, locale) {
    if (!data || !Object.getOwnPropertyNames(data).length) {
        return {};
    }
    traverse(data, (value, update) => {
        if (isLocalizedField(value)) {
            update(value[locale] ?? undefined);
        }
    });
    return data;
}
function resolveLocalizedValues(block, locale) {
    if (block.component?.options && containsLocalizedValues(block.component?.options)) {
        if (!locale) {
            console.warn('[Builder.io] In order to use localized fields in Builder, you must pass a locale prop to the BuilderComponent or to options object while fetching the content to resolve localized fields. Learn more: https://www.builder.io/c/docs/localization-inline#targeting-and-inline-localization');
        }
        block.component.options = extractLocalizedValues(block.component.options, locale ?? 'Default');
    }
    return block;
}

/**
 * We need to serialize values to a string in case there are Proxy values, as is the case with SolidJS etc.
 */
const fastClone = (obj) => JSON.parse(JSON.stringify(obj));

/**
 * Minimal implementation of lodash's _.set
 * https://lodash.com/docs/4.17.15#set
 *
 * See ./set.test.ts for usage examples
 */
const set = (obj, _path, value) => {
    if (Object(obj) !== obj) {
        return obj;
    }
    const path = Array.isArray(_path) ? _path : _path.toString().match(/[^.[\]]+/g);
    path.slice(0, -1).reduce((a, c, i) => Object(a[c]) === a[c] ? a[c] : a[c] = Math.abs(Number(path[i + 1])) >> 0 === +path[i + 1] ? [] : {}, obj)[path[path.length - 1]] = value;
    return obj;
};

// Noope way for targets to make modifications to the block object if/as needed
function transformBlock(block) {
    return block;
}

// Deep clone a block but without cloning any child blocks
function deepCloneWithConditions(obj) {
    if (obj === null || typeof obj !== 'object') {
        return obj;
    }
    if (Array.isArray(obj)) {
        return obj.map((item) => deepCloneWithConditions(item));
    }
    if (obj['@type'] === '@builder.io/sdk:Element') {
        return obj;
    }
    const clonedObj = {};
    for (const key in obj) {
        if (key !== 'meta' && Object.prototype.hasOwnProperty.call(obj, key)) {
            clonedObj[key] = deepCloneWithConditions(obj[key]);
        }
    }
    return clonedObj;
}
const IS_SDK_WITHOUT_CACHED_PROCESSED_BLOCK = ['svelte', 'vue', 'angular', 'qwik', 'solid'].includes(TARGET);
const getCopy = (block) => {
    if (IS_SDK_WITHOUT_CACHED_PROCESSED_BLOCK) {
        const copy = fastClone(block);
        const copied = {
            ...copy,
            properties: {
                ...copy.properties
            },
            actions: {
                ...copy.actions
            }
        };
        return copied;
    }
    else {
        const copy = deepCloneWithConditions(omit(block, 'children', 'meta'));
        return {
            ...copy,
            properties: {
                ...copy.properties
            },
            actions: {
                ...copy.actions
            },
            children: block.children,
            meta: block.meta
        };
    }
};
const evaluateBindings = ({ block, context, localState, rootState, rootSetState }) => {
    if (!block.bindings) {
        return block;
    }
    const copied = getCopy(block);
    for (const binding in block.bindings) {
        const expression = block.bindings[binding];
        const value = evaluate({
            code: expression,
            localState,
            rootState,
            rootSetState,
            context
        });
        set(copied, binding, value);
    }
    return copied;
};
function getProcessedBlock({ block, context, localState, rootState, rootSetState }) {
    let transformedBlock = resolveLocalizedValues(block, rootState.locale);
    transformedBlock = transformBlock(transformedBlock);
    return evaluateBindings({
        block: transformedBlock,
        localState,
        rootState,
        rootSetState,
        context
    });
}

class DynamicDiv {
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
    }
    ngAfterViewInit() {
        const el = this.v?.nativeElement;
        if (!el) {
            return;
        }
        this.setAttributes(el, this.attributes);
        this.setAttributes(el, this.actionAttributes);
        this.setAttributes(el, this.showContentProps);
        this.setAttribute(el, 'class', [this.classProp ?? '', this.className ?? ''].join(' ').trim());
        this.handleStyleProp(el, this.style);
        this.setAttribute(el, 'builder-parent-id', this.builderParentId);
        this.setAttribute(el, 'builder-path', this.builderPath);
        this.setAttribute(el, 'builder-model', this.builderModel);
        this.setAttribute(el, 'builder-content-id', this.builderContentId);
        this.setAttribute(el, 'hidden', this.hidden);
        this.setAttribute(el, 'aria-hidden', this.ariaHidden);
    }
    ngOnChanges(changes) {
        const el = this.v?.nativeElement;
        if (!el) {
            return;
        }
        if (Object.keys(changes).length === 0) {
            return;
        }
        if (changes.attributes) {
            this.setAttributes(el, this.attributes, changes.attributes.currentValue);
        }
        if (changes.actionAttributes) {
            this.setAttributes(el, this.actionAttributes, changes.actionAttributes.currentValue);
        }
        if (changes.showContentProps) {
            this.setAttributes(el, this.showContentProps, changes.showContentProps.currentValue);
        }
        if (changes.classProp || changes.className) {
            this.setAttribute(el, 'class', [this.classProp ?? '', this.className ?? ''].join(' ').trim());
        }
        if (changes.style)
            this.handleStyleProp(el, this.style);
        if (changes.builderParentId)
            this.setAttribute(el, 'builder-parent-id', this.builderParentId);
        if (changes.builderPath)
            this.setAttribute(el, 'builder-path', this.builderPath);
        if (changes.builderModel)
            this.setAttribute(el, 'builder-model', this.builderModel);
        if (changes.builderContentId)
            this.setAttribute(el, 'builder-content-id', this.builderContentId);
        if (changes.hidden)
            this.setAttribute(el, 'hidden', this.hidden);
        if (changes.ariaHidden)
            this.setAttribute(el, 'aria-hidden', this.ariaHidden);
    }
    setAttributes(el, value, changes) {
        if (!el)
            return;
        const target = changes ? changes : value;
        if (!target)
            return;
        Object.keys(target).forEach((key) => {
            if (key.startsWith('on')) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace('on', '').toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key, target[key] ?? '');
            }
        });
    }
    setAttribute(el, key, value) {
        if (value) {
            this.renderer.setAttribute(el, key, value);
        }
    }
    handleStyleProp(el, style) {
        if (typeof style === 'object') {
            Object.entries(style).forEach(([key, value]) => {
                this.renderer.setStyle(el, key, value);
            });
        }
        else {
            this.renderer.setAttribute(el, 'style', style);
        }
    }
    ngOnDestroy() {
        this._listenerFns.forEach((fn) => fn());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicDiv, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DynamicDiv, isStandalone: true, selector: "dynamic-div, DynamicDiv", inputs: { attributes: "attributes", actionAttributes: "actionAttributes", BlockWrapperProps: "BlockWrapperProps", builderPath: ["builder-path", "builderPath"], builderParentId: ["builder-parent-id", "builderParentId"], BlocksWrapperProps: "BlocksWrapperProps", contentWrapperProps: "contentWrapperProps", builderModel: ["builder-model", "builderModel"], builderContentId: ["builder-content-id", "builderContentId"], ref: "ref", classProp: ["class", "classProp"], style: "style", showContentProps: "showContentProps", onClick: "onClick", onMouseEnter: "onMouseEnter", onKeyPress: "onKeyPress", hidden: "hidden", ariaHidden: ["aria-hidden", "ariaHidden"], className: "className" }, viewQueries: [{ propertyName: "v", first: true, predicate: ["v"], descendants: true, read: ElementRef }], usesOnChanges: true, ngImport: i0, template: `
    <div
      #v
      (click)="onClick && onClick($event)"
      (mouseenter)="onMouseEnter && onMouseEnter($event)"
    >
      <ng-content></ng-content>
    </div>
  `, isInline: true, styles: [":host{display:contents}\n", ".props-blocks-wrapper{display:flex;flex-direction:column;align-items:stretch}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DynamicDiv, decorators: [{
            type: Component,
            args: [{ selector: 'dynamic-div, DynamicDiv', template: `
    <div
      #v
      (click)="onClick && onClick($event)"
      (mouseenter)="onMouseEnter && onMouseEnter($event)"
    >
      <ng-content></ng-content>
    </div>
  `, standalone: true, imports: [CommonModule], styles: [":host{display:contents}\n", ".props-blocks-wrapper{display:flex;flex-direction:column;align-items:stretch}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { attributes: [{
                type: Input
            }], actionAttributes: [{
                type: Input
            }], BlockWrapperProps: [{
                type: Input
            }], builderPath: [{
                type: Input,
                args: ['builder-path']
            }], builderParentId: [{
                type: Input,
                args: ['builder-parent-id']
            }], BlocksWrapperProps: [{
                type: Input
            }], contentWrapperProps: [{
                type: Input
            }], builderModel: [{
                type: Input,
                args: ['builder-model']
            }], builderContentId: [{
                type: Input,
                args: ['builder-content-id']
            }], ref: [{
                type: Input
            }], classProp: [{
                type: Input,
                args: ['class']
            }], style: [{
                type: Input
            }], showContentProps: [{
                type: Input
            }], onClick: [{
                type: Input
            }], onMouseEnter: [{
                type: Input
            }], onKeyPress: [{
                type: Input
            }], hidden: [{
                type: Input
            }], ariaHidden: [{
                type: Input,
                args: ['aria-hidden']
            }], className: [{
                type: Input
            }], v: [{
                type: ViewChild,
                args: ['v', { read: ElementRef }]
            }] } });

const camelToKebabCase = (str) => str ? str.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, '$1-$2').toLowerCase() : '';

// eslint-disable-next-line @typescript-eslint/ban-types
function throttle(func, wait, options = {}) {
    let context;
    let args;
    let result;
    let timeout = null;
    let previous = 0;
    const later = function () {
        previous = options.leading === false ? 0 : Date.now();
        timeout = null;
        result = func.apply(context, args);
        if (!timeout)
            context = args = null;
    };
    return function () {
        const now = Date.now();
        if (!previous && options.leading === false)
            previous = now;
        const remaining = wait - (now - previous);
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        context = this;
        // eslint-disable-next-line prefer-rest-params
        args = arguments;
        if (remaining <= 0 || remaining > wait) {
            if (timeout) {
                clearTimeout(timeout);
                timeout = null;
            }
            previous = now;
            result = func.apply(context, args);
            if (!timeout)
                context = args = null;
        }
        else if (!timeout && options.trailing !== false) {
            timeout = setTimeout(later, remaining);
        }
        return result;
    };
}
function assign(target, ..._args) {
    const to = Object(target);
    for (let index = 1; index < arguments.length; index++) {
        // eslint-disable-next-line prefer-rest-params
        const nextSource = arguments[index];
        if (nextSource != null) {
            // Skip over if undefined or null
            for (const nextKey in nextSource) {
                // Avoid bugs when hasOwnProperty is shadowed
                if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                    to[nextKey] = nextSource[nextKey];
                }
            }
        }
    }
    return to;
}
function bindAnimations(animations) {
    if (TARGET === 'reactNative') {
        return;
    }
    for (const animation of animations) {
        switch (animation.trigger) {
            case 'pageLoad':
                triggerAnimation(animation);
                break;
            case 'scrollInView':
                bindScrollInViewAnimation(animation);
                break;
        }
    }
}
function warnElementNotPresent(id) {
    console.warn(`Cannot animate element: element with ID ${id} not found!`);
}
function augmentAnimation(animation, element) {
    const stylesUsed = getAllStylesUsed(animation);
    const computedStyle = getComputedStyle(element);
    // const computedStyle = getComputedStyle(element);
    // // FIXME: this will break if original load is in one reponsive size then resize to another hmmm
    // Need to use transform instead of left since left can change on screen sizes
    const firstStyles = animation.steps[0].styles;
    const lastStyles = animation.steps[animation.steps.length - 1].styles;
    const bothStyles = [firstStyles, lastStyles];
    // FIXME: this won't work as expected for augmented animations - may need the editor itself to manage this
    for (const styles of bothStyles) {
        for (const style of stylesUsed) {
            if (!(style in styles)) {
                styles[style] = computedStyle[style];
            }
        }
    }
}
function getAllStylesUsed(animation) {
    const properties = [];
    for (const step of animation.steps) {
        for (const key in step.styles) {
            if (properties.indexOf(key) === -1) {
                properties.push(key);
            }
        }
    }
    return properties;
}
function triggerAnimation(animation) {
    // TODO: do for ALL elements
    const elements = Array.prototype.slice.call(document.getElementsByClassName(animation.elementId || animation.id || ''));
    if (!elements.length) {
        warnElementNotPresent(animation.elementId || animation.id || '');
        return;
    }
    Array.from(elements).forEach(element => {
        augmentAnimation(animation, element);
        // TODO: do this properly, may have other animations of different properties
        // TODO: only override the properties
        // TODO: if there is an entrance and hover animation, the transition duration will get effed
        // element.setAttribute('style', '');
        // const styledUsed = this.getAllStylesUsed(animation);
        element.style.transition = 'none';
        element.style.transitionDelay = '0';
        assign(element.style, animation.steps[0].styles);
        // TODO: queue/batch these timeouts
        // TODO: only include properties explicitly set in the animation
        // using Object.keys(styles)
        setTimeout(() => {
            element.style.transition = `all ${animation.duration}s ${camelToKebabCase(animation.easing)}`;
            if (animation.delay) {
                element.style.transitionDelay = animation.delay + 's';
            }
            assign(element.style, animation.steps[1].styles);
            // TODO: maybe remove/reset transitoin property after animation duration
            // TODO: queue timers
            setTimeout(() => {
                // TODO: what if has other transition (reset back to what it was)
                element.style.transition = '';
                element.style.transitionDelay = '';
            }, (animation.delay || 0) * 1000 + animation.duration * 1000 + 100);
        });
    });
}
// TODO: unbind on element remove
function bindScrollInViewAnimation(animation) {
    // TODO: apply to ALL matching elements
    const elements = Array.prototype.slice.call(document.getElementsByClassName(animation.elementId || animation.id || ''));
    if (!elements.length) {
        warnElementNotPresent(animation.elementId || animation.id || '');
        return;
    }
    // TODO: if server side rendered and scrolled into view don't animate...
    Array.from(elements).forEach(element => {
        augmentAnimation(animation, element);
        let triggered = false;
        let pendingAnimation = false;
        function immediateOnScroll() {
            if (!triggered && isScrolledIntoView(element)) {
                triggered = true;
                pendingAnimation = true;
                setTimeout(() => {
                    assign(element.style, animation.steps[1].styles);
                    if (!animation.repeat) {
                        document.removeEventListener('scroll', onScroll);
                    }
                    setTimeout(() => {
                        pendingAnimation = false;
                        if (!animation.repeat) {
                            element.style.transition = '';
                            element.style.transitionDelay = '';
                        }
                    }, (animation.duration + (animation.delay || 0)) * 1000 + 100);
                });
            }
            else if (animation.repeat && triggered && !pendingAnimation && !isScrolledIntoView(element)) {
                // we want to repeat the animation every time the the element is out of view and back again
                triggered = false;
                assign(element.style, animation.steps[0].styles);
            }
        }
        // TODO: roll all of these in one for more efficiency of checking all the rects
        const onScroll = throttle(immediateOnScroll, 200, {
            leading: false
        });
        // TODO: fully in view or partially
        function isScrolledIntoView(elem) {
            const rect = elem.getBoundingClientRect();
            const windowHeight = window.innerHeight;
            const thresholdPercent = (animation.thresholdPercent || 0) / 100;
            const threshold = thresholdPercent * windowHeight;
            // TODO: partial in view? or what if element is larger than screen itself
            return rect.bottom > threshold && rect.top < windowHeight - threshold // Element is peeking top or bottom
            ;
        }
        const defaultState = animation.steps[0].styles;
        function attachDefaultState() {
            assign(element.style, defaultState);
        }
        attachDefaultState();
        // TODO: queue/batch these timeouts!
        setTimeout(() => {
            element.style.transition = `all ${animation.duration}s ${camelToKebabCase(animation.easing)}`;
            if (animation.delay) {
                element.style.transitionDelay = animation.delay + 's';
            }
        });
        // TODO: one listener for everything
        document.addEventListener('scroll', onScroll, {
            capture: true,
            passive: true
        });
        // Do an initial check
        immediateOnScroll();
    });
}

const TEXT_STYLE_KEYS = ['color', 'whiteSpace', 'direction', 'hyphens', 'overflowWrap'];
/**
 * Check if the key represent a CSS style property that applies to text
 * See MDN docs for refrence of what properties apply to text.
 * https://developer.mozilla.org/en-US/docs/Learn/CSS/Styling_text/Fundamentals#summary
 */
const isTextStyle = (key) => {
    return TEXT_STYLE_KEYS.includes(key) || key.startsWith('font') || key.startsWith('text') || key.startsWith('letter') || key.startsWith('line') || key.startsWith('word') || key.startsWith('writing');
};
/**
 * Extract styles that apply to text from a style object.
 */
const extractTextStyles = (styles) => {
    const textStyles = {};
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Object.entries(styles).forEach(([key, value]) => {
        if (isTextStyle(key)) {
            textStyles[key] = value;
        }
    });
    return textStyles;
};

const convertStyleMapToCSSArray = (style) => {
    const cssProps = Object.entries(style).map(([key, value]) => {
        if (typeof value === 'string') {
            return `${camelToKebabCase(key)}: ${value};`;
        }
        else {
            return undefined;
        }
    });
    return cssProps.filter(checkIsDefined);
};
const convertStyleMapToCSS = (style) => convertStyleMapToCSSArray(style).join('\n');
const createCssClass = ({ mediaQuery, className, styles }) => {
    const cssClass = `.${className} {
    ${convertStyleMapToCSS(styles)}
  }`;
    if (mediaQuery) {
        return `${mediaQuery} {
      ${cssClass}
    }`;
    }
    else {
        return cssClass;
    }
};

function transformStyleProperty({ style }) {
    return style;
}

const getStyle = ({ block, context }) => {
    return mapStyleObjToStrIfNeeded(transformStyleProperty({
        style: block.style || {},
        context,
        block
    }));
};
/**
 * Svelte does not support style attribute as an object so we need to flatten it.
 *
 * Additionally, Svelte, Vue and other frameworks use kebab-case styles, so we need to convert them.
 */
function mapStyleObjToStrIfNeeded(style) {
    switch (TARGET) {
        case 'svelte':
        case 'vue':
        case 'solid':
        case 'angular':
            return convertStyleMapToCSSArray(style).join(' ');
        case 'qwik':
        case 'reactNative':
        case 'react':
        case 'rsc':
            return style;
    }
}

const checkIsComponentRestricted = (component, model) => {
    if (!component)
        return true;
    if (!model)
        return false;
    return component.models && component.models.length > 0 && !component.models.includes(model);
};
const getComponent = ({ block, registeredComponents, model }) => {
    const componentName = block.component?.name;
    if (!componentName) {
        return null;
    }
    const ref = registeredComponents[componentName];
    if (!ref || checkIsComponentRestricted(ref, model)) {
        // TODO: Public doc page with more info about this message
        console.warn(`
      Could not find a registered component named "${componentName}". 
      If you registered it, is the file that registered it imported by the file that needs to render it?`);
        return undefined;
    }
    else {
        return ref;
    }
};
const getRepeatItemData = ({ block, context }) => {
    /**
     * we don't use `state.processedBlock` here because the processing done within its logic includes evaluating the block's bindings,
     * which will not work if there is a repeat.
     */
    const { repeat, ...blockWithoutRepeat } = block;
    if (!repeat?.collection) {
        return undefined;
    }
    const itemsArray = evaluate({
        code: repeat.collection,
        localState: context.localState,
        rootState: context.rootState,
        rootSetState: context.rootSetState,
        context: context.context
    });
    if (!Array.isArray(itemsArray)) {
        return undefined;
    }
    const collectionName = repeat.collection.split('.').pop();
    const itemNameToUse = repeat.itemName || (collectionName ? collectionName + 'Item' : 'item');
    const repeatArray = itemsArray.map((item, index) => ({
        context: {
            ...context,
            localState: {
                ...context.localState,
                $index: index,
                $item: item,
                [itemNameToUse]: item,
                [`$${itemNameToUse}Index`]: index
            }
        },
        block: blockWithoutRepeat
    }));
    return repeatArray;
};
const getInheritedStyles = ({ block, context }) => {
    const style = getStyle({
        block,
        context
    });
    if (!style) {
        return {};
    }
    return extractTextStyles(style);
};
const provideLinkComponent = (block, linkComponent) => {
    if (block?.shouldReceiveBuilderProps?.builderLinkComponent)
        return {
            builderLinkComponent: linkComponent
        };
    return {};
};
const provideRegisteredComponents = (block, registeredComponents, model) => {
    if (block?.shouldReceiveBuilderProps?.builderComponents) {
        const filteredRegisteredComponents = Object.fromEntries(Object.entries(registeredComponents).filter(([_, component]) => {
            return !checkIsComponentRestricted(component, model);
        }));
        return {
            builderComponents: filteredRegisteredComponents
        };
    }
    return {};
};
const provideBuilderBlock = (block, builderBlock) => {
    if (block?.shouldReceiveBuilderProps?.builderBlock)
        return {
            builderBlock
        };
    return {};
};
const provideBuilderContext = (block, context) => {
    if (block?.shouldReceiveBuilderProps?.builderContext)
        return {
            builderContext: context
        };
    return {};
};

const SIZES = {
    xsmall: {
        min: 0,
        default: 160,
        max: 320
    },
    small: {
        min: 321,
        default: 321,
        max: 640
    },
    medium: {
        min: 641,
        default: 642,
        max: 991
    },
    large: {
        min: 990,
        default: 991,
        max: 1200
    }
};
const getMaxWidthQueryForSize = (size, sizeValues = SIZES) => `@media (max-width: ${sizeValues[size].max}px)`;
const getSizesForBreakpoints = (breakpoints) => {
    const newSizes = fastClone(SIZES); // Note: this helps to get a deep clone of fields like small, medium etc
    if (!breakpoints) {
        return newSizes;
    }
    const { xsmall, small, medium } = breakpoints;
    if (xsmall) {
        const xsmallMin = Math.floor(xsmall / 2);
        newSizes.xsmall = {
            max: xsmall,
            min: xsmallMin,
            default: xsmallMin + 1
        };
    }
    if (!small || !medium) {
        return newSizes;
    }
    const smallMin = xsmall ? newSizes.xsmall.max + 1 : Math.floor(small / 2);
    newSizes.small = {
        max: small,
        min: smallMin,
        default: smallMin + 1
    };
    const mediumMin = newSizes.small.max + 1;
    newSizes.medium = {
        max: medium,
        min: mediumMin,
        default: mediumMin + 1
    };
    const largeMin = newSizes.medium.max + 1;
    newSizes.large = {
        max: 2000,
        // TODO: decide upper limit
        min: largeMin,
        default: largeMin + 1
    };
    return newSizes;
};

class InlinedStyles {
    constructor(renderer, document) {
        this.renderer = renderer;
        this.document = document;
    }
    ngOnChanges(changes) {
        if (changes.styles) {
            if (this.styleElement) {
                this.styleElement.textContent = this.styles;
            }
            else {
                this.styleElement = this.renderer.createElement('style');
                this.renderer.setAttribute(this.styleElement, 'data-id', this.id);
                this.renderer.appendChild(this.styleElement, this.renderer.createText(this.styles));
                this.renderer.setAttribute(this.styleElement, 'nonce', this.nonce);
                this.renderer.appendChild(this.document.head, this.styleElement);
            }
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: InlinedStyles, deps: [{ token: i0.Renderer2 }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: InlinedStyles, isStandalone: true, selector: "inlined-styles, InlinedStyles", inputs: { styles: "styles", id: "id", nonce: "nonce" }, usesOnChanges: true, ngImport: i0, template: ``, isInline: true, styles: [":host{display:contents}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: InlinedStyles, decorators: [{
            type: Component,
            args: [{ selector: 'inlined-styles, InlinedStyles', template: ``, standalone: true, imports: [CommonModule], styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }, { type: Document, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }]; }, propDecorators: { styles: [{
                type: Input
            }], id: [{
                type: Input
            }], nonce: [{
                type: Input
            }] } });

class BlockStyles {
    constructor() {
        this.TARGET = TARGET;
    }
    get canShowBlock() {
        const processedBlock = this.block;
        // only render styles for blocks that are visible
        if (checkIsDefined(processedBlock.hide)) {
            return !processedBlock.hide;
        }
        if (checkIsDefined(processedBlock.show)) {
            return processedBlock.show;
        }
        return true;
    }
    get css() {
        const processedBlock = this.block;
        const styles = processedBlock.responsiveStyles;
        const content = this.context.content;
        const sizesWithUpdatedBreakpoints = getSizesForBreakpoints(content?.meta?.breakpoints || {});
        const contentHasXSmallBreakpoint = Boolean(content?.meta?.breakpoints?.xsmall);
        const largeStyles = styles?.large;
        const mediumStyles = styles?.medium;
        const smallStyles = styles?.small;
        const xsmallStyles = styles?.xsmall;
        const className = processedBlock.id;
        if (!className) {
            return "";
        }
        const largeStylesClass = largeStyles
            ? createCssClass({
                className,
                styles: largeStyles,
            })
            : "";
        const mediumStylesClass = mediumStyles
            ? createCssClass({
                className,
                styles: mediumStyles,
                mediaQuery: getMaxWidthQueryForSize("medium", sizesWithUpdatedBreakpoints),
            })
            : "";
        const smallStylesClass = smallStyles
            ? createCssClass({
                className,
                styles: smallStyles,
                mediaQuery: getMaxWidthQueryForSize("small", sizesWithUpdatedBreakpoints),
            })
            : "";
        const xsmallStylesClass = xsmallStyles && contentHasXSmallBreakpoint
            ? createCssClass({
                className,
                styles: xsmallStyles,
                mediaQuery: getMaxWidthQueryForSize("xsmall", sizesWithUpdatedBreakpoints),
            })
            : "";
        const hoverAnimation = processedBlock.animations &&
            processedBlock.animations.find((item) => item.trigger === "hover");
        let hoverStylesClass = "";
        if (hoverAnimation) {
            const hoverStyles = hoverAnimation.steps?.[1]?.styles || {};
            hoverStylesClass =
                createCssClass({
                    className: `${className}:hover`,
                    styles: {
                        ...hoverStyles,
                        transition: `all ${hoverAnimation.duration}s ${camelToKebabCase(hoverAnimation.easing)}`,
                        transitionDelay: hoverAnimation.delay
                            ? `${hoverAnimation.delay}s`
                            : "0s",
                    },
                }) || "";
        }
        return [
            largeStylesClass,
            mediumStylesClass,
            smallStylesClass,
            xsmallStylesClass,
            hoverStylesClass,
        ].join(" ");
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: BlockStyles, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: BlockStyles, isStandalone: true, selector: "block-styles", inputs: { block: "block", context: "context" }, ngImport: i0, template: `
    <ng-container *ngIf="TARGET !== 'reactNative' && css && canShowBlock">
      <inlined-styles
        id="builderio-block"
        [styles]="css"
        [nonce]="context.nonce"
      ></inlined-styles>
    </ng-container>
  `, isInline: true, styles: [":host{display:contents}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: InlinedStyles, selector: "inlined-styles, InlinedStyles", inputs: ["styles", "id", "nonce"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: BlockStyles, decorators: [{
            type: Component,
            args: [{ selector: "block-styles", template: `
    <ng-container *ngIf="TARGET !== 'reactNative' && css && canShowBlock">
      <inlined-styles
        id="builderio-block"
        [styles]="css"
        [nonce]="context.nonce"
      ></inlined-styles>
    </ng-container>
  `, standalone: true, imports: [CommonModule, InlinedStyles], styles: [":host{display:contents}\n"] }]
        }], propDecorators: { block: [{
                type: Input
            }], context: [{
                type: Input
            }] } });

function capitalizeFirstLetter(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
}
const getEventHandlerName = (key) => `on${capitalizeFirstLetter(key)}`;

const createEventHandler = (value, options) => event => evaluate({
    code: value,
    context: options.context,
    localState: options.localState,
    rootState: options.rootState,
    rootSetState: options.rootSetState,
    event,
    isExpression: false
});

function getBlockActions(options) {
    const obj = {};
    const optionActions = options.block.actions ?? {};
    for (const key in optionActions) {
        // eslint-disable-next-line no-prototype-builtins
        if (!optionActions.hasOwnProperty(key)) {
            continue;
        }
        const value = optionActions[key];
        let eventHandlerName = getEventHandlerName(key);
        if (options.stripPrefix) {
            switch (TARGET) {
                case 'vue':
                    eventHandlerName = eventHandlerName.replace('v-on:', '');
                    break;
                case 'svelte':
                    eventHandlerName = eventHandlerName.replace('on:', '');
                    break;
            }
        }
        obj[eventHandlerName] = createEventHandler(value, options);
    }
    return obj;
}

function transformBlockProperties({ properties }) {
    return properties;
}

const extractRelevantRootBlockProperties = (block) => {
    // currently we are only spreading the `href` property
    // TO-DO: potentially spread all properties from block, but only if they are not already defined by BuilderBlock
    // const {
    //   '@type': _type,
    //   '@version': _version,
    //   id: _id,
    //   tagName: _tagName,
    //   layerName: _layerName,
    //   groupLocked: _groupLocked,
    //   layerLocked: _layerLocked,
    //   class: _class,
    //   children: _children,
    //   responsiveStyles: _responsiveStyles,
    //   component: _component,
    //   bindings: _bindings,
    //   meta: _meta,
    //   actions: _actions,
    //   properties: _properties,
    //   code: _code,
    //   repeat: _repeat,
    //   animations: _animations,
    //   style: _style,
    //   hide: _hide,
    //   show: _show,
    //   // anything set by dynamic bindings outside of predefined `BuilderBlock` properties
    //   ...remainingBlockProperties
    // } = block;
    return {
        href: block.href
    };
};
function getBlockProperties({ block, context }) {
    const properties = {
        ...extractRelevantRootBlockProperties(block),
        ...block.properties,
        'builder-id': block.id,
        style: getStyle({
            block,
            context
        }),
        [getClassPropName()]: [block.id, 'builder-block', block.class, block.properties?.class].filter(Boolean).join(' ')
    };
    return transformBlockProperties({
        properties,
        context,
        block
    });
}

class BlockWrapper {
    constructor() {
        this.node_0_DynamicRenderer = null;
        this.node_1_DynamicRenderer = null;
    }
    ngOnInit() {
        this.node_0_DynamicRenderer = getBlockProperties({
            block: this.block,
            context: this.context,
        });
        this.node_1_DynamicRenderer = getBlockActions({
            block: this.block,
            rootState: this.context.rootState,
            rootSetState: this.context.rootSetState,
            localState: this.context.localState,
            context: this.context.context,
            stripPrefix: true,
        });
    }
    ngOnChanges(changes) {
        if (typeof window !== "undefined") {
            this.node_0_DynamicRenderer = getBlockProperties({
                block: this.block,
                context: this.context,
            });
            this.node_1_DynamicRenderer = getBlockActions({
                block: this.block,
                rootState: this.context.rootState,
                rootSetState: this.context.rootSetState,
                localState: this.context.localState,
                context: this.context.context,
                stripPrefix: true,
            });
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: BlockWrapper, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: BlockWrapper, isStandalone: true, selector: "block-wrapper", inputs: { block: "block", context: "context", Wrapper: "Wrapper" }, usesOnChanges: true, ngImport: i0, template: `
    <dynamic-renderer
      [TagName]="Wrapper"
      [attributes]="node_0_DynamicRenderer"
      [actionAttributes]="node_1_DynamicRenderer"
    >
      <ng-content></ng-content>
    </dynamic-renderer>
  `, isInline: true, styles: [":host{display:contents}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "component", type: DynamicRenderer, selector: "dynamic-renderer, DynamicRenderer", inputs: ["TagName", "attributes", "actionAttributes"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: BlockWrapper, decorators: [{
            type: Component,
            args: [{ selector: "block-wrapper", template: `
    <dynamic-renderer
      [TagName]="Wrapper"
      [attributes]="node_0_DynamicRenderer"
      [actionAttributes]="node_1_DynamicRenderer"
    >
      <ng-content></ng-content>
    </dynamic-renderer>
  `, standalone: true, imports: [CommonModule, DynamicRenderer], styles: [":host{display:contents}\n"] }]
        }], propDecorators: { block: [{
                type: Input
            }], context: [{
                type: Input
            }], Wrapper: [{
                type: Input
            }] } });

class Awaiter {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: Awaiter, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: Awaiter, isStandalone: true, selector: "awaiter", inputs: { load: "load", props: "props", attributes: "attributes", fallback: "fallback" }, ngImport: i0, template: `
    <ng-container><ng-content></ng-content></ng-container>
  `, isInline: true, styles: [":host{display:contents}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: Awaiter, decorators: [{
            type: Component,
            args: [{ selector: "awaiter", template: `
    <ng-container><ng-content></ng-content></ng-container>
  `, standalone: true, imports: [CommonModule], styles: [":host{display:contents}\n"] }]
        }], propDecorators: { load: [{
                type: Input
            }], props: [{
                type: Input
            }], attributes: [{
                type: Input
            }], fallback: [{
                type: Input
            }] } });

class InteractiveElement {
    get attributes() {
        return this.includeBlockProps
            ? {
                ...getBlockProperties({
                    block: this.block,
                    context: this.context,
                }),
                ...getBlockActions({
                    block: this.block,
                    rootState: this.context.rootState,
                    rootSetState: this.context.rootSetState,
                    localState: this.context.localState,
                    context: this.context.context,
                }),
            }
            : {};
    }
    constructor(vcRef, renderer) {
        this.vcRef = vcRef;
        this.renderer = renderer;
        this.mergedInputs_atkjh2 = {};
        this._listenerFns = new Map();
    }
    ngOnInit() {
        this.mergedInputs_atkjh2 = {
            ...this.filterPropsThatWrapperNeeds(this.wrapperProps),
            ...(this.hasAttributesInput(this.Wrapper) ? { attributes: this.attributes } : {})
        };
        this.myContent = [
            this.vcRef.createEmbeddedView(this.wrapperTemplateRef).rootNodes,
        ];
    }
    hasAttributesInput(component) {
        return !!reflectComponentType(component)?.inputs.find(input => input.propName === 'attributes');
    }
    updateAttributes(el, attributes) {
        Object.keys(attributes).forEach((attr) => {
            if (attr.startsWith("on")) {
                if (this._listenerFns.has(attr)) {
                    this._listenerFns.get(attr)();
                }
                this._listenerFns.set(attr, this.renderer.listen(el, attr.replace("on", "").toLowerCase(), attributes[attr]));
            }
            else if (attr === 'class' && attributes[attr]) {
                const classes = attributes[attr].split(' ');
                classes.forEach((cls) => this.renderer.addClass(el, cls.trim()));
            }
            else {
                this.renderer.setAttribute(el, attr.toLowerCase(), attributes[attr] ?? "");
            }
        });
    }
    ngAfterViewInit() {
        if (!this.hasAttributesInput(this.Wrapper)) {
            const wrapperElement = this.wrapperTemplateRef.elementRef.nativeElement?.nextElementSibling;
            if (wrapperElement) {
                this.updateAttributes(wrapperElement, this.attributes);
            }
        }
    }
    ngOnDestroy() {
        for (const fn of this._listenerFns.values()) {
            fn();
        }
    }
    filterPropsThatWrapperNeeds(allProps) {
        const definedPropNames = reflectComponentType(this.Wrapper).inputs.map(prop => prop.propName);
        return definedPropNames.reduce((acc, propName) => {
            acc[propName] = allProps[propName];
            return acc;
        }, {});
    }
    ngOnChanges(changes) {
        if (changes["attributes"] && !this.hasAttributesInput(this.Wrapper)) {
            this.ngAfterViewInit();
        }
        if (typeof window !== "undefined") {
            this.mergedInputs_atkjh2 = {
                ...this.filterPropsThatWrapperNeeds(this.wrapperProps),
                ...(this.hasAttributesInput(this.Wrapper) ? { attributes: this.attributes } : {})
            };
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: InteractiveElement, deps: [{ token: i0.ViewContainerRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: InteractiveElement, isStandalone: true, selector: "interactive-element", inputs: { includeBlockProps: "includeBlockProps", block: "block", context: "context", Wrapper: "Wrapper", wrapperProps: "wrapperProps" }, viewQueries: [{ propertyName: "wrapperTemplateRef", first: true, predicate: ["wrapperTemplate"], descendants: true, static: true }], usesOnChanges: true, ngImport: i0, template: `
    <ng-template #wrapperTemplate><ng-content></ng-content></ng-template>
    <ng-container *ngIf="Wrapper.load">
      <awaiter
        [load]="Wrapper.load"
        [fallback]="Wrapper.fallback"
        [props]="wrapperProps"
        [attributes]="attributes"
      >
        <ng-content></ng-content>
      </awaiter>
    </ng-container>
    <ng-container *ngIf="!(Wrapper.load)">
      <ng-container
        *ngComponentOutlet="
              Wrapper;
              inputs: mergedInputs_atkjh2;
              content: myContent;
              "
      ></ng-container>
    </ng-container>
  `, isInline: true, styles: [":host{display:contents}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgComponentOutlet, selector: "[ngComponentOutlet]", inputs: ["ngComponentOutlet", "ngComponentOutletInputs", "ngComponentOutletInjector", "ngComponentOutletContent", "ngComponentOutletNgModule", "ngComponentOutletNgModuleFactory"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: Awaiter, selector: "awaiter", inputs: ["load", "props", "attributes", "fallback"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: InteractiveElement, decorators: [{
            type: Component,
            args: [{ selector: "interactive-element", template: `
    <ng-template #wrapperTemplate><ng-content></ng-content></ng-template>
    <ng-container *ngIf="Wrapper.load">
      <awaiter
        [load]="Wrapper.load"
        [fallback]="Wrapper.fallback"
        [props]="wrapperProps"
        [attributes]="attributes"
      >
        <ng-content></ng-content>
      </awaiter>
    </ng-container>
    <ng-container *ngIf="!(Wrapper.load)">
      <ng-container
        *ngComponentOutlet="
              Wrapper;
              inputs: mergedInputs_atkjh2;
              content: myContent;
              "
      ></ng-container>
    </ng-container>
  `, standalone: true, imports: [CommonModule, Awaiter], styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.ViewContainerRef }, { type: i0.Renderer2 }]; }, propDecorators: { includeBlockProps: [{
                type: Input
            }], block: [{
                type: Input
            }], context: [{
                type: Input
            }], Wrapper: [{
                type: Input
            }], wrapperProps: [{
                type: Input
            }], wrapperTemplateRef: [{
                type: ViewChild,
                args: ["wrapperTemplate", { static: true }]
            }] } });

const getWrapperProps = ({ componentOptions, builderBlock, context, componentRef, includeBlockProps, isInteractive, contextValue }) => {
    const wrapperPropsWithAttributes = {
        ...componentOptions,
        /**
         * If `noWrap` is set to `true`, then the block's props/attributes are provided to the
         * component itself directly. Otherwise, they are provided to the wrapper element.
         */
        ...(includeBlockProps ? {
            attributes: getBlockProperties({
                block: builderBlock,
                context: contextValue
            })
        } : {})
    };
    const interactiveElementProps = {
        Wrapper: componentRef,
        block: builderBlock,
        context,
        wrapperProps: componentOptions,
        includeBlockProps
    };
    return isInteractive ? interactiveElementProps : wrapperPropsWithAttributes;
};

class ComponentRef {
    trackByChild0(_, child) {
        return child.id;
    }
    constructor(vcRef) {
        this.vcRef = vcRef;
        this.Wrapper = null;
        this.node_0_state_Wrapper = null;
        this.mergedInputs_v6przu = {};
    }
    ngOnInit() {
        this.Wrapper = this.isInteractive ? InteractiveElement : this.componentRef;
        this.node_0_state_Wrapper = {
            ...getWrapperProps({
                componentOptions: this.componentOptions,
                builderBlock: this.builderBlock,
                context: this.context,
                componentRef: this.componentRef,
                linkComponent: this.linkComponent,
                includeBlockProps: this.includeBlockProps,
                isInteractive: this.isInteractive,
                contextValue: this.context,
            }),
        };
        this.mergedInputs_v6przu = { ...this.node_0_state_Wrapper };
        const wrapperTemplate = this.vcRef.createEmbeddedView(this.wrapperTemplateRef);
        wrapperTemplate.detectChanges();
        this.myContent = [wrapperTemplate.rootNodes];
    }
    ngOnChanges(changes) {
        if (changes.componentOptions) {
            let foundChange = false;
            for (const key in changes.componentOptions.previousValue) {
                if (changes.componentOptions.previousValue[key] !== changes.componentOptions.currentValue[key]) {
                    foundChange = true;
                    break;
                }
            }
            if (!foundChange) {
                return;
            }
        }
        if (typeof window !== "undefined") {
            this.node_0_state_Wrapper = {
                ...getWrapperProps({
                    componentOptions: this.componentOptions,
                    builderBlock: this.builderBlock,
                    context: this.context,
                    componentRef: this.componentRef,
                    linkComponent: this.linkComponent,
                    includeBlockProps: this.includeBlockProps,
                    isInteractive: this.isInteractive,
                    contextValue: this.context,
                }),
            };
            this.mergedInputs_v6przu = { ...this.node_0_state_Wrapper };
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ComponentRef, deps: [{ token: i0.ViewContainerRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: ComponentRef, isStandalone: true, selector: "component-ref", inputs: { componentOptions: "componentOptions", builderBlock: "builderBlock", context: "context", componentRef: "componentRef", linkComponent: "linkComponent", includeBlockProps: "includeBlockProps", isInteractive: "isInteractive", blockChildren: "blockChildren", registeredComponents: "registeredComponents" }, viewQueries: [{ propertyName: "wrapperTemplateRef", first: true, predicate: ["wrapperTemplate"], descendants: true, static: true }], usesOnChanges: true, ngImport: i0, template: `
    <ng-template #wrapperTemplate>
      <ng-container *ngIf="componentRef">
<ng-container *ngFor="let child of blockChildren; trackBy: trackByChild0">
        <block
          [block]="child"
          [context]="context"
          [registeredComponents]="registeredComponents"
          [linkComponent]="linkComponent"
        ></block>
      </ng-container>
</ng-container>
    </ng-template>
    <ng-container *ngIf="componentRef">
      <ng-container
        *ngComponentOutlet="
              Wrapper;
              inputs: mergedInputs_v6przu;
              content: myContent;
              "
      ></ng-container>
    </ng-container>
  `, isInline: true, styles: [":host{display:contents}\n"], dependencies: [{ kind: "ngmodule", type: i0.forwardRef(function () { return CommonModule; }) }, { kind: "directive", type: i0.forwardRef(function () { return i1.NgComponentOutlet; }), selector: "[ngComponentOutlet]", inputs: ["ngComponentOutlet", "ngComponentOutletInputs", "ngComponentOutletInjector", "ngComponentOutletContent", "ngComponentOutletNgModule", "ngComponentOutletNgModuleFactory"] }, { kind: "directive", type: i0.forwardRef(function () { return i1.NgForOf; }), selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i0.forwardRef(function () { return i1.NgIf; }), selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i0.forwardRef(function () { return Block; }), selector: "block", inputs: ["block", "context", "registeredComponents", "linkComponent"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ComponentRef, decorators: [{
            type: Component,
            args: [{ selector: "component-ref", template: `
    <ng-template #wrapperTemplate>
      <ng-container *ngIf="componentRef">
<ng-container *ngFor="let child of blockChildren; trackBy: trackByChild0">
        <block
          [block]="child"
          [context]="context"
          [registeredComponents]="registeredComponents"
          [linkComponent]="linkComponent"
        ></block>
      </ng-container>
</ng-container>
    </ng-template>
    <ng-container *ngIf="componentRef">
      <ng-container
        *ngComponentOutlet="
              Wrapper;
              inputs: mergedInputs_v6przu;
              content: myContent;
              "
      ></ng-container>
    </ng-container>
  `, standalone: true, imports: [CommonModule, forwardRef(() => Block)], styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.ViewContainerRef }]; }, propDecorators: { componentOptions: [{
                type: Input
            }], builderBlock: [{
                type: Input
            }], context: [{
                type: Input
            }], componentRef: [{
                type: Input
            }], linkComponent: [{
                type: Input
            }], includeBlockProps: [{
                type: Input
            }], isInteractive: [{
                type: Input
            }], blockChildren: [{
                type: Input
            }], registeredComponents: [{
                type: Input
            }], wrapperTemplateRef: [{
                type: ViewChild,
                args: ["wrapperTemplate", { static: true }]
            }] } });

class RepeatedBlock {
    constructor() {
        this.store = null;
    }
    ngOnInit() {
        this.store = this.repeatContext;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: RepeatedBlock, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: RepeatedBlock, isStandalone: true, selector: "repeated-block", inputs: { repeatContext: "repeatContext", block: "block", registeredComponents: "registeredComponents", linkComponent: "linkComponent" }, ngImport: i0, template: `
    <block
      [block]="block"
      [context]="store"
      [registeredComponents]="registeredComponents"
      [linkComponent]="linkComponent"
    ></block>
  `, isInline: true, styles: [":host{display:contents}\n"], dependencies: [{ kind: "ngmodule", type: i0.forwardRef(function () { return CommonModule; }) }, { kind: "component", type: i0.forwardRef(function () { return Block; }), selector: "block", inputs: ["block", "context", "registeredComponents", "linkComponent"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: RepeatedBlock, decorators: [{
            type: Component,
            args: [{ selector: "repeated-block", template: `
    <block
      [block]="block"
      [context]="store"
      [registeredComponents]="registeredComponents"
      [linkComponent]="linkComponent"
    ></block>
  `, standalone: true, imports: [CommonModule, forwardRef(() => Block)], styles: [":host{display:contents}\n"] }]
        }], propDecorators: { repeatContext: [{
                type: Input
            }], block: [{
                type: Input
            }], registeredComponents: [{
                type: Input
            }], linkComponent: [{
                type: Input
            }] } });

class Block {
    constructor() {
        this._processedBlock = {
            value: null,
            update: false,
        };
    }
    get repeatItem() {
        return getRepeatItemData({
            block: this.block,
            context: this.context,
        });
    }
    get processedBlock() {
        const blockToUse = this.block.repeat?.collection
            ? this.block
            : getProcessedBlock({
                block: this.block,
                localState: this.context.localState,
                rootState: this.context.rootState,
                rootSetState: this.context.rootSetState,
                context: this.context.context,
            });
        return blockToUse;
    }
    get blockComponent() {
        return getComponent({
            block: this.processedBlock,
            registeredComponents: this.registeredComponents,
            model: this.context.model,
        });
    }
    get Tag() {
        const shouldUseLink = this.block.tagName === "a" ||
            this.processedBlock.properties?.href ||
            this.processedBlock.href;
        if (shouldUseLink) {
            return this.linkComponent || "a";
        }
        return DynamicDiv;
    }
    get canShowBlock() {
        if (this.block.repeat?.collection) {
            if (this.repeatItem?.length)
                return true;
            return false;
        }
        const shouldHide = "hide" in this.processedBlock ? this.processedBlock.hide : false;
        const shouldShow = "show" in this.processedBlock ? this.processedBlock.show : true;
        return shouldShow && !shouldHide;
    }
    get childrenWithoutParentComponent() {
        /**
         * When there is no `componentRef`, there might still be children that need to be rendered. In this case,
         * we render them outside of `componentRef`.
         * NOTE: We make sure not to render this if `repeatItemData` is non-null, because that means we are rendering an array of
         * blocks, and the children will be repeated within those blocks.
         */
        const shouldRenderChildrenOutsideRef = !this.blockComponent?.component && !this.repeatItem;
        return shouldRenderChildrenOutsideRef
            ? this.processedBlock.children ?? []
            : [];
    }
    get componentRefProps() {
        return {
            blockChildren: this.processedBlock.children ?? [],
            componentRef: this.blockComponent?.component,
            componentOptions: {
                ...getBlockComponentOptions(this.processedBlock, this.context),
                ...provideBuilderBlock(this.blockComponent, this.processedBlock),
                ...provideBuilderContext(this.blockComponent, this.context),
                ...provideLinkComponent(this.blockComponent, this.linkComponent),
                ...provideRegisteredComponents(this.blockComponent, this.registeredComponents, this.context.model),
            },
            context: this.context,
            linkComponent: this.linkComponent,
            registeredComponents: this.registeredComponents,
            builderBlock: this.processedBlock,
            includeBlockProps: this.blockComponent?.noWrap === true,
            isInteractive: !(this.blockComponent?.isRSC && TARGET === "rsc"),
        };
    }
    trackByChild0(_, child) {
        return child.id;
    }
    trackByData1(index, data) {
        return index;
    }
    trackByData2(index, data) {
        return index;
    }
    ngOnInit() {
        if (typeof window !== "undefined") {
            const blockId = this.processedBlock.id;
            const animations = this.processedBlock.animations;
            if (animations && blockId) {
                // in Angular, the DynamicDiv sets attributes (builder-id) on the element late (ngAfterViewInit)
                // so we need to wait for them to be attached to the DOM before calling this else we'll not find the element
                requestAnimationFrame(() => {
                    bindAnimations(animations.map((animation) => ({
                        ...animation,
                        elementId: blockId,
                    })));
                });
            }
        }
    }
    ngOnChanges(changes) {
        if (typeof window !== "undefined") {
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: Block, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: Block, isStandalone: true, selector: "block", inputs: { block: "block", context: "context", registeredComponents: "registeredComponents", linkComponent: "linkComponent" }, usesOnChanges: true, ngImport: i0, template: `
    <ng-container *ngIf="canShowBlock">
      <block-styles [block]="processedBlock" [context]="context"></block-styles>
      <ng-container *ngIf="!blockComponent?.noWrap">
        <ng-container *ngIf="!repeatItem">
          <block-wrapper
            [Wrapper]="Tag"
            [block]="processedBlock"
            [context]="context"
          >
            <component-ref
              [componentRef]="componentRefProps.componentRef"
              [componentOptions]="componentRefProps.componentOptions"
              [blockChildren]="componentRefProps.blockChildren"
              [context]="componentRefProps.context"
              [registeredComponents]="componentRefProps.registeredComponents"
              [linkComponent]="componentRefProps.linkComponent"
              [builderBlock]="componentRefProps.builderBlock"
              [includeBlockProps]="componentRefProps.includeBlockProps"
              [isInteractive]="componentRefProps.isInteractive"
            ></component-ref>
            <ng-container
              *ngFor="let child of childrenWithoutParentComponent; trackBy: trackByChild0"
            >
              <block
                [block]="child"
                [registeredComponents]="registeredComponents"
                [linkComponent]="linkComponent"
                [context]="context"
              ></block>
            </ng-container>
          </block-wrapper>
        </ng-container>
        <ng-container *ngIf="!(!repeatItem)">
          <ng-container
            *ngFor="let data of repeatItem; index as index; trackBy: trackByData1"
          >
            <repeated-block
              [repeatContext]="data.context"
              [block]="data.block"
              [registeredComponents]="registeredComponents"
              [linkComponent]="linkComponent"
            ></repeated-block>
          </ng-container>
        </ng-container>
      </ng-container>
      <ng-container *ngIf="!(!blockComponent?.noWrap)">
        <ng-container *ngIf="!repeatItem">
          <component-ref
            [componentRef]="componentRefProps.componentRef"
            [componentOptions]="componentRefProps.componentOptions"
            [blockChildren]="componentRefProps.blockChildren"
            [context]="componentRefProps.context"
            [registeredComponents]="componentRefProps.registeredComponents"
            [linkComponent]="componentRefProps.linkComponent"
            [builderBlock]="componentRefProps.builderBlock"
            [includeBlockProps]="componentRefProps.includeBlockProps"
            [isInteractive]="componentRefProps.isInteractive"
          ></component-ref>
        </ng-container>
        <ng-container *ngIf="!(!repeatItem)">
          <ng-container
            *ngFor="let data of repeatItem; index as index; trackBy: trackByData2"
          >
            <repeated-block
              [repeatContext]="data.context"
              [block]="data.block"
              [registeredComponents]="registeredComponents"
              [linkComponent]="linkComponent"
            ></repeated-block>
          </ng-container>
        </ng-container>
      </ng-container>
    </ng-container>
  `, isInline: true, styles: [":host{display:contents}\n"], dependencies: [{ kind: "component", type: Block, selector: "block", inputs: ["block", "context", "registeredComponents", "linkComponent"] }, { kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: BlockStyles, selector: "block-styles", inputs: ["block", "context"] }, { kind: "component", type: RepeatedBlock, selector: "repeated-block", inputs: ["repeatContext", "block", "registeredComponents", "linkComponent"] }, { kind: "component", type: ComponentRef, selector: "component-ref", inputs: ["componentOptions", "builderBlock", "context", "componentRef", "linkComponent", "includeBlockProps", "isInteractive", "blockChildren", "registeredComponents"] }, { kind: "component", type: BlockWrapper, selector: "block-wrapper", inputs: ["block", "context", "Wrapper"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: Block, decorators: [{
            type: Component,
            args: [{ selector: "block", template: `
    <ng-container *ngIf="canShowBlock">
      <block-styles [block]="processedBlock" [context]="context"></block-styles>
      <ng-container *ngIf="!blockComponent?.noWrap">
        <ng-container *ngIf="!repeatItem">
          <block-wrapper
            [Wrapper]="Tag"
            [block]="processedBlock"
            [context]="context"
          >
            <component-ref
              [componentRef]="componentRefProps.componentRef"
              [componentOptions]="componentRefProps.componentOptions"
              [blockChildren]="componentRefProps.blockChildren"
              [context]="componentRefProps.context"
              [registeredComponents]="componentRefProps.registeredComponents"
              [linkComponent]="componentRefProps.linkComponent"
              [builderBlock]="componentRefProps.builderBlock"
              [includeBlockProps]="componentRefProps.includeBlockProps"
              [isInteractive]="componentRefProps.isInteractive"
            ></component-ref>
            <ng-container
              *ngFor="let child of childrenWithoutParentComponent; trackBy: trackByChild0"
            >
              <block
                [block]="child"
                [registeredComponents]="registeredComponents"
                [linkComponent]="linkComponent"
                [context]="context"
              ></block>
            </ng-container>
          </block-wrapper>
        </ng-container>
        <ng-container *ngIf="!(!repeatItem)">
          <ng-container
            *ngFor="let data of repeatItem; index as index; trackBy: trackByData1"
          >
            <repeated-block
              [repeatContext]="data.context"
              [block]="data.block"
              [registeredComponents]="registeredComponents"
              [linkComponent]="linkComponent"
            ></repeated-block>
          </ng-container>
        </ng-container>
      </ng-container>
      <ng-container *ngIf="!(!blockComponent?.noWrap)">
        <ng-container *ngIf="!repeatItem">
          <component-ref
            [componentRef]="componentRefProps.componentRef"
            [componentOptions]="componentRefProps.componentOptions"
            [blockChildren]="componentRefProps.blockChildren"
            [context]="componentRefProps.context"
            [registeredComponents]="componentRefProps.registeredComponents"
            [linkComponent]="componentRefProps.linkComponent"
            [builderBlock]="componentRefProps.builderBlock"
            [includeBlockProps]="componentRefProps.includeBlockProps"
            [isInteractive]="componentRefProps.isInteractive"
          ></component-ref>
        </ng-container>
        <ng-container *ngIf="!(!repeatItem)">
          <ng-container
            *ngFor="let data of repeatItem; index as index; trackBy: trackByData2"
          >
            <repeated-block
              [repeatContext]="data.context"
              [block]="data.block"
              [registeredComponents]="registeredComponents"
              [linkComponent]="linkComponent"
            ></repeated-block>
          </ng-container>
        </ng-container>
      </ng-container>
    </ng-container>
  `, standalone: true, imports: [
                        CommonModule,
                        BlockStyles,
                        RepeatedBlock,
                        ComponentRef,
                        BlockWrapper,
                        Block,
                    ], styles: [":host{display:contents}\n"] }]
        }], propDecorators: { block: [{
                type: Input
            }], context: [{
                type: Input
            }], registeredComponents: [{
                type: Input
            }], linkComponent: [{
                type: Input
            }] } });

class BlocksWrapper {
    get className() {
        return [
            "builder-blocks",
            !this.blocks?.length ? "no-blocks" : "",
            this.classNameProp,
        ]
            .filter(Boolean)
            .join(" ");
    }
    get dataPath() {
        if (!this.path) {
            return undefined;
        }
        const thisPrefix = "this.";
        const pathPrefix = "component.options.";
        return this.path.startsWith(thisPrefix)
            ? this.path.replace(thisPrefix, "")
            : this.path.startsWith(pathPrefix)
                ? this.path
                : `${pathPrefix}${this.path || ""}`;
    }
    onClick() {
        if (isEditing() && !this.blocks?.length) {
            window.parent?.postMessage({
                type: "builder.clickEmptyBlocks",
                data: {
                    parentElementId: this.parent,
                    dataPath: this.dataPath,
                },
            }, "*");
        }
    }
    onMouseEnter() {
        if (isEditing() && !this.blocks?.length) {
            window.parent?.postMessage({
                type: "builder.hoverEmptyBlocks",
                data: {
                    parentElementId: this.parent,
                    dataPath: this.dataPath,
                },
            }, "*");
        }
    }
    constructor(vcRef) {
        this.vcRef = vcRef;
        this.mergedInputs_2eim3t = {};
    }
    ngAfterContentInit() {
        this.mergedInputs_2eim3t = {
            ref: this.blocksWrapperRef,
            class: this.className + " props-blocks-wrapper",
            "builder-path": this.dataPath,
            "builder-parent-id": this.parent,
            style: this.styleProp,
            onClick: this.onClick.bind(this),
            onMouseEnter: this.onMouseEnter.bind(this),
            onKeyPress: this.onClick.bind(this),
            ...this.BlocksWrapperProps,
        };
        if (typeof window !== "undefined") {
        }
        this.myContent = [
            this.vcRef.createEmbeddedView(this.blockswrapperTemplateRef).rootNodes,
        ];
    }
    ngOnChanges(changes) {
        if (typeof window !== "undefined") {
            this.mergedInputs_2eim3t = {
                ref: this.blocksWrapperRef,
                class: this.className + " props-blocks-wrapper",
                "builder-path": this.dataPath,
                "builder-parent-id": this.parent,
                style: this.styleProp,
                onClick: this.onClick.bind(this),
                onMouseEnter: this.onMouseEnter.bind(this),
                onKeyPress: this.onClick.bind(this),
                ...this.BlocksWrapperProps,
            };
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: BlocksWrapper, deps: [{ token: i0.ViewContainerRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: BlocksWrapper, isStandalone: true, selector: "blocks-wrapper", inputs: { blocks: "blocks", classNameProp: "classNameProp", path: "path", parent: "parent", styleProp: "styleProp", BlocksWrapperProps: "BlocksWrapperProps", BlocksWrapper: "BlocksWrapper" }, viewQueries: [{ propertyName: "blocksWrapperRef", first: true, predicate: ["blocksWrapperRef"], descendants: true }, { propertyName: "blockswrapperTemplateRef", first: true, predicate: ["blockswrapperTemplate"], descendants: true, static: true }], usesOnChanges: true, ngImport: i0, template: `
    <ng-template #blockswrapperTemplate><ng-content></ng-content></ng-template>
    <ng-container
      *ngComponentOutlet="
              BlocksWrapper;
              inputs: mergedInputs_2eim3t;
              content: myContent;
              "
    ></ng-container>
  `, isInline: true, styles: [":host{display:contents}.props-blocks-wrapper{display:flex;flex-direction:column;align-items:stretch}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgComponentOutlet, selector: "[ngComponentOutlet]", inputs: ["ngComponentOutlet", "ngComponentOutletInputs", "ngComponentOutletInjector", "ngComponentOutletContent", "ngComponentOutletNgModule", "ngComponentOutletNgModuleFactory"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: BlocksWrapper, decorators: [{
            type: Component,
            args: [{ selector: "blocks-wrapper", template: `
    <ng-template #blockswrapperTemplate><ng-content></ng-content></ng-template>
    <ng-container
      *ngComponentOutlet="
              BlocksWrapper;
              inputs: mergedInputs_2eim3t;
              content: myContent;
              "
    ></ng-container>
  `, standalone: true, imports: [CommonModule], styles: [":host{display:contents}.props-blocks-wrapper{display:flex;flex-direction:column;align-items:stretch}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.ViewContainerRef }]; }, propDecorators: { blocks: [{
                type: Input
            }], classNameProp: [{
                type: Input
            }], path: [{
                type: Input
            }], parent: [{
                type: Input
            }], styleProp: [{
                type: Input
            }], BlocksWrapperProps: [{
                type: Input
            }], BlocksWrapper: [{
                type: Input
            }], blocksWrapperRef: [{
                type: ViewChild,
                args: ["blocksWrapperRef"]
            }], blockswrapperTemplateRef: [{
                type: ViewChild,
                args: ["blockswrapperTemplate", { static: true }]
            }] } });

class Blocks {
    trackByBlock0(_, block) {
        return block.id;
    }
    constructor(builderContext, componentsContext) {
        this.builderContext = builderContext;
        this.componentsContext = componentsContext;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: Blocks, deps: [{ token: BuilderContext }, { token: ComponentsContext }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: Blocks, isStandalone: true, selector: "blocks", inputs: { blocks: "blocks", parent: "parent", path: "path", styleProp: "styleProp", className: "className", context: "context", linkComponent: "linkComponent", registeredComponents: "registeredComponents" }, ngImport: i0, template: `
    <blocks-wrapper
      [blocks]="blocks"
      [parent]="parent"
      [path]="path"
      [styleProp]="styleProp"
      [classNameProp]="className"
      [BlocksWrapper]="context?.BlocksWrapper || builderContext?.BlocksWrapper"
      [BlocksWrapperProps]="context?.BlocksWrapperProps || builderContext?.BlocksWrapperProps"
    >
      <ng-container *ngIf="blocks">
        <ng-container *ngFor="let block of blocks; trackBy: trackByBlock0">
          <block
            [block]="block"
            [linkComponent]="linkComponent"
            [context]="context || builderContext"
            [registeredComponents]="registeredComponents || componentsContext?.registeredComponents"
          ></block>
        </ng-container>
      </ng-container>
    </blocks-wrapper>
  `, isInline: true, styles: [":host{display:contents}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: BlocksWrapper, selector: "blocks-wrapper", inputs: ["blocks", "classNameProp", "path", "parent", "styleProp", "BlocksWrapperProps", "BlocksWrapper"] }, { kind: "component", type: Block, selector: "block", inputs: ["block", "context", "registeredComponents", "linkComponent"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: Blocks, decorators: [{
            type: Component,
            args: [{ selector: "blocks", template: `
    <blocks-wrapper
      [blocks]="blocks"
      [parent]="parent"
      [path]="path"
      [styleProp]="styleProp"
      [classNameProp]="className"
      [BlocksWrapper]="context?.BlocksWrapper || builderContext?.BlocksWrapper"
      [BlocksWrapperProps]="context?.BlocksWrapperProps || builderContext?.BlocksWrapperProps"
    >
      <ng-container *ngIf="blocks">
        <ng-container *ngFor="let block of blocks; trackBy: trackByBlock0">
          <block
            [block]="block"
            [linkComponent]="linkComponent"
            [context]="context || builderContext"
            [registeredComponents]="registeredComponents || componentsContext?.registeredComponents"
          ></block>
        </ng-container>
      </ng-container>
    </blocks-wrapper>
  `, standalone: true, imports: [CommonModule, BlocksWrapper, Block], styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: BuilderContext }, { type: ComponentsContext }]; }, propDecorators: { blocks: [{
                type: Input
            }], parent: [{
                type: Input
            }], path: [{
                type: Input
            }], styleProp: [{
                type: Input
            }], className: [{
                type: Input
            }], context: [{
                type: Input
            }], linkComponent: [{
                type: Input
            }], registeredComponents: [{
                type: Input
            }] } });

const getColumnsClass = (id) => {
    return `builder-columns ${id}-breakpoints`;
};

class Columns {
    get gutterSize() {
        return typeof this.space === "number" ? this.space || 0 : 20;
    }
    get cols() {
        return this.columns || [];
    }
    get stackAt() {
        return this.stackColumnsAt || "tablet";
    }
    getTagName(column) {
        return column.link ? this.builderLinkComponent || "a" : DynamicDiv;
    }
    getWidth(index) {
        return this.cols[index]?.width || 100 / this.cols.length;
    }
    getColumnCssWidth(index) {
        const width = this.getWidth(index);
        const subtractWidth = this.gutterSize * (this.cols.length - 1) * (width / 100);
        return `calc(${width}% - ${subtractWidth}px)`;
    }
    getTabletStyle({ stackedStyle, desktopStyle, }) {
        return this.stackAt === "tablet" ? stackedStyle : desktopStyle;
    }
    getMobileStyle({ stackedStyle, desktopStyle, }) {
        return this.stackAt === "never" ? desktopStyle : stackedStyle;
    }
    get flexDir() {
        return this.stackColumnsAt === "never"
            ? "row"
            : this.reverseColumnsWhenStacked
                ? "column-reverse"
                : "column";
    }
    columnsCssVars() {
        return {
            "--flex-dir": this.flexDir,
            "--flex-dir-tablet": this.getTabletStyle({
                stackedStyle: this.flexDir,
                desktopStyle: "row",
            }),
        };
    }
    columnCssVars(index) {
        const gutter = index === 0 ? 0 : this.gutterSize;
        const width = this.getColumnCssWidth(index);
        const gutterPixels = `${gutter}px`;
        const mobileWidth = "100%";
        const mobileMarginLeft = 0;
        const marginLeftKey = "margin-left";
        const sharedStyles = {
            display: "flex",
            flexDirection: "column",
            alignItems: "stretch",
        };
        return {
            ...sharedStyles,
            width,
            [marginLeftKey]: gutterPixels,
            "--column-width-mobile": this.getMobileStyle({
                stackedStyle: mobileWidth,
                desktopStyle: width,
            }),
            "--column-margin-left-mobile": this.getMobileStyle({
                stackedStyle: mobileMarginLeft,
                desktopStyle: gutterPixels,
            }),
            "--column-width-tablet": this.getTabletStyle({
                stackedStyle: mobileWidth,
                desktopStyle: width,
            }),
            "--column-margin-left-tablet": this.getTabletStyle({
                stackedStyle: mobileMarginLeft,
                desktopStyle: gutterPixels,
            }),
        };
    }
    getWidthForBreakpointSize(size) {
        const breakpointSizes = getSizesForBreakpoints(this.builderContext.content?.meta?.breakpoints || {});
        return breakpointSizes[size].max;
    }
    columnsStyles() {
        const childColumnDiv = `.${this.builderBlock.id}-breakpoints .builder-column:first-of-type`;
        return `
        @media (max-width: ${this.getWidthForBreakpointSize("medium")}px) {
          .${this.builderBlock.id}-breakpoints {
            flex-direction: var(--flex-dir-tablet);
            align-items: stretch;
          }

          ${childColumnDiv} {
            width: var(--column-width-tablet) !important;
            margin-left: var(--column-margin-left-tablet) !important;
          }
        }

        @media (max-width: ${this.getWidthForBreakpointSize("small")}px) {
          .${this.builderBlock.id}-breakpoints {
            flex-direction: var(--flex-dir);
            align-items: stretch;
          }

          ${childColumnDiv} {
            width: var(--column-width-mobile) !important;
            margin-left: var(--column-margin-left-mobile) !important;
          }
        },
      `;
    }
    getAttributes(column, index) {
        return {
            ...{},
            ...(column.link
                ? {
                    href: column.link,
                }
                : {}),
            [getClassPropName()]: "builder-column",
            style: mapStyleObjToStrIfNeeded(this.columnCssVars(index)),
        };
    }
    setAttributes(el, value, changes) {
        if (!el) {
            return;
        }
        const target = typeof changes === "undefined" ? value : changes;
        Object.keys(target).forEach((key) => {
            if (key.startsWith("on")) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace("on", "").toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key.toLowerCase(), target[key] ?? "");
            }
        });
    }
    trackByColumn0(index, column) {
        return index;
    }
    constructor(renderer) {
        this.renderer = renderer;
        this.TARGET = TARGET;
        this._listenerFns = new Map();
        this.node_0_div = null;
        this.node_1_div = null;
        this.node_2_InlinedStyles = null;
        this.node_3_DynamicRenderer = (column, index) => this.getTagName(column);
        this.node_4_DynamicRenderer = (column, index) => ({});
        this.node_5_DynamicRenderer = (column, index) => this.getAttributes(column, index);
        this.node_6_Blocks = (column, index) => `columns.${index}.blocks`;
        this.node_7_Blocks = (column, index) => ({
            flexGrow: "1",
        });
        this.elRef0_state_0 = null;
    }
    ngOnInit() {
        this.node_0_div = getColumnsClass(this.builderBlock?.id);
        this.node_1_div = this.columnsCssVars();
        this.node_2_InlinedStyles = this.columnsStyles();
        this.elRef0_state_0 = {};
    }
    ngAfterViewInit() {
        this.setAttributes(this.elRef0?.nativeElement, this.elRef0_state_0);
    }
    ngOnChanges(changes) {
        if (typeof window !== "undefined") {
            this.node_0_div = getColumnsClass(this.builderBlock?.id);
            this.node_1_div = this.columnsCssVars();
            this.node_2_InlinedStyles = this.columnsStyles();
            this.elRef0_state_0 = {};
            this.setAttributes(this.elRef0?.nativeElement, this.elRef0_state_0, changes["elRef0_state_0"]?.currentValue);
        }
    }
    ngOnDestroy() {
        for (const fn of this._listenerFns.values()) {
            fn();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: Columns, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: Columns, isStandalone: true, selector: "columns", inputs: { builderBlock: "builderBlock", space: "space", columns: "columns", stackColumnsAt: "stackColumnsAt", builderLinkComponent: "builderLinkComponent", reverseColumnsWhenStacked: "reverseColumnsWhenStacked", builderContext: "builderContext", builderComponents: "builderComponents" }, viewQueries: [{ propertyName: "elRef0", first: true, predicate: ["elRef0"], descendants: true }], usesOnChanges: true, ngImport: i0, template: `
    <div [class]="node_0_div + ' div'" [ngStyle]="node_1_div" #elRef0>
      <ng-container *ngIf="TARGET !== 'reactNative'">
        <inlined-styles
          id="builderio-columns"
          [styles]="node_2_InlinedStyles"
          [nonce]="builderContext.nonce"
        ></inlined-styles>
      </ng-container>
      <ng-container
        *ngFor="let column of columns; index as index; trackBy: trackByColumn0"
      >
        <dynamic-renderer
          [TagName]="node_3_DynamicRenderer(column, index)"
          [actionAttributes]="node_4_DynamicRenderer(column, index)"
          [attributes]="node_5_DynamicRenderer(column, index)"
        >
          <blocks
            [path]="node_6_Blocks(column, index)"
            [parent]="builderBlock.id"
            [context]="builderContext"
            [registeredComponents]="builderComponents"
            [linkComponent]="builderLinkComponent"
            [blocks]="column.blocks"
            [styleProp]="node_7_Blocks(column, index)"
          ></blocks>
        </dynamic-renderer>
      </ng-container>
    </div>
  `, isInline: true, styles: [":host{display:contents}.div{display:flex;line-height:normal}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "component", type: InlinedStyles, selector: "inlined-styles, InlinedStyles", inputs: ["styles", "id", "nonce"] }, { kind: "component", type: DynamicRenderer, selector: "dynamic-renderer, DynamicRenderer", inputs: ["TagName", "attributes", "actionAttributes"] }, { kind: "component", type: Blocks, selector: "blocks", inputs: ["blocks", "parent", "path", "styleProp", "className", "context", "linkComponent", "registeredComponents"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: Columns, decorators: [{
            type: Component,
            args: [{ selector: "columns", template: `
    <div [class]="node_0_div + ' div'" [ngStyle]="node_1_div" #elRef0>
      <ng-container *ngIf="TARGET !== 'reactNative'">
        <inlined-styles
          id="builderio-columns"
          [styles]="node_2_InlinedStyles"
          [nonce]="builderContext.nonce"
        ></inlined-styles>
      </ng-container>
      <ng-container
        *ngFor="let column of columns; index as index; trackBy: trackByColumn0"
      >
        <dynamic-renderer
          [TagName]="node_3_DynamicRenderer(column, index)"
          [actionAttributes]="node_4_DynamicRenderer(column, index)"
          [attributes]="node_5_DynamicRenderer(column, index)"
        >
          <blocks
            [path]="node_6_Blocks(column, index)"
            [parent]="builderBlock.id"
            [context]="builderContext"
            [registeredComponents]="builderComponents"
            [linkComponent]="builderLinkComponent"
            [blocks]="column.blocks"
            [styleProp]="node_7_Blocks(column, index)"
          ></blocks>
        </dynamic-renderer>
      </ng-container>
    </div>
  `, standalone: true, imports: [CommonModule, InlinedStyles, DynamicRenderer, Blocks], styles: [":host{display:contents}.div{display:flex;line-height:normal}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { builderBlock: [{
                type: Input
            }], space: [{
                type: Input
            }], columns: [{
                type: Input
            }], stackColumnsAt: [{
                type: Input
            }], builderLinkComponent: [{
                type: Input
            }], reverseColumnsWhenStacked: [{
                type: Input
            }], builderContext: [{
                type: Input
            }], builderComponents: [{
                type: Input
            }], elRef0: [{
                type: ViewChild,
                args: ["elRef0"]
            }] } });

class FragmentComponent {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FragmentComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: FragmentComponent, isStandalone: true, selector: "fragment-component", ngImport: i0, template: `
    <span><ng-content></ng-content></span>
  `, isInline: true, styles: [":host{display:contents}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FragmentComponent, decorators: [{
            type: Component,
            args: [{ selector: "fragment-component", template: `
    <span><ng-content></ng-content></span>
  `, standalone: true, imports: [CommonModule], styles: [":host{display:contents}\n"] }]
        }] });

// Taken from (and modified) the shopify theme script repo
// https://github.com/Shopify/theme-scripts/blob/bcfb471f2a57d439e2f964a1bb65b67708cc90c3/packages/theme-images/images.js#L59
function removeProtocol(path) {
    return path.replace(/http(s)?:/, '');
}
function updateQueryParam(uri = '', key, value) {
    const re = new RegExp('([?&])' + key + '=.*?(&|$)', 'i');
    const separator = uri.indexOf('?') !== -1 ? '&' : '?';
    if (uri.match(re)) {
        return uri.replace(re, '$1' + key + '=' + encodeURIComponent(value) + '$2');
    }
    return uri + separator + key + '=' + encodeURIComponent(value);
}
function getShopifyImageUrl(src, size) {
    if (!src || !src?.match(/cdn\.shopify\.com/) || !size) {
        return src;
    }
    if (size === 'master') {
        return removeProtocol(src);
    }
    const match = src.match(/(_\d+x(\d+)?)?(\.(jpg|jpeg|gif|png|bmp|bitmap|tiff|tif)(\?v=\d+)?)/i);
    if (match) {
        const prefix = src.split(match[0]);
        const suffix = match[3];
        const useSize = size.match('x') ? size : `${size}x`;
        return removeProtocol(`${prefix[0]}_${useSize}${suffix}`);
    }
    return null;
}
function getSrcSet(url) {
    if (!url) {
        return url;
    }
    const sizes = [100, 200, 400, 800, 1200, 1600, 2000];
    if (url.match(/builder\.io/)) {
        let srcUrl = url;
        const widthInSrc = Number(url.split('?width=')[1]);
        if (!isNaN(widthInSrc)) {
            srcUrl = `${srcUrl} ${widthInSrc}w`;
        }
        return sizes.filter(size => size !== widthInSrc).map(size => `${updateQueryParam(url, 'width', size)} ${size}w`).concat([srcUrl]).join(', ');
    }
    if (url.match(/cdn\.shopify\.com/)) {
        return sizes.map(size => [getShopifyImageUrl(url, `${size}x${size}`), size]).filter(([sizeUrl]) => !!sizeUrl).map(([sizeUrl, size]) => `${sizeUrl} ${size}w`).concat([url]).join(', ');
    }
    return url;
}

class BuilderImage {
    constructor() {
        this.node_0_img = null;
        this.node_1_img = null;
        this.node_2_Show = null;
        this.node_3_div = null;
    }
    get srcSetToUse() {
        const imageToUse = this.image || this.src;
        const url = imageToUse;
        if (!url ||
            // We can auto add srcset for cdn.builder.io and shopify
            // images, otherwise you can supply this prop manually
            !(typeof url === "string" &&
                (url.match(/builder\.io/) || url.match(/cdn\.shopify\.com/)))) {
            return this.srcset;
        }
        if (this.noWebp) {
            return undefined; // no need to add srcset to svg images
        }
        if (this.srcset && this.image?.includes("builder.io/api/v1/image")) {
            if (!this.srcset.includes(this.image.split("?")[0])) {
                console.debug("Removed given srcset");
                return getSrcSet(url);
            }
        }
        else if (this.image && !this.srcset) {
            return getSrcSet(url);
        }
        return getSrcSet(url);
    }
    get webpSrcSet() {
        if (this.srcSetToUse?.match(/builder\.io/) && !this.noWebp) {
            return this.srcSetToUse.replace(/\?/g, "?format=webp&");
        }
        else {
            return "";
        }
    }
    get aspectRatioCss() {
        const aspectRatioStyles = {
            position: "absolute",
            height: "100%",
            width: "100%",
            left: "0px",
            top: "0px",
        };
        const out = this.aspectRatio ? aspectRatioStyles : undefined;
        return out;
    }
    ngOnInit() {
        this.node_0_img = {
            objectPosition: this.backgroundPosition || "center",
            objectFit: this.backgroundSize || "cover",
            ...this.aspectRatioCss,
        };
        this.node_1_img =
            "builder-image" + (this.className ? " " + this.className : "");
        this.node_2_Show =
            this.aspectRatio &&
                !(this.builderBlock?.children?.length && this.fitContent);
        this.node_3_div = {
            paddingTop: this.aspectRatio * 100 + "%",
        };
    }
    ngOnChanges(changes) {
        if (typeof window !== "undefined") {
            this.node_0_img = {
                objectPosition: this.backgroundPosition || "center",
                objectFit: this.backgroundSize || "cover",
                ...this.aspectRatioCss,
            };
            this.node_1_img =
                "builder-image" + (this.className ? " " + this.className : "");
            this.node_2_Show =
                this.aspectRatio &&
                    !(this.builderBlock?.children?.length && this.fitContent);
            this.node_3_div = {
                paddingTop: this.aspectRatio * 100 + "%",
            };
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: BuilderImage, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: BuilderImage, isStandalone: true, selector: "builder-image", inputs: { backgroundPosition: "backgroundPosition", backgroundSize: "backgroundSize", className: "className", aspectRatio: "aspectRatio", builderBlock: "builderBlock", fitContent: "fitContent", image: "image", src: "src", srcset: "srcset", noWebp: "noWebp", highPriority: "highPriority", altText: "altText", sizes: "sizes" }, usesOnChanges: true, ngImport: i0, template: `
    <ng-container>
      <picture>
        <ng-container *ngIf="webpSrcSet">
          <source type="image/webp" [attr.srcset]="webpSrcSet" />
        </ng-container>
        <img
          [attr.loading]="highPriority ? 'eager' : 'lazy'"
          [attr.fetchpriority]="highPriority ? 'high' : 'auto'"
          [attr.alt]="altText"
          [attr.role]="altText ? undefined : 'presentation'"
          [ngStyle]="node_0_img"
          [class]="node_1_img + ' img'"
          [attr.src]="image"
          [attr.srcset]="srcSetToUse"
          [attr.sizes]="sizes"
        />
      </picture>
      <ng-container *ngIf="node_2_Show">
        <div class="builder-image-sizer div" [ngStyle]="node_3_div"></div>
      </ng-container>
      <ng-container *ngIf="builderBlock?.children?.length && fitContent">
        <ng-content></ng-content>
      </ng-container>
      <ng-container *ngIf="!fitContent && builderBlock?.children?.length">
        <div class="div-2"><ng-content></ng-content></div>
      </ng-container>
    </ng-container>
  `, isInline: true, styles: [":host{display:contents}.img{opacity:1;transition:opacity .2s ease-in-out}.div{width:100%;pointer-events:none;font-size:0}.div-2{display:flex;flex-direction:column;align-items:stretch;position:absolute;top:0;left:0;width:100%;height:100%}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: BuilderImage, decorators: [{
            type: Component,
            args: [{ selector: "builder-image", template: `
    <ng-container>
      <picture>
        <ng-container *ngIf="webpSrcSet">
          <source type="image/webp" [attr.srcset]="webpSrcSet" />
        </ng-container>
        <img
          [attr.loading]="highPriority ? 'eager' : 'lazy'"
          [attr.fetchpriority]="highPriority ? 'high' : 'auto'"
          [attr.alt]="altText"
          [attr.role]="altText ? undefined : 'presentation'"
          [ngStyle]="node_0_img"
          [class]="node_1_img + ' img'"
          [attr.src]="image"
          [attr.srcset]="srcSetToUse"
          [attr.sizes]="sizes"
        />
      </picture>
      <ng-container *ngIf="node_2_Show">
        <div class="builder-image-sizer div" [ngStyle]="node_3_div"></div>
      </ng-container>
      <ng-container *ngIf="builderBlock?.children?.length && fitContent">
        <ng-content></ng-content>
      </ng-container>
      <ng-container *ngIf="!fitContent && builderBlock?.children?.length">
        <div class="div-2"><ng-content></ng-content></div>
      </ng-container>
    </ng-container>
  `, standalone: true, imports: [CommonModule], styles: [":host{display:contents}.img{opacity:1;transition:opacity .2s ease-in-out}.div{width:100%;pointer-events:none;font-size:0}.div-2{display:flex;flex-direction:column;align-items:stretch;position:absolute;top:0;left:0;width:100%;height:100%}\n"] }]
        }], propDecorators: { backgroundPosition: [{
                type: Input
            }], backgroundSize: [{
                type: Input
            }], className: [{
                type: Input
            }], aspectRatio: [{
                type: Input
            }], builderBlock: [{
                type: Input
            }], fitContent: [{
                type: Input
            }], image: [{
                type: Input
            }], src: [{
                type: Input
            }], srcset: [{
                type: Input
            }], noWebp: [{
                type: Input
            }], highPriority: [{
                type: Input
            }], altText: [{
                type: Input
            }], sizes: [{
                type: Input
            }] } });

class SectionComponent {
    setAttributes(el, value, changes) {
        if (!el) {
            return;
        }
        const target = typeof changes === "undefined" ? value : changes;
        Object.keys(target).forEach((key) => {
            if (key.startsWith("on")) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace("on", "").toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key.toLowerCase(), target[key] ?? "");
            }
        });
    }
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
        this.node_0_section = null;
        this.elRef0_state_0 = null;
    }
    ngOnInit() {
        this.node_0_section = {
            width: "100%",
            alignSelf: "stretch",
            flexGrow: 1,
            boxSizing: "border-box",
            maxWidth: this.maxWidth || 1200,
            display: "flex",
            flexDirection: "column",
            alignItems: "stretch",
            marginLeft: "auto",
            marginRight: "auto",
        };
        this.elRef0_state_0 = {};
    }
    ngAfterViewInit() {
        this.setAttributes(this.elRef0?.nativeElement, this.elRef0_state_0);
        this.setAttributes(this.elRef0?.nativeElement, this.attributes);
    }
    ngOnChanges(changes) {
        if (typeof window !== "undefined") {
            this.node_0_section = {
                width: "100%",
                alignSelf: "stretch",
                flexGrow: 1,
                boxSizing: "border-box",
                maxWidth: this.maxWidth || 1200,
                display: "flex",
                flexDirection: "column",
                alignItems: "stretch",
                marginLeft: "auto",
                marginRight: "auto",
            };
            this.elRef0_state_0 = {};
            this.setAttributes(this.elRef0?.nativeElement, this.elRef0_state_0, changes["elRef0_state_0"]?.currentValue);
            this.setAttributes(this.elRef0?.nativeElement, this.attributes, changes["attributes"]?.currentValue);
        }
    }
    ngOnDestroy() {
        for (const fn of this._listenerFns.values()) {
            fn();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SectionComponent, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: SectionComponent, isStandalone: true, selector: "section-component", inputs: { maxWidth: "maxWidth", attributes: "attributes" }, viewQueries: [{ propertyName: "elRef0", first: true, predicate: ["elRef0"], descendants: true }], usesOnChanges: true, ngImport: i0, template: `
    <section [ngStyle]="node_0_section" #elRef0>
      <ng-content></ng-content>
    </section>
  `, isInline: true, styles: [":host{display:contents}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SectionComponent, decorators: [{
            type: Component,
            args: [{ selector: "section-component", template: `
    <section [ngStyle]="node_0_section" #elRef0>
      <ng-content></ng-content>
    </section>
  `, standalone: true, imports: [CommonModule], styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { maxWidth: [{
                type: Input
            }], attributes: [{
                type: Input
            }], elRef0: [{
                type: ViewChild,
                args: ["elRef0"]
            }] } });

/**
 * Only gets one level up from hostname
 * wwww.example.com -> example.com
 * www.example.co.uk -> example.co.uk
 */
const getTopLevelDomain = (host) => {
    if (host === 'localhost' || host === '127.0.0.1') {
        return host;
    }
    const parts = host.split('.');
    if (parts.length > 2) {
        return parts.slice(1).join('.');
    }
    return host;
};

const getCookieSync = ({ name, canTrack }) => {
    try {
        if (!canTrack) {
            return undefined;
        }
        /**
         * Extracted from MDN docs
         * https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie#example_2_get_a_sample_cookie_named_test2
         */
        return document.cookie.split('; ').find(row => row.startsWith(`${name}=`))?.split('=')[1];
    }
    catch (err) {
        logger.warn('[COOKIE] GET error: ', err?.message || err);
        return undefined;
    }
};
/**
 * NOTE: This function is `async` because its react-native override is async. Do not remove the `async` keyword!
 * The sync version is only safe to use in code blocks that `react-native` is guaranteed not to not run.
 */
const getCookie = async (args) => getCookieSync(args);
const stringifyCookie = (cookie) => cookie.map(([key, value]) => value ? `${key}=${value}` : key).filter(checkIsDefined).join('; ');
const SECURE_CONFIG = [['secure', ''], ['SameSite', 'None']];
const createCookieString = ({ name, value, expires }) => {
    const secure = isBrowser() ? location.protocol === 'https:' : true;
    const secureObj = secure ? SECURE_CONFIG : [[]];
    // TODO: need to know if secure server side
    const expiresObj = expires ? [['expires', expires.toUTCString()]] : [[]];
    const cookieValue = [[name, value], ...expiresObj, ['path', '/'], ['domain', getTopLevelDomain(window.location.hostname)], ...secureObj];
    const cookie = stringifyCookie(cookieValue);
    return cookie;
};
/**
 * NOTE: This function is `async` because its react-native override is async. Do not remove the `async` keyword!
 */
const setCookie = async ({ name, value, expires, canTrack }) => {
    try {
        if (!canTrack) {
            return;
        }
        const cookie = createCookieString({
            name,
            value,
            expires
        });
        document.cookie = cookie;
    }
    catch (err) {
        logger.warn('[COOKIE] SET error: ', err?.message || err);
    }
};

const BUILDER_STORE_PREFIX = 'builder.tests';
const getContentTestKey = (id) => `${BUILDER_STORE_PREFIX}.${id}`;
const getContentVariationCookie = ({ contentId }) => getCookie({
    name: getContentTestKey(contentId),
    canTrack: true
});
const getContentVariationCookieSync = ({ contentId }) => getCookieSync({
    name: getContentTestKey(contentId),
    canTrack: true
});
const setContentVariationCookie = ({ contentId, value }) => setCookie({
    name: getContentTestKey(contentId),
    value,
    canTrack: true
});
const checkIsBuilderContentWithVariations = (item) => checkIsDefined(item.id) && checkIsDefined(item.variations) && Object.keys(item.variations).length > 0;
/**
 * Randomly assign a variation to a user
 */
const getRandomVariationId = ({ id, variations }) => {
    let n = 0;
    const random = Math.random();
    // loop over variations test ratios, incrementing a counter,
    // until we find the variation that this user should be assigned to
    for (const id in variations) {
        const testRatio = variations[id]?.testRatio;
        n += testRatio;
        if (random < n) {
            return id;
        }
    }
    // the variations array does not include the default variation.
    // if we arrive here, then it means that the random number fits in the default variation bucket.
    return id;
};
const getAndSetVariantId = (args) => {
    // if variation not found in storage, assign a random variation to this user
    const randomVariationId = getRandomVariationId(args);
    // store variation in cookies/storage
    setContentVariationCookie({
        contentId: args.id,
        value: randomVariationId
    }).catch(err => {
        logger.error('could not store A/B test variation: ', err);
    });
    return randomVariationId;
};
const getTestFields = ({ item, testGroupId }) => {
    const variationValue = item.variations[testGroupId];
    if (testGroupId === item.id ||
        // handle edge-case where `testGroupId` points to non-existing variation
        !variationValue) {
        return {
            testVariationId: item.id,
            testVariationName: 'Default'
        };
    }
    else {
        return {
            data: variationValue.data,
            testVariationId: variationValue.id,
            testVariationName: variationValue.name || (variationValue.id === item.id ? 'Default' : '')
        };
    }
};
const handleABTestingSync = ({ item, canTrack }) => {
    /**
     * We cannot SSR in React-Native.
     */
    if (TARGET === 'reactNative')
        return item;
    if (!canTrack) {
        return item;
    }
    if (!item) {
        return undefined;
    }
    if (!checkIsBuilderContentWithVariations(item)) {
        return item;
    }
    const testGroupId = getContentVariationCookieSync({
        contentId: item.id
    }) || getAndSetVariantId({
        variations: item.variations,
        id: item.id
    });
    const variationValue = getTestFields({
        item,
        testGroupId
    });
    return {
        ...item,
        ...variationValue
    };
};
const handleABTesting = async ({ item, canTrack }) => {
    if (!canTrack) {
        return item;
    }
    if (!checkIsBuilderContentWithVariations(item)) {
        return item;
    }
    const cookieValue = await getContentVariationCookie({
        contentId: item.id
    });
    const testGroupId = cookieValue || getAndSetVariantId({
        variations: item.variations,
        id: item.id
    });
    const variationValue = getTestFields({
        item,
        testGroupId
    });
    return {
        ...item,
        ...variationValue
    };
};

const USER_ATTRIBUTES_COOKIE_NAME = 'builder.userAttributes';
function createUserAttributesService() {
    let canTrack = true;
    const subscribers = new Set();
    return {
        setUserAttributes(newAttrs) {
            if (!isBrowser()) {
                return;
            }
            const userAttributes = {
                ...this.getUserAttributes(),
                ...newAttrs
            };
            setCookie({
                name: USER_ATTRIBUTES_COOKIE_NAME,
                value: JSON.stringify(userAttributes),
                canTrack
            });
            subscribers.forEach(callback => callback(userAttributes));
        },
        getUserAttributes() {
            if (!isBrowser()) {
                return {};
            }
            return JSON.parse(getCookieSync({
                name: USER_ATTRIBUTES_COOKIE_NAME,
                canTrack
            }) || '{}');
        },
        subscribeOnUserAttributesChange(callback) {
            subscribers.add(callback);
            return () => {
                subscribers.delete(callback);
            };
        },
        setCanTrack(value) {
            canTrack = value;
        }
    };
}
const userAttributesService = createUserAttributesService();
const setClientUserAttributes = (attributes) => {
    userAttributesService.setUserAttributes(attributes);
};

const getDefaultCanTrack = (canTrack) => {
    const result = checkIsDefined(canTrack) ? canTrack : true;
    userAttributesService.setCanTrack(result);
    return result;
};

const defaultTitle = {
    '@type': '@builder.io/sdk:Element',
    layerName: 'Accordion item title',
    responsiveStyles: {
        large: {
            marginTop: '10px',
            position: 'relative',
            display: 'flex',
            alignItems: 'stretch',
            flexDirection: 'column',
            paddingBottom: '10px'
        }
    },
    children: [{
            '@type': '@builder.io/sdk:Element',
            responsiveStyles: {
                large: {
                    textAlign: 'left',
                    display: 'flex',
                    flexDirection: 'column'
                }
            },
            component: {
                name: 'Text',
                options: {
                    text: 'I am an accordion title. Click me!'
                }
            }
        }]
};
const defaultDetail = {
    '@type': '@builder.io/sdk:Element',
    layerName: 'Accordion item detail',
    responsiveStyles: {
        large: {
            position: 'relative',
            display: 'flex',
            alignItems: 'stretch',
            flexDirection: 'column',
            marginTop: '10px',
            paddingBottom: '10px'
        }
    },
    children: [{
            '@type': '@builder.io/sdk:Element',
            responsiveStyles: {
                large: {
                    paddingTop: '50px',
                    textAlign: 'left',
                    display: 'flex',
                    flexDirection: 'column',
                    paddingBottom: '50px'
                }
            },
            component: {
                name: 'Text',
                options: {
                    text: 'I am an accordion detail, hello!'
                }
            }
        }]
};
const componentInfo$j = {
    name: 'Builder:Accordion',
    canHaveChildren: true,
    image: 'https://cdn.builder.io/api/v1/image/assets%2FagZ9n5CUKRfbL9t6CaJOyVSK4Es2%2Ffab6c1fd3fe542408cbdec078bca7f35',
    defaultStyles: {
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'stretch'
    },
    inputs: [{
            name: 'items',
            type: 'list',
            broadcast: true,
            subFields: [{
                    name: 'title',
                    type: 'uiBlocks',
                    hideFromUI: true,
                    defaultValue: [defaultTitle]
                }, {
                    name: 'detail',
                    type: 'uiBlocks',
                    hideFromUI: true,
                    defaultValue: [defaultDetail]
                }],
            defaultValue: [{
                    title: [defaultTitle],
                    detail: [defaultDetail]
                }, {
                    title: [defaultTitle],
                    detail: [defaultDetail]
                }],
            showIf: (options) => !options.get('useChildrenForItems')
        }, {
            name: 'oneAtATime',
            helperText: 'Only allow opening one at a time (collapse all others when new item openned)',
            type: 'boolean',
            defaultValue: false
        }, {
            name: 'grid',
            helperText: 'Display as a grid',
            type: 'boolean',
            defaultValue: false
        }, {
            name: 'gridRowWidth',
            helperText: 'Display as a grid',
            type: 'string',
            showIf: (options) => options.get('grid'),
            defaultValue: '25%'
        }, {
            name: 'useChildrenForItems',
            type: 'boolean',
            helperText: 'Use child elements for each slide, instead of the array. Useful for dynamically repeating items',
            advanced: true,
            defaultValue: false,
            onChange: (options) => {
                if (options.get('useChildrenForItems') === true) {
                    options.set('items', []);
                }
            }
        }],
    shouldReceiveBuilderProps: {
        builderBlock: true,
        builderContext: true,
        builderComponents: true,
        builderLinkComponent: true
    }
};

const convertOrderNumberToString = (order) => {
    return order.toString();
};

class Accordion {
    constructor() {
        this.open = [];
        this.node_0_div = (item, index) => this.getAccordionTitleClassName(index);
        this.node_1_div = (item, index) => ({
            ...this.accordionTitleStyles,
            ...(this.grid && {
                width: this.gridRowWidth,
                ...{
                    order: this.openGridItemOrder !== null
                        ? convertOrderNumberToString(index)
                        : convertOrderNumberToString(index + 1),
                },
            }),
        });
        this.node_3_Blocks = (item, index) => `items.${index}.title`;
        this.node_4_Show = (item, index) => this.open.includes(index);
        this.node_5_div = (item, index) => this.getAccordionDetailClassName(index);
        this.node_6_Blocks = (item, index) => `items.${index}.detail`;
    }
    get onlyOneAtATime() {
        return Boolean(this.grid || this.oneAtATime);
    }
    get accordionStyles() {
        const styles = {
            display: "flex",
            alignItems: "stretch",
            flexDirection: "column",
            ...(this.grid && {
                flexDirection: "row",
                alignItems: "flex-start",
                flexWrap: "wrap",
            }),
        };
        return styles;
    }
    get accordionTitleStyles() {
        const shared = {
            display: "flex",
            flexDirection: "column",
        };
        const styles = {
            ...shared,
            alignItems: "stretch",
            cursor: "pointer",
        };
        return Object.fromEntries(Object.entries(styles).filter(([_, value]) => value !== undefined));
    }
    getAccordionTitleClassName(index) {
        return `builder-accordion-title builder-accordion-title-${this.open.includes(index) ? "open" : "closed"}`;
    }
    getAccordionDetailClassName(index) {
        return `builder-accordion-detail builder-accordion-detail-${this.open.includes(index) ? "open" : "closed"}`;
    }
    get openGridItemOrder() {
        let itemOrder = null;
        const getOpenGridItemPosition = this.grid && this.open.length;
        if (getOpenGridItemPosition && document) {
            const openItemIndex = this.open[0];
            const openItem = document.querySelector(`.builder-accordion-title[data-index="${openItemIndex}"]`);
            let subjectItem = openItem;
            itemOrder = openItemIndex;
            if (subjectItem) {
                let prevItemRect = subjectItem.getBoundingClientRect();
                while ((subjectItem = subjectItem && subjectItem.nextElementSibling)) {
                    if (subjectItem) {
                        if (subjectItem.classList.contains("builder-accordion-detail")) {
                            continue;
                        }
                        const subjectItemRect = subjectItem.getBoundingClientRect();
                        if (subjectItemRect.left > prevItemRect.left) {
                            const index = parseInt(subjectItem.getAttribute("data-index") || "", 10);
                            if (!isNaN(index)) {
                                prevItemRect = subjectItemRect;
                                itemOrder = index;
                            }
                        }
                        else {
                            break;
                        }
                    }
                }
            }
        }
        if (typeof itemOrder === "number") {
            itemOrder = itemOrder + 1;
        }
        return itemOrder;
    }
    get accordionDetailStyles() {
        const styles = {
            ...{
                order: typeof this.openGridItemOrder === "number"
                    ? this.openGridItemOrder
                    : undefined,
            },
            ...(this.grid && {
                width: "100%",
            }),
        };
        return Object.fromEntries(Object.entries(styles).filter(([_, value]) => value !== undefined));
    }
    onClick(index) {
        if (this.open.includes(index)) {
            this.open = this.onlyOneAtATime
                ? []
                : this.open.filter((item) => item !== index);
        }
        else {
            this.open = this.onlyOneAtATime ? [index] : this.open.concat(index);
        }
    }
    trackByItem0(index, item) {
        return index;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: Accordion, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: Accordion, isStandalone: true, selector: "accordion", inputs: { grid: "grid", oneAtATime: "oneAtATime", gridRowWidth: "gridRowWidth", items: "items", builderBlock: "builderBlock", builderContext: "builderContext", builderComponents: "builderComponents", builderLinkComponent: "builderLinkComponent" }, ngImport: i0, template: `
    <div class="builder-accordion" [ngStyle]="accordionStyles">
      <ng-container
        *ngFor="let item of items; index as index; trackBy: trackByItem0"
      >
        <ng-container>
          <div
            [class]="node_0_div(item, index)"
            [ngStyle]="node_1_div(item, index)"
            [attr.data-index]="index"
            (click)="onClick(index)"
          >
            <blocks
              [blocks]="item.title"
              [path]="node_3_Blocks(item, index)"
              [parent]="builderBlock.id"
              [context]="builderContext"
              [registeredComponents]="builderComponents"
              [linkComponent]="builderLinkComponent"
            ></blocks>
          </div>
          <ng-container *ngIf="node_4_Show(item, index)">
            <div
              [class]="node_5_div(item, index)"
              [ngStyle]="accordionDetailStyles"
            >
              <blocks
                [blocks]="item.detail"
                [path]="node_6_Blocks(item, index)"
                [parent]="builderBlock.id"
                [context]="builderContext"
                [registeredComponents]="builderComponents"
                [linkComponent]="builderLinkComponent"
              ></blocks>
            </div>
          </ng-container>
        </ng-container>
      </ng-container>
    </div>
  `, isInline: true, styles: [":host{display:contents}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "component", type: Blocks, selector: "blocks", inputs: ["blocks", "parent", "path", "styleProp", "className", "context", "linkComponent", "registeredComponents"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: Accordion, decorators: [{
            type: Component,
            args: [{ selector: "accordion", template: `
    <div class="builder-accordion" [ngStyle]="accordionStyles">
      <ng-container
        *ngFor="let item of items; index as index; trackBy: trackByItem0"
      >
        <ng-container>
          <div
            [class]="node_0_div(item, index)"
            [ngStyle]="node_1_div(item, index)"
            [attr.data-index]="index"
            (click)="onClick(index)"
          >
            <blocks
              [blocks]="item.title"
              [path]="node_3_Blocks(item, index)"
              [parent]="builderBlock.id"
              [context]="builderContext"
              [registeredComponents]="builderComponents"
              [linkComponent]="builderLinkComponent"
            ></blocks>
          </div>
          <ng-container *ngIf="node_4_Show(item, index)">
            <div
              [class]="node_5_div(item, index)"
              [ngStyle]="accordionDetailStyles"
            >
              <blocks
                [blocks]="item.detail"
                [path]="node_6_Blocks(item, index)"
                [parent]="builderBlock.id"
                [context]="builderContext"
                [registeredComponents]="builderComponents"
                [linkComponent]="builderLinkComponent"
              ></blocks>
            </div>
          </ng-container>
        </ng-container>
      </ng-container>
    </div>
  `, standalone: true, imports: [CommonModule, Blocks], styles: [":host{display:contents}\n"] }]
        }], propDecorators: { grid: [{
                type: Input
            }], oneAtATime: [{
                type: Input
            }], gridRowWidth: [{
                type: Input
            }], items: [{
                type: Input
            }], builderBlock: [{
                type: Input
            }], builderContext: [{
                type: Input
            }], builderComponents: [{
                type: Input
            }], builderLinkComponent: [{
                type: Input
            }] } });

const componentInfo$i = {
    name: 'Core:Button',
    image: 'https://cdn.builder.io/api/v1/image/assets%2FIsxPKMo2gPRRKeakUztj1D6uqed2%2F81a15681c3e74df09677dfc57a615b13',
    defaultStyles: {
        // TODO: make min width more intuitive and set one
        appearance: 'none',
        paddingTop: '15px',
        paddingBottom: '15px',
        paddingLeft: '25px',
        paddingRight: '25px',
        backgroundColor: '#000000',
        color: 'white',
        borderRadius: '4px',
        textAlign: 'center',
        cursor: 'pointer'
    },
    inputs: [{
            name: 'text',
            type: 'text',
            defaultValue: 'Click me!',
            bubble: true
        }, {
            name: 'link',
            type: 'url',
            bubble: true
        }, {
            name: 'openLinkInNewTab',
            type: 'boolean',
            defaultValue: false,
            friendlyName: 'Open link in new tab'
        }],
    static: true,
    noWrap: true,
    shouldReceiveBuilderProps: {
        builderLinkComponent: true
    }
};

const componentInfo$h = {
    // TODO: ways to statically preprocess JSON for references, functions, etc
    name: 'Columns',
    isRSC: true,
    inputs: [{
            name: 'columns',
            type: 'array',
            broadcast: true,
            subFields: [{
                    name: 'blocks',
                    type: 'array',
                    hideFromUI: true,
                    defaultValue: [{
                            '@type': '@builder.io/sdk:Element',
                            responsiveStyles: {
                                large: {
                                    display: 'flex',
                                    flexDirection: 'column',
                                    alignItems: 'stretch',
                                    flexShrink: '0',
                                    position: 'relative',
                                    marginTop: '30px',
                                    textAlign: 'center',
                                    lineHeight: 'normal',
                                    height: 'auto',
                                    minHeight: '20px',
                                    minWidth: '20px',
                                    overflow: 'hidden'
                                }
                            },
                            component: {
                                name: 'Image',
                                options: {
                                    image: 'https://builder.io/api/v1/image/assets%2Fpwgjf0RoYWbdnJSbpBAjXNRMe9F2%2Ffb27a7c790324294af8be1c35fe30f4d',
                                    backgroundPosition: 'center',
                                    backgroundSize: 'cover',
                                    aspectRatio: 0.7004048582995948
                                }
                            }
                        }, {
                            '@type': '@builder.io/sdk:Element',
                            responsiveStyles: {
                                large: {
                                    display: 'flex',
                                    flexDirection: 'column',
                                    alignItems: 'stretch',
                                    flexShrink: '0',
                                    position: 'relative',
                                    marginTop: '30px',
                                    textAlign: 'center',
                                    lineHeight: 'normal',
                                    height: 'auto'
                                }
                            },
                            component: {
                                name: 'Text',
                                options: {
                                    text: '<p>Enter some text...</p>'
                                }
                            }
                        }]
                }, {
                    name: 'width',
                    type: 'number',
                    hideFromUI: true,
                    helperText: 'Width %, e.g. set to 50 to fill half of the space'
                }, {
                    name: 'link',
                    type: 'url',
                    helperText: 'Optionally set a url that clicking this column will link to'
                }],
            defaultValue: [{
                    blocks: [{
                            '@type': '@builder.io/sdk:Element',
                            responsiveStyles: {
                                large: {
                                    display: 'flex',
                                    flexDirection: 'column',
                                    alignItems: 'stretch',
                                    flexShrink: '0',
                                    position: 'relative',
                                    marginTop: '30px',
                                    textAlign: 'center',
                                    lineHeight: 'normal',
                                    height: 'auto',
                                    minHeight: '20px',
                                    minWidth: '20px',
                                    overflow: 'hidden'
                                }
                            },
                            component: {
                                name: 'Image',
                                options: {
                                    image: 'https://builder.io/api/v1/image/assets%2Fpwgjf0RoYWbdnJSbpBAjXNRMe9F2%2Ffb27a7c790324294af8be1c35fe30f4d',
                                    backgroundPosition: 'center',
                                    backgroundSize: 'cover',
                                    aspectRatio: 0.7004048582995948
                                }
                            }
                        }, {
                            '@type': '@builder.io/sdk:Element',
                            responsiveStyles: {
                                large: {
                                    display: 'flex',
                                    flexDirection: 'column',
                                    alignItems: 'stretch',
                                    flexShrink: '0',
                                    position: 'relative',
                                    marginTop: '30px',
                                    textAlign: 'center',
                                    lineHeight: 'normal',
                                    height: 'auto'
                                }
                            },
                            component: {
                                name: 'Text',
                                options: {
                                    text: '<p>Enter some text...</p>'
                                }
                            }
                        }]
                }, {
                    blocks: [{
                            '@type': '@builder.io/sdk:Element',
                            responsiveStyles: {
                                large: {
                                    display: 'flex',
                                    flexDirection: 'column',
                                    alignItems: 'stretch',
                                    flexShrink: '0',
                                    position: 'relative',
                                    marginTop: '30px',
                                    textAlign: 'center',
                                    lineHeight: 'normal',
                                    height: 'auto',
                                    minHeight: '20px',
                                    minWidth: '20px',
                                    overflow: 'hidden'
                                }
                            },
                            component: {
                                name: 'Image',
                                options: {
                                    image: 'https://builder.io/api/v1/image/assets%2Fpwgjf0RoYWbdnJSbpBAjXNRMe9F2%2Ffb27a7c790324294af8be1c35fe30f4d',
                                    backgroundPosition: 'center',
                                    backgroundSize: 'cover',
                                    aspectRatio: 0.7004048582995948
                                }
                            }
                        }, {
                            '@type': '@builder.io/sdk:Element',
                            responsiveStyles: {
                                large: {
                                    display: 'flex',
                                    flexDirection: 'column',
                                    alignItems: 'stretch',
                                    flexShrink: '0',
                                    position: 'relative',
                                    marginTop: '30px',
                                    textAlign: 'center',
                                    lineHeight: 'normal',
                                    height: 'auto'
                                }
                            },
                            component: {
                                name: 'Text',
                                options: {
                                    text: '<p>Enter some text...</p>'
                                }
                            }
                        }]
                }],
            onChange: (options) => {
                function clearWidths() {
                    columns.forEach(col => {
                        col.delete('width');
                    });
                }
                const columns = options.get('columns');
                if (Array.isArray(columns)) {
                    const containsColumnWithWidth = !!columns.find(col => col.get('width'));
                    if (containsColumnWithWidth) {
                        const containsColumnWithoutWidth = !!columns.find(col => !col.get('width'));
                        if (containsColumnWithoutWidth) {
                            clearWidths();
                        }
                        else {
                            const sumWidths = columns.reduce((memo, col) => {
                                return memo + col.get('width');
                            }, 0);
                            const widthsDontAddUp = sumWidths !== 100;
                            if (widthsDontAddUp) {
                                clearWidths();
                            }
                        }
                    }
                }
            }
        }, {
            name: 'space',
            type: 'number',
            defaultValue: 20,
            helperText: 'Size of gap between columns',
            advanced: true
        }, {
            name: 'stackColumnsAt',
            type: 'string',
            defaultValue: 'tablet',
            helperText: 'Convert horizontal columns to vertical at what device size',
            enum: ['tablet', 'mobile', 'never'],
            advanced: true
        }, {
            name: 'reverseColumnsWhenStacked',
            type: 'boolean',
            defaultValue: false,
            helperText: 'When stacking columns for mobile devices, reverse the ordering',
            advanced: true
        }],
    shouldReceiveBuilderProps: {
        builderBlock: true,
        builderContext: true,
        builderComponents: true,
        builderLinkComponent: true
    }
};

const componentInfo$g = {
    name: 'Fragment',
    static: true,
    hidden: true,
    canHaveChildren: true,
    noWrap: true
};

const IMAGE_FILE_TYPES = ['jpeg', 'jpg', 'png', 'svg', 'webp', 'gif', 'jfif', 'pjpeg', 'pjp', 'apng', 'avif', 'tif', 'tiff', 'heif', 'bmp', 'eps', 'raw', 'cr2', 'nef', 'orf', 'sr2', 'psd', 'heic', 'dib', 'ai'];
const VIDEO_FILE_TYPES = ['mp4', 'webm', 'mkv', 'flv', 'vob', 'ogv', 'ogg', 'drc', 'gif', 'gifv', 'mng', 'avi', 'mov', 'qt', 'mts', 'm2ts', 'ts', 'wmv', 'yuv', 'rm', 'rmvb', 'viv', 'asf', 'amv', 'm4p', 'mpeg', 'mpe', 'm2v', 'm4v', 'svi', '3gp', '3g2', 'mxf', 'roq', 'nsv', 'f4v', 'f4p', 'f4a', 'f4b'];

const componentInfo$f = {
    name: 'Image',
    static: true,
    image: 'https://firebasestorage.googleapis.com/v0/b/builder-3b0a2.appspot.com/o/images%2Fbaseline-insert_photo-24px.svg?alt=media&token=4e5d0ef4-f5e8-4e57-b3a9-38d63a9b9dc4',
    defaultStyles: {
        position: 'relative',
        minHeight: '20px',
        minWidth: '20px',
        overflow: 'hidden'
    },
    canHaveChildren: true,
    inputs: [{
            name: 'image',
            type: 'file',
            bubble: true,
            allowedFileTypes: IMAGE_FILE_TYPES,
            required: true,
            defaultValue: 'https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2F72c80f114dc149019051b6852a9e3b7a',
            onChange: (options) => {
                const DEFAULT_ASPECT_RATIO = 0.7041;
                options.delete('srcset');
                options.delete('noWebp');
                function loadImage(url, timeout = 60000) {
                    return new Promise((resolve, reject) => {
                        const img = document.createElement('img');
                        let loaded = false;
                        img.onload = () => {
                            loaded = true;
                            resolve(img);
                        };
                        img.addEventListener('error', event => {
                            console.warn('Image load failed', event.error);
                            reject(event.error);
                        });
                        img.src = url;
                        setTimeout(() => {
                            if (!loaded) {
                                reject(new Error('Image load timed out'));
                            }
                        }, timeout);
                    });
                }
                function round(num) {
                    return Math.round(num * 1000) / 1000;
                }
                const value = options.get('image');
                const aspectRatio = options.get('aspectRatio');
                // For SVG images - don't render as webp, keep them as SVG
                fetch(value).then(res => res.blob()).then(blob => {
                    if (blob.type.includes('svg')) {
                        options.set('noWebp', true);
                    }
                });
                if (value && (!aspectRatio || aspectRatio === DEFAULT_ASPECT_RATIO)) {
                    return loadImage(value).then(img => {
                        const possiblyUpdatedAspectRatio = options.get('aspectRatio');
                        if (options.get('image') === value && (!possiblyUpdatedAspectRatio || possiblyUpdatedAspectRatio === DEFAULT_ASPECT_RATIO)) {
                            if (img.width && img.height) {
                                options.set('aspectRatio', round(img.height / img.width));
                                options.set('height', img.height);
                                options.set('width', img.width);
                            }
                        }
                    });
                }
            }
        }, {
            name: 'backgroundSize',
            type: 'text',
            defaultValue: 'cover',
            enum: [{
                    label: 'contain',
                    value: 'contain',
                    helperText: 'The image should never get cropped'
                }, {
                    label: 'cover',
                    value: 'cover',
                    helperText: "The image should fill it's box, cropping when needed"
                }]
        }, {
            name: 'backgroundPosition',
            type: 'text',
            defaultValue: 'center',
            enum: ['center', 'top', 'left', 'right', 'bottom', 'top left', 'top right', 'bottom left', 'bottom right']
        }, {
            name: 'altText',
            type: 'string',
            helperText: 'Text to display when the user has images off'
        }, {
            name: 'height',
            type: 'number',
            hideFromUI: true
        }, {
            name: 'width',
            type: 'number',
            hideFromUI: true
        }, {
            name: 'sizes',
            type: 'string',
            hideFromUI: true
        }, {
            name: 'srcset',
            type: 'string',
            hideFromUI: true
        }, {
            name: 'lazy',
            type: 'boolean',
            defaultValue: true,
            hideFromUI: true
        }, {
            name: 'fitContent',
            type: 'boolean',
            helperText: "When child blocks are provided, fit to them instead of using the image's aspect ratio",
            defaultValue: true
        }, {
            name: 'highPriority',
            type: 'boolean',
            advanced: true,
            helperText: 'Mark this image as high priority compared to other images on the page. This prevents lazy loading of the image and tells the browser to load this image before others on the page.'
        }, {
            name: 'aspectRatio',
            type: 'number',
            helperText: "This is the ratio of height/width, e.g. set to 1.5 for a 300px wide and 200px tall photo. Set to 0 to not force the image to maintain it's aspect ratio",
            advanced: true,
            defaultValue: 0.7041
        }],
    shouldReceiveBuilderProps: {
        builderBlock: true
    }
};

const componentInfo$e = {
    name: 'PersonalizationContainer',
    shouldReceiveBuilderProps: {
        builderBlock: true,
        builderContext: true
    },
    noWrap: true,
    image: 'https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2F37229ed30d8c41dfb10b8cca1992053a',
    canHaveChildren: true,
    inputs: [{
            name: 'variants',
            defaultValue: [],
            behavior: 'personalizationVariantList',
            type: 'list',
            subFields: [{
                    name: 'name',
                    type: 'text'
                }, {
                    name: 'query',
                    friendlyName: 'Targeting rules',
                    type: 'BuilderQuery',
                    defaultValue: []
                }, {
                    name: 'startDate',
                    type: 'date'
                }, {
                    name: 'endDate',
                    type: 'date'
                }, {
                    name: 'blocks',
                    type: 'uiBlocks',
                    hideFromUI: true,
                    defaultValue: []
                }]
        }]
};

class InlinedScript {
    constructor(renderer, document, platformId) {
        this.renderer = renderer;
        this.document = document;
        this.platformId = platformId;
    }
    ngOnInit() {
        if (isPlatformBrowser(this.platformId)) {
            const script = this.renderer.createElement('script');
            script.innerHTML = this.scriptStr;
            this.renderer.setAttribute(script, 'data-id', this.id);
            this.renderer.setAttribute(script, 'nonce', this.nonce);
            this.renderer.appendChild(this.document.body, script);
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: InlinedScript, deps: [{ token: i0.Renderer2 }, { token: DOCUMENT }, { token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: InlinedScript, isStandalone: true, selector: "inlined-script, InlinedScript", inputs: { scriptStr: "scriptStr", id: "id", nonce: "nonce" }, ngImport: i0, template: ``, isInline: true, styles: [":host{display:contents}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: InlinedScript, decorators: [{
            type: Component,
            args: [{ selector: 'inlined-script, InlinedScript', template: ``, standalone: true, imports: [CommonModule], styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }, { type: Document, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [PLATFORM_ID]
                }] }]; }, propDecorators: { scriptStr: [{
                type: Input
            }], id: [{
                type: Input
            }], nonce: [{
                type: Input
            }] } });

function isPreviewing(_search) {
    const search = _search || (isBrowser() ? window.location.search : undefined);
    /**
     * If this function is called on the server without an explicit `search` argument,
     * then it can't check if the user is previewing, and will return `false`.
     */
    if (!search) {
        return false;
    }
    const normalizedSearch = getSearchString(search);
    return Boolean(normalizedSearch.indexOf('builder.preview=') !== -1);
}

/**
 * WARNING: This file contains functions that get stringified and inlined into the HTML at build-time.
 * They cannot import anything.
 */
function filterWithCustomTargeting(userAttributes, query, startDate, endDate) {
    function isString(val) {
        return typeof val === 'string';
    }
    function isNumber(val) {
        return typeof val === 'number';
    }
    function objectMatchesQuery(userattr, query) {
        const result = (() => {
            const property = query.property;
            const operator = query.operator;
            let testValue = query.value;
            if (query && query.property === 'urlPath' && query.value && typeof query.value === 'string' && query.value !== '/' && query.value.endsWith('/')) {
                testValue = query.value.slice(0, -1);
            }
            if (!(property && operator)) {
                return true;
            }
            if (Array.isArray(testValue)) {
                if (operator === 'isNot') {
                    return testValue.every(val => objectMatchesQuery(userattr, {
                        property,
                        operator,
                        value: val
                    }));
                }
                return !!testValue.find(val => objectMatchesQuery(userattr, {
                    property,
                    operator,
                    value: val
                }));
            }
            const value = userattr[property];
            if (Array.isArray(value)) {
                return value.includes(testValue);
            }
            switch (operator) {
                case 'is':
                    return value === testValue;
                case 'isNot':
                    return value !== testValue;
                case 'contains':
                    return (isString(value) || Array.isArray(value)) && value.includes(String(testValue));
                case 'startsWith':
                    return isString(value) && value.startsWith(String(testValue));
                case 'endsWith':
                    return isString(value) && value.endsWith(String(testValue));
                case 'greaterThan':
                    return isNumber(value) && isNumber(testValue) && value > testValue;
                case 'lessThan':
                    return isNumber(value) && isNumber(testValue) && value < testValue;
                case 'greaterThanOrEqualTo':
                    return isNumber(value) && isNumber(testValue) && value >= testValue;
                case 'lessThanOrEqualTo':
                    return isNumber(value) && isNumber(testValue) && value <= testValue;
                default:
                    return false;
            }
        })();
        return result;
    }
    const item = {
        query,
        startDate,
        endDate
    };
    const now = userAttributes.date && new Date(userAttributes.date) || new Date();
    if (item.startDate && new Date(item.startDate) > now) {
        return false;
    }
    else if (item.endDate && new Date(item.endDate) < now) {
        return false;
    }
    if (!item.query || !item.query.length) {
        return true;
    }
    return item.query.every((filter) => {
        return objectMatchesQuery(userAttributes, filter);
    });
}
const PERSONALIZATION_SCRIPT = "function getPersonalizedVariant(variants, blockId, locale) {\n  if (!navigator.cookieEnabled) {\n    return;\n  }\n  function getCookie(name) {\n    const nameEQ = name + '=';\n    const ca = document.cookie.split(';');\n    for (let i = 0; i < ca.length; i++) {\n      let c = ca[i];\n      while (c.charAt(0) == ' ') c = c.substring(1, c.length);\n      if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);\n    }\n    return null;\n  }\n  function removeVariants() {\n    variants?.forEach(function (_, index) {\n      document.querySelector('template[data-variant-id=\"' + blockId + '-' + index + '\"]')?.remove();\n    });\n    document.querySelector('script[data-id=\"variants-script-' + blockId + '\"]')?.remove();\n    document.querySelector('style[data-id=\"variants-styles-' + blockId + '\"]')?.remove();\n  }\n  const attributes = JSON.parse(getCookie('builder.userAttributes') || '{}');\n  if (locale) {\n    attributes.locale = locale;\n  }\n  const winningVariantIndex = variants?.findIndex(function (variant) {\n    return filterWithCustomTargeting(attributes, variant.query, variant.startDate, variant.endDate);\n  });\n  const isDebug = location.href.includes('builder.debug=true');\n  if (isDebug) {\n    console.debug('PersonalizationContainer', {\n      attributes,\n      variants,\n      winningVariantIndex\n    });\n  }\n  if (winningVariantIndex !== -1) {\n    const winningVariant = document.querySelector('template[data-variant-id=\"' + blockId + '-' + winningVariantIndex + '\"]');\n    if (winningVariant) {\n      const parentNode = winningVariant.parentNode;\n      if (parentNode) {\n        const newParent = parentNode.cloneNode(false);\n        newParent.appendChild(winningVariant.content.firstChild);\n        newParent.appendChild(winningVariant.content.lastChild);\n        parentNode.parentNode?.replaceChild(newParent, parentNode);\n      }\n      if (isDebug) {\n        console.debug('PersonalizationContainer', 'Winning variant Replaced:', winningVariant);\n      }\n    }\n  } else if (variants && variants.length > 0) {\n    removeVariants();\n  }\n}";
const FILTER_WITH_CUSTOM_TARGETING_SCRIPT = "function filterWithCustomTargeting(userAttributes, query, startDate, endDate) {\n  function isString(val) {\n    return typeof val === 'string';\n  }\n  function isNumber(val) {\n    return typeof val === 'number';\n  }\n  function objectMatchesQuery(userattr, query) {\n    const result = (() => {\n      const property = query.property;\n      const operator = query.operator;\n      let testValue = query.value;\n      if (query && query.property === 'urlPath' && query.value && typeof query.value === 'string' && query.value !== '/' && query.value.endsWith('/')) {\n        testValue = query.value.slice(0, -1);\n      }\n      if (!(property && operator)) {\n        return true;\n      }\n      if (Array.isArray(testValue)) {\n        if (operator === 'isNot') {\n          return testValue.every(val => objectMatchesQuery(userattr, {\n            property,\n            operator,\n            value: val\n          }));\n        }\n        return !!testValue.find(val => objectMatchesQuery(userattr, {\n          property,\n          operator,\n          value: val\n        }));\n      }\n      const value = userattr[property];\n      if (Array.isArray(value)) {\n        return value.includes(testValue);\n      }\n      switch (operator) {\n        case 'is':\n          return value === testValue;\n        case 'isNot':\n          return value !== testValue;\n        case 'contains':\n          return (isString(value) || Array.isArray(value)) && value.includes(String(testValue));\n        case 'startsWith':\n          return isString(value) && value.startsWith(String(testValue));\n        case 'endsWith':\n          return isString(value) && value.endsWith(String(testValue));\n        case 'greaterThan':\n          return isNumber(value) && isNumber(testValue) && value > testValue;\n        case 'lessThan':\n          return isNumber(value) && isNumber(testValue) && value < testValue;\n        case 'greaterThanOrEqualTo':\n          return isNumber(value) && isNumber(testValue) && value >= testValue;\n        case 'lessThanOrEqualTo':\n          return isNumber(value) && isNumber(testValue) && value <= testValue;\n        default:\n          return false;\n      }\n    })();\n    return result;\n  }\n  const item = {\n    query,\n    startDate,\n    endDate\n  };\n  const now = userAttributes.date && new Date(userAttributes.date) || new Date();\n  if (item.startDate && new Date(item.startDate) > now) {\n    return false;\n  } else if (item.endDate && new Date(item.endDate) < now) {\n    return false;\n  }\n  if (!item.query || !item.query.length) {\n    return true;\n  }\n  return item.query.every(filter => {\n    return objectMatchesQuery(userAttributes, filter);\n  });\n}";

function checkShouldRenderVariants$1(variants, canTrack) {
    const hasVariants = variants && variants.length > 0;
    if (TARGET === 'reactNative')
        return false;
    if (!hasVariants)
        return false;
    if (!canTrack)
        return false;
    if (TARGET === 'vue' || TARGET === 'svelte')
        return true;
    if (isBrowser())
        return false;
    return true;
}
function getBlocksToRender({ variants, previewingIndex, isHydrated, filteredVariants, fallbackBlocks }) {
    const fallback = {
        blocks: fallbackBlocks ?? [],
        path: 'this.children'
    };
    if (isHydrated && isEditing()) {
        // If editing a specific variant
        if (typeof previewingIndex === 'number' && previewingIndex < (variants?.length ?? 0)) {
            const variant = variants[previewingIndex];
            return {
                blocks: variant.blocks,
                path: `component.options.variants.${previewingIndex}.blocks`
            };
        }
        // Otherwise we're editing the default variant
        return fallback;
    }
    // If we're on the browser, check if there's a winning variant
    if (isBrowser()) {
        const winningVariant = filteredVariants?.[0];
        if (winningVariant) {
            return {
                blocks: winningVariant.blocks,
                path: `component.options.variants.${variants?.indexOf(winningVariant)}.blocks`
            };
        }
    }
    // If no winning variant or we are on the server, return the default variant
    return fallback;
}
const getPersonalizationScript = (variants, blockId, locale) => {
    return `
  (function() {
    ${FILTER_WITH_CUSTOM_TARGETING_SCRIPT}
    ${PERSONALIZATION_SCRIPT}
    getPersonalizedVariant(${JSON.stringify(variants)}, "${blockId}"${locale ? `, "${locale}"` : ''})
  })();
  `;
};

class PersonalizationContainer {
    get filteredVariants() {
        return (this.variants || []).filter((variant) => {
            return filterWithCustomTargeting({
                ...(this.builderContext?.rootState?.locale
                    ? {
                        locale: this.builderContext?.rootState?.locale,
                    }
                    : {}),
                ...this.userAttributes,
            }, variant.query, variant.startDate, variant.endDate);
        });
    }
    get blocksToRender() {
        return getBlocksToRender({
            variants: this.variants,
            fallbackBlocks: this.builderBlock?.children,
            isHydrated: this.isHydrated,
            filteredVariants: this.filteredVariants,
            previewingIndex: this.previewingIndex,
        });
    }
    get hideVariantsStyleString() {
        return (this.variants || [])
            .map((_, index) => `[data-variant-id="${this.builderBlock?.id}-${index}"] { display: none; } `)
            .join("");
    }
    setAttributes(el, value, changes) {
        if (!el) {
            return;
        }
        const target = typeof changes === "undefined" ? value : changes;
        Object.keys(target).forEach((key) => {
            if (key.startsWith("on")) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace("on", "").toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key.toLowerCase(), target[key] ?? "");
            }
        });
    }
    trackByVariant0(index, variant) {
        return index;
    }
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
        this.userAttributes = userAttributesService.getUserAttributes();
        this.scriptStr = null;
        this.unsubscribers = [];
        this.shouldRenderVariants = null;
        this.isHydrated = false;
        this.node_0_div = null;
        this.node_1_template = (variant, index) => `${this.builderBlock?.id}-${index}`;
        this.node_2_Blocks = (variant, index) => `component.options.variants.${index}.blocks`;
        this.node_3_InlinedStyles = null;
        this.node_4_InlinedScript = null;
    }
    ngOnInit() {
        this.scriptStr = getPersonalizationScript(this.variants, this.builderBlock?.id || "none", this.builderContext?.rootState?.locale);
        this.shouldRenderVariants = checkShouldRenderVariants$1(this.variants, getDefaultCanTrack(this.builderContext?.canTrack));
        this.node_0_div = `builder-personalization-container ${this.attributes?.className || ""}`;
        this.node_3_InlinedStyles = `variants-styles-${this.builderBlock?.id}`;
        this.node_4_InlinedScript = `variants-script-${this.builderBlock?.id}`;
        if (typeof window !== "undefined") {
            this.isHydrated = true;
            const unsub = userAttributesService.subscribeOnUserAttributesChange((attrs) => {
                this.userAttributes = attrs;
            });
            if (!(isEditing() || isPreviewing())) {
                const variant = this.filteredVariants[0];
                if (this.rootRef.nativeElement) {
                    this.rootRef.nativeElement.dispatchEvent(new CustomEvent("builder.variantLoaded", {
                        detail: {
                            variant: variant || "default",
                            content: this.builderContext?.content,
                        },
                        bubbles: true,
                    }));
                    const observer = new IntersectionObserver((entries) => {
                        entries.forEach((entry) => {
                            if (entry.isIntersecting && this.rootRef.nativeElement) {
                                this.rootRef.nativeElement.dispatchEvent(new CustomEvent("builder.variantDisplayed", {
                                    detail: {
                                        variant: variant || "default",
                                        content: this.builderContext?.content,
                                    },
                                    bubbles: true,
                                }));
                            }
                        });
                    });
                    observer.observe(this.rootRef.nativeElement);
                }
            }
            this.unsubscribers.push(unsub);
        }
    }
    ngAfterViewInit() {
        this.setAttributes(this.elRef0?.nativeElement, this.attributes);
    }
    ngOnChanges(changes) {
        if (typeof window !== "undefined") {
            this.node_0_div = `builder-personalization-container ${this.attributes?.className || ""}`;
            this.node_3_InlinedStyles = `variants-styles-${this.builderBlock?.id}`;
            this.node_4_InlinedScript = `variants-script-${this.builderBlock?.id}`;
            this.setAttributes(this.elRef0?.nativeElement, this.attributes, changes["attributes"]?.currentValue);
        }
    }
    ngOnDestroy() {
        this.unsubscribers.forEach((unsub) => unsub());
        for (const fn of this._listenerFns.values()) {
            fn();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: PersonalizationContainer, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: PersonalizationContainer, isStandalone: true, selector: "personalization-container", inputs: { builderContext: "builderContext", attributes: "attributes", builderBlock: "builderBlock", variants: "variants", previewingIndex: "previewingIndex" }, viewQueries: [{ propertyName: "rootRef", first: true, predicate: ["rootRef"], descendants: true }, { propertyName: "elRef0", first: true, predicate: ["elRef0"], descendants: true }], usesOnChanges: true, ngImport: i0, template: `
    <div #rootRef [class]="node_0_div" #elRef0>
      <ng-container *ngIf="shouldRenderVariants">
        <ng-container
          *ngFor="let variant of variants; index as index; trackBy: trackByVariant0"
        >
          <template [attr.data-variant-id]="node_1_template(variant, index)">
            <blocks
              [blocks]="variant.blocks"
              [parent]="builderBlock?.id"
              [path]="node_2_Blocks(variant, index)"
            ></blocks>
          </template>
        </ng-container>
        <inlined-styles
          [nonce]="builderContext?.nonce || ''"
          [styles]="hideVariantsStyleString"
          [id]="node_3_InlinedStyles"
        ></inlined-styles>
        <inlined-script
          [nonce]="builderContext?.nonce || ''"
          [scriptStr]="scriptStr"
          [id]="node_4_InlinedScript"
        ></inlined-script>
      </ng-container>
      <blocks
        [blocks]="blocksToRender.blocks"
        [parent]="builderBlock?.id"
        [path]="blocksToRender.path"
      ></blocks>
    </div>
  `, isInline: true, styles: [":host{display:contents}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: Blocks, selector: "blocks", inputs: ["blocks", "parent", "path", "styleProp", "className", "context", "linkComponent", "registeredComponents"] }, { kind: "component", type: InlinedStyles, selector: "inlined-styles, InlinedStyles", inputs: ["styles", "id", "nonce"] }, { kind: "component", type: InlinedScript, selector: "inlined-script, InlinedScript", inputs: ["scriptStr", "id", "nonce"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: PersonalizationContainer, decorators: [{
            type: Component,
            args: [{ selector: "personalization-container", template: `
    <div #rootRef [class]="node_0_div" #elRef0>
      <ng-container *ngIf="shouldRenderVariants">
        <ng-container
          *ngFor="let variant of variants; index as index; trackBy: trackByVariant0"
        >
          <template [attr.data-variant-id]="node_1_template(variant, index)">
            <blocks
              [blocks]="variant.blocks"
              [parent]="builderBlock?.id"
              [path]="node_2_Blocks(variant, index)"
            ></blocks>
          </template>
        </ng-container>
        <inlined-styles
          [nonce]="builderContext?.nonce || ''"
          [styles]="hideVariantsStyleString"
          [id]="node_3_InlinedStyles"
        ></inlined-styles>
        <inlined-script
          [nonce]="builderContext?.nonce || ''"
          [scriptStr]="scriptStr"
          [id]="node_4_InlinedScript"
        ></inlined-script>
      </ng-container>
      <blocks
        [blocks]="blocksToRender.blocks"
        [parent]="builderBlock?.id"
        [path]="blocksToRender.path"
      ></blocks>
    </div>
  `, standalone: true, imports: [CommonModule, Blocks, InlinedStyles, InlinedScript], styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { builderContext: [{
                type: Input
            }], attributes: [{
                type: Input
            }], builderBlock: [{
                type: Input
            }], variants: [{
                type: Input
            }], previewingIndex: [{
                type: Input
            }], rootRef: [{
                type: ViewChild,
                args: ["rootRef"]
            }], elRef0: [{
                type: ViewChild,
                args: ["elRef0"]
            }] } });

const componentInfo$d = {
    name: 'Core:Section',
    static: true,
    image: 'https://cdn.builder.io/api/v1/image/assets%2FIsxPKMo2gPRRKeakUztj1D6uqed2%2F682efef23ace49afac61748dd305c70a',
    inputs: [{
            name: 'maxWidth',
            type: 'number',
            defaultValue: 1200
        }, {
            name: 'lazyLoad',
            type: 'boolean',
            defaultValue: false,
            advanced: true,
            description: 'Only render this section when in view'
        }],
    defaultStyles: {
        paddingLeft: '20px',
        paddingRight: '20px',
        paddingTop: '50px',
        paddingBottom: '50px',
        marginTop: '0px',
        width: '100vw',
        marginLeft: 'calc(50% - 50vw)'
    },
    canHaveChildren: true,
    defaultChildren: [{
            '@type': '@builder.io/sdk:Element',
            responsiveStyles: {
                large: {
                    textAlign: 'center'
                }
            },
            component: {
                name: 'Text',
                options: {
                    text: "<p><b>I am a section! My content keeps from getting too wide, so that it's easy to read even on big screens.</b></p><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur</p>"
                }
            }
        }]
};

const componentInfo$c = {
    name: 'Slot',
    isRSC: true,
    description: 'Allow child blocks to be inserted into this content when used as a Symbol',
    docsLink: 'https://www.builder.io/c/docs/symbols-with-blocks',
    image: 'https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2F3aad6de36eae43b59b52c85190fdef56',
    // Maybe wrap this for canHaveChildren so bind children to this hm
    inputs: [{
            name: 'name',
            type: 'string',
            required: true,
            defaultValue: 'children'
        }],
    shouldReceiveBuilderProps: {
        builderContext: true,
        builderComponents: true
    }
};

class BuilderSlot {
    setAttributes(el, value, changes) {
        if (!el) {
            return;
        }
        const target = typeof changes === "undefined" ? value : changes;
        Object.keys(target).forEach((key) => {
            if (key.startsWith("on")) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace("on", "").toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key.toLowerCase(), target[key] ?? "");
            }
        });
    }
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
        this.node_0_div = null;
        this.node_1_div = null;
        this.node_2_Blocks = null;
        this.node_3_Blocks = null;
        this.node_4_Blocks = null;
    }
    ngOnInit() {
        this.node_0_div = {
            pointerEvents: "auto",
        };
        this.node_1_div = {
            ...(!this.builderContext.context?.symbolId && {
                "builder-slot": this.name,
            }),
        };
        this.node_2_Blocks = this.builderContext.context?.symbolId;
        this.node_3_Blocks = `symbol.data.${this.name}`;
        this.node_4_Blocks = this.builderContext.rootState?.[this.name];
    }
    ngAfterViewInit() {
        this.setAttributes(this.elRef0?.nativeElement, this.node_1_div);
    }
    ngOnChanges(changes) {
        if (typeof window !== "undefined") {
            this.node_0_div = {
                pointerEvents: "auto",
            };
            this.node_1_div = {
                ...(!this.builderContext.context?.symbolId && {
                    "builder-slot": this.name,
                }),
            };
            this.node_2_Blocks = this.builderContext.context?.symbolId;
            this.node_3_Blocks = `symbol.data.${this.name}`;
            this.node_4_Blocks = this.builderContext.rootState?.[this.name];
            this.setAttributes(this.elRef0?.nativeElement, this.node_1_div, changes["node_1_div"]?.currentValue);
        }
    }
    ngOnDestroy() {
        for (const fn of this._listenerFns.values()) {
            fn();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: BuilderSlot, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: BuilderSlot, isStandalone: true, selector: "builder-slot", inputs: { builderContext: "builderContext", name: "name", builderComponents: "builderComponents" }, viewQueries: [{ propertyName: "elRef0", first: true, predicate: ["elRef0"], descendants: true }], usesOnChanges: true, ngImport: i0, template: `
    <div [ngStyle]="node_0_div" #elRef0>
      <blocks
        [parent]="node_2_Blocks"
        [path]="node_3_Blocks"
        [context]="builderContext"
        [registeredComponents]="builderComponents"
        [blocks]="node_4_Blocks"
      ></blocks>
    </div>
  `, isInline: true, styles: [":host{display:contents}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "component", type: Blocks, selector: "blocks", inputs: ["blocks", "parent", "path", "styleProp", "className", "context", "linkComponent", "registeredComponents"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: BuilderSlot, decorators: [{
            type: Component,
            args: [{ selector: "builder-slot", template: `
    <div [ngStyle]="node_0_div" #elRef0>
      <blocks
        [parent]="node_2_Blocks"
        [path]="node_3_Blocks"
        [context]="builderContext"
        [registeredComponents]="builderComponents"
        [blocks]="node_4_Blocks"
      ></blocks>
    </div>
  `, standalone: true, imports: [CommonModule, Blocks], styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { builderContext: [{
                type: Input
            }], name: [{
                type: Input
            }], builderComponents: [{
                type: Input
            }], elRef0: [{
                type: ViewChild,
                args: ["elRef0"]
            }] } });

const componentInfo$b = {
    name: 'Symbol',
    noWrap: true,
    static: true,
    isRSC: true,
    inputs: [{
            name: 'symbol',
            type: 'uiSymbol'
        }, {
            name: 'dataOnly',
            helperText: "Make this a data symbol that doesn't display any UI",
            type: 'boolean',
            defaultValue: false,
            advanced: true,
            hideFromUI: true
        }, {
            name: 'inheritState',
            helperText: 'Inherit the parent component state and data',
            type: 'boolean',
            defaultValue: false,
            advanced: true
        }, {
            name: 'renderToLiquid',
            helperText: 'Render this symbols contents to liquid. Turn off to fetch with javascript and use custom targeting',
            type: 'boolean',
            defaultValue: false,
            advanced: true,
            hideFromUI: true
        }, {
            name: 'useChildren',
            hideFromUI: true,
            type: 'boolean'
        }],
    shouldReceiveBuilderProps: {
        builderBlock: true,
        builderContext: true,
        builderComponents: true,
        builderLinkComponent: true
    }
};

const defaultTab = {
    '@type': '@builder.io/sdk:Element',
    responsiveStyles: {
        large: {
            paddingLeft: '20px',
            paddingRight: '20px',
            paddingTop: '10px',
            paddingBottom: '10px',
            minWidth: '100px',
            textAlign: 'center',
            display: 'flex',
            flexDirection: 'column',
            cursor: 'pointer',
            userSelect: 'none'
        }
    },
    component: {
        name: 'Text',
        options: {
            text: 'New tab'
        }
    }
};
const defaultElement = {
    '@type': '@builder.io/sdk:Element',
    responsiveStyles: {
        large: {
            height: '200px',
            display: 'flex',
            marginTop: '20px',
            flexDirection: 'column'
        }
    },
    component: {
        name: 'Text',
        options: {
            text: 'New tab content '
        }
    }
};
const componentInfo$a = {
    name: 'Builder: Tabs',
    inputs: [{
            name: 'tabs',
            type: 'list',
            broadcast: true,
            subFields: [{
                    name: 'label',
                    type: 'uiBlocks',
                    hideFromUI: true,
                    defaultValue: [defaultTab]
                }, {
                    name: 'content',
                    type: 'uiBlocks',
                    hideFromUI: true,
                    defaultValue: [defaultElement]
                }],
            defaultValue: [{
                    label: [{
                            ...defaultTab,
                            component: {
                                name: 'Text',
                                options: {
                                    text: 'Tab 1'
                                }
                            }
                        }],
                    content: [{
                            ...defaultElement,
                            component: {
                                name: 'Text',
                                options: {
                                    text: 'Tab 1 content'
                                }
                            }
                        }]
                }, {
                    label: [{
                            ...defaultTab,
                            component: {
                                name: 'Text',
                                options: {
                                    text: 'Tab 2'
                                }
                            }
                        }],
                    content: [{
                            ...defaultElement,
                            component: {
                                name: 'Text',
                                options: {
                                    text: 'Tab 2 content'
                                }
                            }
                        }]
                }]
        }, {
            name: 'activeTabStyle',
            type: 'uiStyle',
            helperText: 'CSS styles for the active tab',
            defaultValue: {
                backgroundColor: 'rgba(0, 0, 0, 0.1)'
            }
        }, {
            name: 'defaultActiveTab',
            type: 'number',
            helperText: 'Default tab to open to. Set to "1" for the first tab, "2" for the second, or choose "0" for none',
            defaultValue: 1,
            advanced: true
        }, {
            name: 'collapsible',
            type: 'boolean',
            helperText: 'If on, clicking an open tab closes it so no tabs are active',
            defaultValue: false,
            advanced: true
        }, {
            name: 'tabHeaderLayout',
            type: 'enum',
            helperText: 'Change the layout of the tab headers (uses justify-content)',
            defaultValue: 'flex-start',
            enum: [{
                    label: 'Center',
                    value: 'center'
                }, {
                    label: 'Space between',
                    value: 'space-between'
                }, {
                    label: 'Space around',
                    value: 'space-around'
                }, {
                    label: 'Left',
                    value: 'flex-start'
                }, {
                    label: 'Right',
                    value: 'flex-end'
                }]
        }],
    shouldReceiveBuilderProps: {
        builderBlock: true,
        builderContext: true,
        builderComponents: true,
        builderLinkComponent: true
    }
};

class Tabs {
    constructor() {
        this.activeTab = null;
        this.node_0_div = null;
        this.node_1_span = (tab, index) => `builder-tab-wrap ${this.activeTab === index ? "builder-tab-active" : ""}`;
        this.node_2_span = (tab, index) => ({
            ...(this.activeTab === index ? this.activeTabStyle : {}),
        });
        this.node_4_Blocks = (tab, index) => `tabs.${index}.label`;
        this.node_5_Show = null;
        this.node_6_Blocks = null;
        this.node_7_Blocks = null;
    }
    activeTabContent(active) {
        return this.tabs && this.tabs[active].content;
    }
    onClick(index) {
        if (index === this.activeTab && this.collapsible) {
            this.activeTab = -1;
        }
        else {
            this.activeTab = index;
        }
    }
    trackByTab0(index, tab) {
        return index;
    }
    ngOnInit() {
        this.activeTab = this.defaultActiveTab ? this.defaultActiveTab - 1 : 0;
        this.node_0_div = {
            display: "flex",
            flexDirection: "row",
            justifyContent: this.tabHeaderLayout || "flex-start",
            overflow: "auto",
        };
        this.node_5_Show = this.activeTabContent(this.activeTab);
        this.node_6_Blocks = `tabs.${this.activeTab}.content`;
        this.node_7_Blocks = this.activeTabContent(this.activeTab);
    }
    ngOnChanges(changes) {
        if (typeof window !== "undefined") {
            this.node_0_div = {
                display: "flex",
                flexDirection: "row",
                justifyContent: this.tabHeaderLayout || "flex-start",
                overflow: "auto",
            };
            this.node_5_Show = this.activeTabContent(this.activeTab);
            this.node_6_Blocks = `tabs.${this.activeTab}.content`;
            this.node_7_Blocks = this.activeTabContent(this.activeTab);
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: Tabs, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: Tabs, isStandalone: true, selector: "tabs", inputs: { tabHeaderLayout: "tabHeaderLayout", defaultActiveTab: "defaultActiveTab", tabs: "tabs", collapsible: "collapsible", activeTabStyle: "activeTabStyle", builderBlock: "builderBlock", builderContext: "builderContext", builderComponents: "builderComponents", builderLinkComponent: "builderLinkComponent" }, usesOnChanges: true, ngImport: i0, template: `
    <div>
      <div class="builder-tabs-wrap" [ngStyle]="node_0_div">
        <ng-container
          *ngFor="let tab of tabs; index as index; trackBy: trackByTab0"
        >
          <span
            [class]="node_1_span(tab, index)"
            [ngStyle]="node_2_span(tab, index)"
            (click)="onClick(index)"
          >
            <blocks
              [parent]="builderBlock.id"
              [path]="node_4_Blocks(tab, index)"
              [blocks]="tab.label"
              [context]="builderContext"
              [registeredComponents]="builderComponents"
              [linkComponent]="builderLinkComponent"
            ></blocks>
          </span>
        </ng-container>
      </div>
      <ng-container *ngIf="node_5_Show">
        <div>
          <blocks
            [parent]="builderBlock.id"
            [path]="node_6_Blocks"
            [blocks]="node_7_Blocks"
            [context]="builderContext"
            [registeredComponents]="builderComponents"
            [linkComponent]="builderLinkComponent"
          ></blocks>
        </div>
      </ng-container>
    </div>
  `, isInline: true, styles: [":host{display:contents}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "component", type: Blocks, selector: "blocks", inputs: ["blocks", "parent", "path", "styleProp", "className", "context", "linkComponent", "registeredComponents"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: Tabs, decorators: [{
            type: Component,
            args: [{ selector: "tabs", template: `
    <div>
      <div class="builder-tabs-wrap" [ngStyle]="node_0_div">
        <ng-container
          *ngFor="let tab of tabs; index as index; trackBy: trackByTab0"
        >
          <span
            [class]="node_1_span(tab, index)"
            [ngStyle]="node_2_span(tab, index)"
            (click)="onClick(index)"
          >
            <blocks
              [parent]="builderBlock.id"
              [path]="node_4_Blocks(tab, index)"
              [blocks]="tab.label"
              [context]="builderContext"
              [registeredComponents]="builderComponents"
              [linkComponent]="builderLinkComponent"
            ></blocks>
          </span>
        </ng-container>
      </div>
      <ng-container *ngIf="node_5_Show">
        <div>
          <blocks
            [parent]="builderBlock.id"
            [path]="node_6_Blocks"
            [blocks]="node_7_Blocks"
            [context]="builderContext"
            [registeredComponents]="builderComponents"
            [linkComponent]="builderLinkComponent"
          ></blocks>
        </div>
      </ng-container>
    </div>
  `, standalone: true, imports: [CommonModule, Blocks], styles: [":host{display:contents}\n"] }]
        }], propDecorators: { tabHeaderLayout: [{
                type: Input
            }], defaultActiveTab: [{
                type: Input
            }], tabs: [{
                type: Input
            }], collapsible: [{
                type: Input
            }], activeTabStyle: [{
                type: Input
            }], builderBlock: [{
                type: Input
            }], builderContext: [{
                type: Input
            }], builderComponents: [{
                type: Input
            }], builderLinkComponent: [{
                type: Input
            }] } });

const componentInfo$9 = {
    shouldReceiveBuilderProps: {
        builderBlock: TARGET === 'reactNative' ? true : false,
        builderContext: true
    },
    name: 'Text',
    static: true,
    isRSC: true,
    image: 'https://firebasestorage.googleapis.com/v0/b/builder-3b0a2.appspot.com/o/images%2Fbaseline-text_fields-24px%20(1).svg?alt=media&token=12177b73-0ee3-42ca-98c6-0dd003de1929',
    inputs: [{
            name: 'text',
            type: 'html',
            required: true,
            autoFocus: true,
            bubble: true,
            defaultValue: 'Enter some text...'
        }],
    defaultStyles: {
        lineHeight: 'normal',
        height: 'auto',
        textAlign: 'center'
    }
};

class BuilderText {
    ngOnInit() {
        this.node_0_div = this.text?.toString() || "";
        this.node_1_div = {
            outline: "none",
        };
    }
    constructor(sanitizer) {
        this.sanitizer = sanitizer;
        this.node_0_div = null;
        this.node_1_div = null;
    }
    ngOnChanges(changes) {
        if (typeof window !== "undefined") {
            this.node_0_div = this.text?.toString() || "";
            this.node_1_div = {
                outline: "none",
            };
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: BuilderText, deps: [{ token: i1$1.DomSanitizer }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: BuilderText, isStandalone: true, selector: "builder-text", inputs: { text: "text" }, usesOnChanges: true, ngImport: i0, template: `
    <div
      class="builder-text"
      [innerHTML]="sanitizer.bypassSecurityTrustHtml(node_0_div)"
      [ngStyle]="node_1_div"
    ></div>
  `, isInline: true, styles: [":host{display:contents}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: BuilderText, decorators: [{
            type: Component,
            args: [{ changeDetection: ChangeDetectionStrategy.OnPush, selector: "builder-text", template: `
    <div
      class="builder-text"
      [innerHTML]="sanitizer.bypassSecurityTrustHtml(node_0_div)"
      [ngStyle]="node_1_div"
    ></div>
  `, standalone: true, imports: [CommonModule], styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i1$1.DomSanitizer }]; }, propDecorators: { text: [{
                type: Input
            }] } });

const componentInfo$8 = {
    name: 'Custom Code',
    static: true,
    requiredPermissions: ['editCode'],
    inputs: [{
            name: 'code',
            type: 'html',
            required: true,
            defaultValue: '<p>Hello there, I am custom HTML code!</p>',
            code: true
        }, {
            name: 'replaceNodes',
            type: 'boolean',
            helperText: 'Preserve server rendered dom nodes',
            advanced: true
        }, {
            name: 'scriptsClientOnly',
            type: 'boolean',
            defaultValue: false,
            helperText: 'Only print and run scripts on the client. Important when scripts influence DOM that could be replaced when client loads',
            advanced: true
        }]
};

class CustomCode {
    ngOnInit() {
        this.node_0_div =
            "builder-custom-code" + (this.replaceNodes ? " replace-nodes" : "");
        if (typeof window !== "undefined") {
            // TODO: Move this function to standalone one in '@builder.io/utils'
            if (!this.elementRef.nativeElement?.getElementsByTagName ||
                typeof window === "undefined") {
                return;
            }
            const scripts = this.elementRef.nativeElement.getElementsByTagName("script");
            for (let i = 0; i < scripts.length; i++) {
                const script = scripts[i];
                if (script.src) {
                    if (this.scriptsInserted.includes(script.src)) {
                        continue;
                    }
                    this.scriptsInserted.push(script.src);
                    const newScript = document.createElement("script");
                    newScript.async = true;
                    newScript.src = script.src;
                    document.head.appendChild(newScript);
                }
                else if (!script.type ||
                    [
                        "text/javascript",
                        "application/javascript",
                        "application/ecmascript",
                    ].includes(script.type)) {
                    if (this.scriptsRun.includes(script.innerText)) {
                        continue;
                    }
                    try {
                        this.scriptsRun.push(script.innerText);
                        new Function(script.innerText)();
                    }
                    catch (error) {
                        console.warn("`CustomCode`: Error running script:", error);
                    }
                }
            }
        }
    }
    constructor(sanitizer) {
        this.sanitizer = sanitizer;
        this.scriptsInserted = [];
        this.scriptsRun = [];
        this.node_0_div = null;
    }
    ngOnChanges(changes) {
        if (typeof window !== "undefined") {
            this.node_0_div =
                "builder-custom-code" + (this.replaceNodes ? " replace-nodes" : "");
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: CustomCode, deps: [{ token: i1$1.DomSanitizer }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: CustomCode, isStandalone: true, selector: "custom-code", inputs: { replaceNodes: "replaceNodes", code: "code" }, viewQueries: [{ propertyName: "elementRef", first: true, predicate: ["elementRef"], descendants: true }], usesOnChanges: true, ngImport: i0, template: `
    <div #elementRef [class]="node_0_div" [innerHTML]="sanitizer.bypassSecurityTrustHtml(code)"></div>
  `, isInline: true, styles: [":host{display:contents}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: CustomCode, decorators: [{
            type: Component,
            args: [{ changeDetection: ChangeDetectionStrategy.OnPush, selector: "custom-code", template: `
    <div #elementRef [class]="node_0_div" [innerHTML]="sanitizer.bypassSecurityTrustHtml(code)"></div>
  `, standalone: true, imports: [CommonModule], styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i1$1.DomSanitizer }]; }, propDecorators: { replaceNodes: [{
                type: Input
            }], code: [{
                type: Input
            }], elementRef: [{
                type: ViewChild,
                args: ["elementRef"]
            }] } });

const componentInfo$7 = {
    name: 'Embed',
    static: true,
    inputs: [{
            name: 'url',
            type: 'url',
            required: true,
            defaultValue: '',
            helperText: 'e.g. enter a youtube url, google map, etc'
        }, {
            name: 'content',
            type: 'html',
            defaultValue: '<div style="padding: 20px; text-align: center">(Choose an embed URL)<div>',
            hideFromUI: true
        }]
};

const SCRIPT_MIME_TYPES = ['text/javascript', 'application/javascript', 'application/ecmascript'];
const isJsScript = (script) => SCRIPT_MIME_TYPES.includes(script.type);

class BuilderEmbed {
    findAndRunScripts() {
        if (!this.elem.nativeElement ||
            !this.elem.nativeElement.getElementsByTagName)
            return;
        const scripts = this.elem.nativeElement.getElementsByTagName("script");
        for (let i = 0; i < scripts.length; i++) {
            const script = scripts[i];
            if (script.src && !this.scriptsInserted.includes(script.src)) {
                this.scriptsInserted.push(script.src);
                const newScript = document.createElement("script");
                newScript.async = true;
                newScript.src = script.src;
                document.head.appendChild(newScript);
            }
            else if (isJsScript(script) &&
                !this.scriptsRun.includes(script.innerText)) {
                try {
                    this.scriptsRun.push(script.innerText);
                    new Function(script.innerText)();
                }
                catch (error) {
                    console.warn("`Embed`: Error running script:", error);
                }
            }
        }
    }
    constructor(sanitizer) {
        this.sanitizer = sanitizer;
        this.scriptsInserted = [];
        this.scriptsRun = [];
        this.ranInitFn = false;
    }
    ngOnChanges(changes) {
        if (typeof window !== "undefined") {
            if (this.elem.nativeElement && !this.ranInitFn) {
                this.ranInitFn = true;
                this.findAndRunScripts();
            }
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: BuilderEmbed, deps: [{ token: i1$1.DomSanitizer }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: BuilderEmbed, isStandalone: true, selector: "builder-embed", inputs: { content: "content" }, viewQueries: [{ propertyName: "elem", first: true, predicate: ["elem"], descendants: true }], usesOnChanges: true, ngImport: i0, template: `
    <div class="builder-embed" #elem [innerHTML]="sanitizer.bypassSecurityTrustHtml(content)"></div>
  `, isInline: true, styles: [":host{display:contents}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: BuilderEmbed, decorators: [{
            type: Component,
            args: [{ changeDetection: ChangeDetectionStrategy.OnPush, selector: "builder-embed", template: `
    <div class="builder-embed" #elem [innerHTML]="sanitizer.bypassSecurityTrustHtml(content)"></div>
  `, standalone: true, imports: [CommonModule], styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i1$1.DomSanitizer }]; }, propDecorators: { content: [{
                type: Input
            }], elem: [{
                type: ViewChild,
                args: ["elem"]
            }] } });

const componentInfo$6 = {
    name: 'Form:Form',
    // editableTags: ['builder-form-error']
    defaults: {
        responsiveStyles: {
            large: {
                marginTop: '15px',
                paddingBottom: '15px'
            }
        }
    },
    image: 'https://cdn.builder.io/api/v1/image/assets%2FIsxPKMo2gPRRKeakUztj1D6uqed2%2Fef36d2a846134910b64b88e6d18c5ca5',
    inputs: [{
            name: 'sendSubmissionsTo',
            type: 'string',
            // TODO: save to builder data and user can download as csv
            // TODO: easy for mode too or computed add/remove fields form mode
            // so you can edit details and high level mode at same time...
            // Later - more integrations like mailchimp
            // /api/v1/form-submit?to=mailchimp
            enum: [{
                    label: 'Send to email',
                    value: 'email',
                    helperText: 'Send form submissions to the email address of your choosing'
                }, {
                    label: 'Custom',
                    value: 'custom',
                    helperText: 'Handle where the form requests go manually with a little code, e.g. to your own custom backend'
                }],
            defaultValue: 'email'
        }, {
            name: 'sendSubmissionsToEmail',
            type: 'string',
            required: true,
            // TODO: required: () => options.get("sendSubmissionsTo") === "email"
            defaultValue: 'your@email.com',
            showIf: 'options.get("sendSubmissionsTo") === "email"'
        }, {
            name: 'sendWithJs',
            type: 'boolean',
            helperText: 'Set to false to use basic html form action',
            defaultValue: true,
            showIf: 'options.get("sendSubmissionsTo") === "custom"'
        }, {
            name: 'name',
            type: 'string',
            defaultValue: 'My form'
            // advanced: true
        }, {
            name: 'action',
            type: 'string',
            helperText: 'URL to send the form data to',
            showIf: 'options.get("sendSubmissionsTo") === "custom"'
        }, {
            name: 'contentType',
            type: 'string',
            defaultValue: 'application/json',
            advanced: true,
            // TODO: do automatically if file input
            enum: ['application/json', 'multipart/form-data', 'application/x-www-form-urlencoded'],
            showIf: 'options.get("sendSubmissionsTo") === "custom" && options.get("sendWithJs") === true'
        }, {
            name: 'method',
            type: 'string',
            showIf: 'options.get("sendSubmissionsTo") === "custom"',
            defaultValue: 'POST',
            advanced: true
        }, {
            name: 'previewState',
            type: 'string',
            // TODO: persist: false flag
            enum: ['unsubmitted', 'sending', 'success', 'error'],
            defaultValue: 'unsubmitted',
            helperText: 'Choose a state to edit, e.g. choose "success" to show what users see on success and edit the message',
            showIf: 'options.get("sendSubmissionsTo") !== "zapier" && options.get("sendWithJs") === true'
        }, {
            name: 'successUrl',
            type: 'url',
            helperText: 'Optional URL to redirect the user to on form submission success',
            showIf: 'options.get("sendSubmissionsTo") !== "zapier" && options.get("sendWithJs") === true'
        }, {
            name: 'resetFormOnSubmit',
            type: 'boolean',
            showIf: "options.get('sendSubmissionsTo') === 'custom' && options.get('sendWithJs') === true",
            advanced: true
        }, {
            name: 'successMessage',
            type: 'uiBlocks',
            hideFromUI: true,
            defaultValue: [{
                    '@type': '@builder.io/sdk:Element',
                    responsiveStyles: {
                        large: {
                            marginTop: '10px'
                        }
                    },
                    component: {
                        name: 'Text',
                        options: {
                            text: '<span>Thanks!</span>'
                        }
                    }
                }]
        }, {
            name: 'validate',
            type: 'boolean',
            defaultValue: true,
            advanced: true
        }, {
            name: 'errorMessagePath',
            type: 'text',
            advanced: true,
            helperText: 'Path to where to get the error message from in a JSON response to display to the user, e.g. "error.message" for a response like { "error": { "message": "this username is taken" }}'
        }, {
            name: 'errorMessage',
            type: 'uiBlocks',
            hideFromUI: true,
            defaultValue: [{
                    '@type': '@builder.io/sdk:Element',
                    responsiveStyles: {
                        large: {
                            marginTop: '10px'
                        }
                    },
                    bindings: {
                        'component.options.text': 'state.formErrorMessage || block.component.options.text'
                    },
                    component: {
                        name: 'Text',
                        options: {
                            text: '<span>Form submission error :( Please check your answers and try again</span>'
                        }
                    }
                }]
        }, {
            name: 'sendingMessage',
            type: 'uiBlocks',
            hideFromUI: true,
            defaultValue: [{
                    '@type': '@builder.io/sdk:Element',
                    responsiveStyles: {
                        large: {
                            marginTop: '10px'
                        }
                    },
                    component: {
                        name: 'Text',
                        options: {
                            text: '<span>Sending...</span>'
                        }
                    }
                }]
        }, {
            name: 'customHeaders',
            type: 'map',
            valueType: {
                type: 'string'
            },
            advanced: true,
            showIf: 'options.get("sendSubmissionsTo") === "custom" && options.get("sendWithJs") === true'
        }],
    noWrap: true,
    canHaveChildren: true,
    defaultChildren: [{
            '@type': '@builder.io/sdk:Element',
            responsiveStyles: {
                large: {
                    marginTop: '10px'
                }
            },
            component: {
                name: 'Text',
                options: {
                    text: '<span>Enter your name</span>'
                }
            }
        }, {
            '@type': '@builder.io/sdk:Element',
            responsiveStyles: {
                large: {
                    marginTop: '10px'
                }
            },
            component: {
                name: 'Form:Input',
                options: {
                    name: 'name',
                    placeholder: 'Jane Doe'
                }
            }
        }, {
            '@type': '@builder.io/sdk:Element',
            responsiveStyles: {
                large: {
                    marginTop: '10px'
                }
            },
            component: {
                name: 'Text',
                options: {
                    text: '<span>Enter your email</span>'
                }
            }
        }, {
            '@type': '@builder.io/sdk:Element',
            responsiveStyles: {
                large: {
                    marginTop: '10px'
                }
            },
            component: {
                name: 'Form:Input',
                options: {
                    name: 'email',
                    placeholder: 'jane@doe.com'
                }
            }
        }, {
            '@type': '@builder.io/sdk:Element',
            responsiveStyles: {
                large: {
                    marginTop: '10px'
                }
            },
            component: {
                name: 'Form:SubmitButton',
                options: {
                    text: 'Submit'
                }
            }
        }],
    shouldReceiveBuilderProps: {
        builderBlock: true,
        builderContext: true,
        builderComponents: true,
        builderLinkComponent: true
    }
};

const validEnvList = ['production', 'qa', 'test', 'development', 'dev', 'cdn-qa', 'cloud', 'fast', 'cdn2', 'cdn-prod'];
const getEnv = () => {
    const env = process.env.NODE_ENV || 'production';
    return validEnvList.includes(env) ? env : 'production';
};

function logFetch(url) {
    if (typeof process !== 'undefined' && process.env?.DEBUG) {
        if (String(process.env.DEBUG) == 'true') {
            logger.log(url);
        }
    }
}

class FormComponent {
    mergeNewRootState(newData) {
        const combinedState = {
            ...this.builderContext.rootState,
            ...newData,
        };
        if (this.builderContext.rootSetState) {
            this.builderContext.rootSetState?.(combinedState);
        }
        else {
            this.builderContext.rootState = combinedState;
        }
    }
    submissionState() {
        return (isEditing() && this.previewState) || this.formState;
    }
    onSubmit(event) {
        const sendWithJsProp = this.sendWithJs || this.sendSubmissionsTo === "email";
        if (this.sendSubmissionsTo === "zapier") {
            event.preventDefault();
        }
        else if (sendWithJsProp) {
            if (!(this.action || this.sendSubmissionsTo === "email")) {
                event.preventDefault();
                return;
            }
            event.preventDefault();
            const el = event.currentTarget || event.target;
            const headers = this.customHeaders || {};
            let body;
            const formData = new FormData(el);
            // TODO: maybe support null
            const formPairs = Array.from(el.querySelectorAll("input,select,textarea"))
                .filter((el) => !!el.name)
                .map((el) => {
                let value;
                const key = el.name;
                if (el instanceof HTMLInputElement) {
                    if (el.type === "radio") {
                        if (el.checked) {
                            value = el.name;
                            return {
                                key,
                                value,
                            };
                        }
                    }
                    else if (el.type === "checkbox") {
                        value = el.checked;
                    }
                    else if (el.type === "number" || el.type === "range") {
                        const num = el.valueAsNumber;
                        if (!isNaN(num)) {
                            value = num;
                        }
                    }
                    else if (el.type === "file") {
                        // TODO: one vs multiple files
                        value = el.files;
                    }
                    else {
                        value = el.value;
                    }
                }
                else {
                    value = el.value;
                }
                return {
                    key,
                    value,
                };
            });
            let formContentType = this.contentType;
            if (this.sendSubmissionsTo === "email") {
                formContentType = "multipart/form-data";
            }
            Array.from(formPairs).forEach(({ value }) => {
                if (value instanceof File ||
                    (Array.isArray(value) && value[0] instanceof File) ||
                    value instanceof FileList) {
                    formContentType = "multipart/form-data";
                }
            });
            // TODO: send as urlEncoded or multipart by default
            // because of ease of use and reliability in browser API
            // for encoding the form?
            if (formContentType !== "application/json") {
                body = formData;
            }
            else {
                // Json
                const json = {};
                Array.from(formPairs).forEach(({ value, key }) => {
                    set(json, key, value);
                });
                body = JSON.stringify(json);
            }
            if (formContentType && formContentType !== "multipart/form-data") {
                if (
                /* Zapier doesn't allow content-type header to be sent from browsers */
                !(sendWithJsProp && this.action?.includes("zapier.com"))) {
                    headers["content-type"] = formContentType;
                }
            }
            const presubmitEvent = new CustomEvent("presubmit", {
                detail: {
                    body,
                },
            });
            if (this.formRef.nativeElement) {
                this.formRef.nativeElement.dispatchEvent(presubmitEvent);
                if (presubmitEvent.defaultPrevented) {
                    return;
                }
            }
            this.formState = "sending";
            const formUrl = `${getEnv() === "dev" ? "http://localhost:5000" : "https://builder.io"}/api/v1/form-submit?apiKey=${this.builderContext.apiKey}&to=${btoa(this.sendSubmissionsToEmail || "")}&name=${encodeURIComponent(this.name || "")}`;
            const url = this.sendSubmissionsTo === "email"
                ? formUrl
                : this.action; /* TODO: throw error if no action URL */
            logFetch(url);
            fetch(url, {
                body,
                headers,
                method: this.method || "post",
            }).then(async (res) => {
                let body;
                const contentType = res.headers.get("content-type");
                if (contentType && contentType.indexOf("application/json") !== -1) {
                    body = await res.json();
                }
                else {
                    body = await res.text();
                }
                if (!res.ok && this.errorMessagePath) {
                    /* TODO: allow supplying an error formatter function */
                    let message = get(body, this.errorMessagePath);
                    if (message) {
                        if (typeof message !== "string") {
                            /* TODO: ideally convert json to yaml so it woul dbe like
                        error: - email has been taken */
                            message = JSON.stringify(message);
                        }
                        this.formErrorMessage = message;
                        this.mergeNewRootState({
                            formErrorMessage: message,
                        });
                    }
                }
                this.responseData = body;
                this.formState = res.ok ? "success" : "error";
                if (res.ok) {
                    const submitSuccessEvent = new CustomEvent("submit:success", {
                        detail: {
                            res,
                            body,
                        },
                    });
                    if (this.formRef.nativeElement) {
                        this.formRef.nativeElement.dispatchEvent(submitSuccessEvent);
                        if (submitSuccessEvent.defaultPrevented) {
                            return;
                        }
                        /* TODO: option to turn this on/off? */
                        if (this.resetFormOnSubmit !== false) {
                            this.formRef.nativeElement.reset();
                        }
                    }
                    /* TODO: client side route event first that can be preventDefaulted */
                    if (this.successUrl) {
                        if (this.formRef.nativeElement) {
                            const event = new CustomEvent("route", {
                                detail: {
                                    url: this.successUrl,
                                },
                            });
                            this.formRef.nativeElement.dispatchEvent(event);
                            if (!event.defaultPrevented) {
                                location.href = this.successUrl;
                            }
                        }
                        else {
                            location.href = this.successUrl;
                        }
                    }
                }
            }, (err) => {
                const submitErrorEvent = new CustomEvent("submit:error", {
                    detail: {
                        error: err,
                    },
                });
                if (this.formRef.nativeElement) {
                    this.formRef.nativeElement.dispatchEvent(submitErrorEvent);
                    if (submitErrorEvent.defaultPrevented) {
                        return;
                    }
                }
                this.responseData = err;
                this.formState = "error";
            });
        }
    }
    setAttributes(el, value, changes) {
        if (!el) {
            return;
        }
        const target = typeof changes === "undefined" ? value : changes;
        Object.keys(target).forEach((key) => {
            if (key.startsWith("on")) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace("on", "").toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key.toLowerCase(), target[key] ?? "");
            }
        });
    }
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
        this.formState = "unsubmitted";
        this.responseData = null;
        this.formErrorMessage = "";
        this.node_1_Show = null;
        this.node_2_Show = null;
        this.node_3_Show = null;
        this.node_4_div = null;
        this.node_5_Show = null;
        this.elRef0_state_0 = null;
        this.elRef0_state_1 = null;
    }
    ngOnInit() {
        this.node_1_Show = this.submissionState() === "error";
        this.node_2_Show = this.submissionState() === "sending";
        this.node_3_Show = this.submissionState() === "error" && this.responseData;
        this.node_4_div = JSON.stringify(this.responseData, null, 2);
        this.node_5_Show = this.submissionState() === "success";
        this.elRef0_state_0 = {};
        this.elRef0_state_1 = {};
    }
    ngAfterViewInit() {
        this.setAttributes(this.elRef0?.nativeElement, this.elRef0_state_0);
        this.setAttributes(this.elRef0?.nativeElement, this.elRef0_state_1);
        this.setAttributes(this.elRef0?.nativeElement, this.attributes);
    }
    ngOnChanges(changes) {
        if (typeof window !== "undefined") {
            this.node_1_Show = this.submissionState() === "error";
            this.node_2_Show = this.submissionState() === "sending";
            this.node_3_Show =
                this.submissionState() === "error" && this.responseData;
            this.node_4_div = JSON.stringify(this.responseData, null, 2);
            this.node_5_Show = this.submissionState() === "success";
            this.elRef0_state_0 = {};
            this.setAttributes(this.elRef0?.nativeElement, this.elRef0_state_0, changes["elRef0_state_0"]?.currentValue);
            this.elRef0_state_1 = {};
            this.setAttributes(this.elRef0?.nativeElement, this.elRef0_state_1, changes["elRef0_state_1"]?.currentValue);
            this.setAttributes(this.elRef0?.nativeElement, this.attributes, changes["attributes"]?.currentValue);
        }
    }
    ngOnDestroy() {
        for (const fn of this._listenerFns.values()) {
            fn();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FormComponent, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: FormComponent, isStandalone: true, selector: "form-component", inputs: { builderContext: "builderContext", previewState: "previewState", sendWithJs: "sendWithJs", sendSubmissionsTo: "sendSubmissionsTo", action: "action", customHeaders: "customHeaders", contentType: "contentType", sendSubmissionsToEmail: "sendSubmissionsToEmail", name: "name", method: "method", errorMessagePath: "errorMessagePath", resetFormOnSubmit: "resetFormOnSubmit", successUrl: "successUrl", validate: "validate", attributes: "attributes", errorMessage: "errorMessage", sendingMessage: "sendingMessage", successMessage: "successMessage" }, viewQueries: [{ propertyName: "formRef", first: true, predicate: ["formRef"], descendants: true }, { propertyName: "elRef0", first: true, predicate: ["elRef0"], descendants: true }], usesOnChanges: true, ngImport: i0, template: `
    <form
      [attr.validate]="validate"
      #formRef
      [attr.action]="!sendWithJs && action"
      [attr.method]="method"
      [attr.name]="name"
      (submit)="onSubmit($event)"
      #elRef0
    >
      <ng-content></ng-content>
      <ng-container *ngIf="node_1_Show">
        <blocks
          path="errorMessage"
          [blocks]="errorMessage!"
          [context]="builderContext"
        ></blocks>
      </ng-container>
      <ng-container *ngIf="node_2_Show">
        <blocks
          path="sendingMessage"
          [blocks]="sendingMessage!"
          [context]="builderContext"
        ></blocks>
      </ng-container>
      <ng-container *ngIf="node_3_Show">
        <pre class="builder-form-error-text pre">{{node_4_div}}</pre>
      </ng-container>
      <ng-container *ngIf="node_5_Show">
        <blocks
          path="successMessage"
          [blocks]="successMessage!"
          [context]="builderContext"
        ></blocks>
      </ng-container>
    </form>
  `, isInline: true, styles: [":host{display:contents}.pre{padding:10px;color:red;text-align:center}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: Blocks, selector: "blocks", inputs: ["blocks", "parent", "path", "styleProp", "className", "context", "linkComponent", "registeredComponents"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FormComponent, decorators: [{
            type: Component,
            args: [{ selector: "form-component", template: `
    <form
      [attr.validate]="validate"
      #formRef
      [attr.action]="!sendWithJs && action"
      [attr.method]="method"
      [attr.name]="name"
      (submit)="onSubmit($event)"
      #elRef0
    >
      <ng-content></ng-content>
      <ng-container *ngIf="node_1_Show">
        <blocks
          path="errorMessage"
          [blocks]="errorMessage!"
          [context]="builderContext"
        ></blocks>
      </ng-container>
      <ng-container *ngIf="node_2_Show">
        <blocks
          path="sendingMessage"
          [blocks]="sendingMessage!"
          [context]="builderContext"
        ></blocks>
      </ng-container>
      <ng-container *ngIf="node_3_Show">
        <pre class="builder-form-error-text pre">{{node_4_div}}</pre>
      </ng-container>
      <ng-container *ngIf="node_5_Show">
        <blocks
          path="successMessage"
          [blocks]="successMessage!"
          [context]="builderContext"
        ></blocks>
      </ng-container>
    </form>
  `, standalone: true, imports: [CommonModule, Blocks], styles: [":host{display:contents}.pre{padding:10px;color:red;text-align:center}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { builderContext: [{
                type: Input
            }], previewState: [{
                type: Input
            }], sendWithJs: [{
                type: Input
            }], sendSubmissionsTo: [{
                type: Input
            }], action: [{
                type: Input
            }], customHeaders: [{
                type: Input
            }], contentType: [{
                type: Input
            }], sendSubmissionsToEmail: [{
                type: Input
            }], name: [{
                type: Input
            }], method: [{
                type: Input
            }], errorMessagePath: [{
                type: Input
            }], resetFormOnSubmit: [{
                type: Input
            }], successUrl: [{
                type: Input
            }], validate: [{
                type: Input
            }], attributes: [{
                type: Input
            }], errorMessage: [{
                type: Input
            }], sendingMessage: [{
                type: Input
            }], successMessage: [{
                type: Input
            }], formRef: [{
                type: ViewChild,
                args: ["formRef"]
            }], elRef0: [{
                type: ViewChild,
                args: ["elRef0"]
            }] } });

const componentInfo$5 = {
    name: 'Form:Input',
    image: 'https://cdn.builder.io/api/v1/image/assets%2FIsxPKMo2gPRRKeakUztj1D6uqed2%2Fad6f37889d9e40bbbbc72cdb5875d6ca',
    inputs: [{
            name: 'type',
            type: 'text',
            enum: ['text', 'number', 'email', 'url', 'checkbox', 'radio', 'range', 'date', 'datetime-local', 'search', 'tel', 'time', 'file', 'month', 'week', 'password', 'color', 'hidden'],
            defaultValue: 'text'
        }, {
            name: 'name',
            type: 'string',
            required: true,
            helperText: 'Every input in a form needs a unique name describing what it takes, e.g. "email"'
        }, {
            name: 'placeholder',
            type: 'string',
            defaultValue: 'Hello there',
            helperText: 'Text to display when there is no value'
        },
        // TODO: handle value vs default value automatically like ng-model
        {
            name: 'defaultValue',
            type: 'string'
        }, {
            name: 'value',
            type: 'string',
            advanced: true
        }, {
            name: 'required',
            type: 'boolean',
            helperText: 'Is this input required to be filled out to submit a form',
            defaultValue: false
        }],
    noWrap: true,
    static: true,
    defaultStyles: {
        paddingTop: '10px',
        paddingBottom: '10px',
        paddingLeft: '10px',
        paddingRight: '10px',
        borderRadius: '3px',
        borderWidth: '1px',
        borderStyle: 'solid',
        borderColor: '#ccc'
    }
};

class FormInputComponent {
    setAttributes(el, value, changes) {
        if (!el) {
            return;
        }
        const target = typeof changes === "undefined" ? value : changes;
        Object.keys(target).forEach((key) => {
            if (key.startsWith("on")) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace("on", "").toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key.toLowerCase(), target[key] ?? "");
            }
        });
    }
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
        this.node_0_input = null;
        this.elRef0_state_0 = null;
    }
    ngOnInit() {
        this.node_0_input =
            isEditing() && this.defaultValue ? this.defaultValue : "default-key";
        this.elRef0_state_0 = {};
    }
    ngAfterViewInit() {
        this.setAttributes(this.elRef0?.nativeElement, this.elRef0_state_0);
        this.setAttributes(this.elRef0?.nativeElement, this.attributes);
    }
    ngOnChanges(changes) {
        if (typeof window !== "undefined") {
            this.node_0_input =
                isEditing() && this.defaultValue ? this.defaultValue : "default-key";
            this.elRef0_state_0 = {};
            this.setAttributes(this.elRef0?.nativeElement, this.elRef0_state_0, changes["elRef0_state_0"]?.currentValue);
            this.setAttributes(this.elRef0?.nativeElement, this.attributes, changes["attributes"]?.currentValue);
        }
    }
    ngOnDestroy() {
        for (const fn of this._listenerFns.values()) {
            fn();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FormInputComponent, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: FormInputComponent, isStandalone: true, selector: "form-input-component", inputs: { defaultValue: "defaultValue", attributes: "attributes", placeholder: "placeholder", type: "type", name: "name", value: "value", required: "required" }, viewQueries: [{ propertyName: "elRef0", first: true, predicate: ["elRef0"], descendants: true }], usesOnChanges: true, ngImport: i0, template: `
    <input
      [attr.placeholder]="placeholder"
      [attr.type]="type"
      [attr.name]="name"
      [attr.value]="value"
      [attr.defaultValue]="defaultValue"
      [attr.required]="required"
      #elRef0
    />
  `, isInline: true, styles: [":host{display:contents}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FormInputComponent, decorators: [{
            type: Component,
            args: [{ selector: "form-input-component", template: `
    <input
      [attr.placeholder]="placeholder"
      [attr.type]="type"
      [attr.name]="name"
      [attr.value]="value"
      [attr.defaultValue]="defaultValue"
      [attr.required]="required"
      #elRef0
    />
  `, standalone: true, imports: [CommonModule], styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { defaultValue: [{
                type: Input
            }], attributes: [{
                type: Input
            }], placeholder: [{
                type: Input
            }], type: [{
                type: Input
            }], name: [{
                type: Input
            }], value: [{
                type: Input
            }], required: [{
                type: Input
            }], elRef0: [{
                type: ViewChild,
                args: ["elRef0"]
            }] } });

const componentInfo$4 = {
    name: 'Form:Select',
    image: 'https://cdn.builder.io/api/v1/image/assets%2FIsxPKMo2gPRRKeakUztj1D6uqed2%2F83acca093fb24aaf94dee136e9a4b045',
    defaultStyles: {
        alignSelf: 'flex-start'
    },
    inputs: [{
            name: 'options',
            type: 'list',
            required: true,
            subFields: [{
                    name: 'value',
                    type: 'text',
                    required: true
                }, {
                    name: 'name',
                    type: 'text'
                }],
            defaultValue: [{
                    value: 'option 1'
                }, {
                    value: 'option 2'
                }]
        }, {
            name: 'name',
            type: 'string',
            required: true,
            helperText: 'Every select in a form needs a unique name describing what it gets, e.g. "email"'
        }, {
            name: 'defaultValue',
            type: 'string'
        }, {
            name: 'value',
            type: 'string',
            advanced: true
        }, {
            name: 'required',
            type: 'boolean',
            defaultValue: false
        }],
    static: true,
    noWrap: true
};

class SelectComponent {
    setAttributes(el, value, changes) {
        if (!el) {
            return;
        }
        const target = typeof changes === "undefined" ? value : changes;
        Object.keys(target).forEach((key) => {
            if (key.startsWith("on")) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace("on", "").toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key.toLowerCase(), target[key] ?? "");
            }
        });
    }
    trackByOption0(index, option) {
        return `${option.name}-${index}`;
    }
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
        this.node_0_select = null;
        this.elRef0_state_0 = null;
    }
    ngOnInit() {
        this.node_0_select =
            isEditing() && this.defaultValue ? this.defaultValue : "default-key";
        this.elRef0_state_0 = {};
    }
    ngAfterViewInit() {
        this.setAttributes(this.elRef0?.nativeElement, this.elRef0_state_0);
        this.setAttributes(this.elRef0?.nativeElement, this.attributes);
    }
    ngOnChanges(changes) {
        if (typeof window !== "undefined") {
            this.node_0_select =
                isEditing() && this.defaultValue ? this.defaultValue : "default-key";
            this.elRef0_state_0 = {};
            this.setAttributes(this.elRef0?.nativeElement, this.elRef0_state_0, changes["elRef0_state_0"]?.currentValue);
            this.setAttributes(this.elRef0?.nativeElement, this.attributes, changes["attributes"]?.currentValue);
        }
    }
    ngOnDestroy() {
        for (const fn of this._listenerFns.values()) {
            fn();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SelectComponent, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: SelectComponent, isStandalone: true, selector: "select-component", inputs: { defaultValue: "defaultValue", attributes: "attributes", value: "value", name: "name", required: "required", options: "options" }, viewQueries: [{ propertyName: "elRef0", first: true, predicate: ["elRef0"], descendants: true }], usesOnChanges: true, ngImport: i0, template: `
    <select
      [attr.value]="value"
      [attr.defaultValue]="defaultValue"
      [attr.name]="name"
      [attr.required]="required"
      #elRef0
    >
      <ng-container
        *ngFor="let option of options; index as index; trackBy: trackByOption0"
      >
        <option [attr.value]="option.value">
          {{option.name || option.value}}
        </option>
      </ng-container>
    </select>
  `, isInline: true, styles: [":host{display:contents}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SelectComponent, decorators: [{
            type: Component,
            args: [{ selector: "select-component", template: `
    <select
      [attr.value]="value"
      [attr.defaultValue]="defaultValue"
      [attr.name]="name"
      [attr.required]="required"
      #elRef0
    >
      <ng-container
        *ngFor="let option of options; index as index; trackBy: trackByOption0"
      >
        <option [attr.value]="option.value">
          {{option.name || option.value}}
        </option>
      </ng-container>
    </select>
  `, standalone: true, imports: [CommonModule], styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { defaultValue: [{
                type: Input
            }], attributes: [{
                type: Input
            }], value: [{
                type: Input
            }], name: [{
                type: Input
            }], required: [{
                type: Input
            }], options: [{
                type: Input
            }], elRef0: [{
                type: ViewChild,
                args: ["elRef0"]
            }] } });

const componentInfo$3 = {
    name: 'Form:SubmitButton',
    image: 'https://cdn.builder.io/api/v1/image/assets%2FIsxPKMo2gPRRKeakUztj1D6uqed2%2Fdf2820ffed1f4349a94c40b3221f5b98',
    defaultStyles: {
        appearance: 'none',
        paddingTop: '15px',
        paddingBottom: '15px',
        paddingLeft: '25px',
        paddingRight: '25px',
        backgroundColor: '#3898EC',
        color: 'white',
        borderRadius: '4px',
        cursor: 'pointer'
    },
    inputs: [{
            name: 'text',
            type: 'text',
            defaultValue: 'Click me'
        }],
    static: true,
    noWrap: true
    // TODO: optional children? maybe as optional form input
    // that only shows if advanced setting is flipped
    // TODO: defaultChildren
    // canHaveChildren: true,
};

class SubmitButton {
    setAttributes(el, value, changes) {
        if (!el) {
            return;
        }
        const target = typeof changes === "undefined" ? value : changes;
        Object.keys(target).forEach((key) => {
            if (key.startsWith("on")) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace("on", "").toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key.toLowerCase(), target[key] ?? "");
            }
        });
    }
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
        this.elRef0_state_0 = null;
    }
    ngOnInit() {
        this.elRef0_state_0 = {};
    }
    ngAfterViewInit() {
        this.setAttributes(this.elRef0?.nativeElement, this.elRef0_state_0);
        this.setAttributes(this.elRef0?.nativeElement, this.attributes);
    }
    ngOnChanges(changes) {
        if (typeof window !== "undefined") {
            this.elRef0_state_0 = {};
            this.setAttributes(this.elRef0?.nativeElement, this.elRef0_state_0, changes["elRef0_state_0"]?.currentValue);
            this.setAttributes(this.elRef0?.nativeElement, this.attributes, changes["attributes"]?.currentValue);
        }
    }
    ngOnDestroy() {
        for (const fn of this._listenerFns.values()) {
            fn();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SubmitButton, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: SubmitButton, isStandalone: true, selector: "submit-button", inputs: { attributes: "attributes", text: "text" }, viewQueries: [{ propertyName: "elRef0", first: true, predicate: ["elRef0"], descendants: true }], usesOnChanges: true, ngImport: i0, template: `
    <button type="submit" #elRef0>{{text}}</button>
  `, isInline: true, styles: [":host{display:contents}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SubmitButton, decorators: [{
            type: Component,
            args: [{ selector: "submit-button", template: `
    <button type="submit" #elRef0>{{text}}</button>
  `, standalone: true, imports: [CommonModule], styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { attributes: [{
                type: Input
            }], text: [{
                type: Input
            }], elRef0: [{
                type: ViewChild,
                args: ["elRef0"]
            }] } });

const componentInfo$2 = {
    name: 'Form:TextArea',
    image: 'https://cdn.builder.io/api/v1/image/assets%2FIsxPKMo2gPRRKeakUztj1D6uqed2%2Ff74a2f3de58c4c3e939204e5b6b8f6c3',
    inputs: [{
            advanced: true,
            name: 'value',
            type: 'string'
        }, {
            name: 'name',
            type: 'string',
            required: true,
            helperText: 'Every input in a form needs a unique name describing what it gets, e.g. "email"'
        }, {
            name: 'defaultValue',
            type: 'string'
        }, {
            name: 'placeholder',
            type: 'string',
            defaultValue: 'Hello there'
        }, {
            name: 'required',
            type: 'boolean',
            defaultValue: false
        }],
    defaultStyles: {
        paddingTop: '10px',
        paddingBottom: '10px',
        paddingLeft: '10px',
        paddingRight: '10px',
        borderRadius: '3px',
        borderWidth: '1px',
        borderStyle: 'solid',
        borderColor: '#ccc'
    },
    static: true,
    noWrap: true
};

class BuilderTextarea {
    setAttributes(el, value, changes) {
        if (!el) {
            return;
        }
        const target = typeof changes === "undefined" ? value : changes;
        Object.keys(target).forEach((key) => {
            if (key.startsWith("on")) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace("on", "").toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key.toLowerCase(), target[key] ?? "");
            }
        });
    }
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
        this.elRef0_state_0 = null;
    }
    ngOnInit() {
        this.elRef0_state_0 = {};
    }
    ngAfterViewInit() {
        this.setAttributes(this.elRef0?.nativeElement, this.elRef0_state_0);
        this.setAttributes(this.elRef0?.nativeElement, this.attributes);
    }
    ngOnChanges(changes) {
        if (typeof window !== "undefined") {
            this.elRef0_state_0 = {};
            this.setAttributes(this.elRef0?.nativeElement, this.elRef0_state_0, changes["elRef0_state_0"]?.currentValue);
            this.setAttributes(this.elRef0?.nativeElement, this.attributes, changes["attributes"]?.currentValue);
        }
    }
    ngOnDestroy() {
        for (const fn of this._listenerFns.values()) {
            fn();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: BuilderTextarea, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: BuilderTextarea, isStandalone: true, selector: "builder-textarea", inputs: { attributes: "attributes", placeholder: "placeholder", name: "name", value: "value", defaultValue: "defaultValue", required: "required" }, viewQueries: [{ propertyName: "elRef0", first: true, predicate: ["elRef0"], descendants: true }], usesOnChanges: true, ngImport: i0, template: `
    <textarea
      [attr.placeholder]="placeholder"
      [attr.name]="name"
      [attr.value]="value"
      [attr.defaultValue]="defaultValue"
      [attr.required]="required"
      #elRef0
    ></textarea>
  `, isInline: true, styles: [":host{display:contents}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: BuilderTextarea, decorators: [{
            type: Component,
            args: [{ selector: "builder-textarea", template: `
    <textarea
      [attr.placeholder]="placeholder"
      [attr.name]="name"
      [attr.value]="value"
      [attr.defaultValue]="defaultValue"
      [attr.required]="required"
      #elRef0
    ></textarea>
  `, standalone: true, imports: [CommonModule], styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { attributes: [{
                type: Input
            }], placeholder: [{
                type: Input
            }], name: [{
                type: Input
            }], value: [{
                type: Input
            }], defaultValue: [{
                type: Input
            }], required: [{
                type: Input
            }], elRef0: [{
                type: ViewChild,
                args: ["elRef0"]
            }] } });

const componentInfo$1 = {
    // friendlyName?
    name: 'Raw:Img',
    hideFromInsertMenu: true,
    image: 'https://firebasestorage.googleapis.com/v0/b/builder-3b0a2.appspot.com/o/images%2Fbaseline-insert_photo-24px.svg?alt=media&token=4e5d0ef4-f5e8-4e57-b3a9-38d63a9b9dc4',
    inputs: [{
            name: 'image',
            bubble: true,
            type: 'file',
            allowedFileTypes: IMAGE_FILE_TYPES,
            required: true
        }],
    noWrap: true,
    static: true
};

class ImgComponent {
    setAttributes(el, value, changes) {
        if (!el) {
            return;
        }
        const target = typeof changes === "undefined" ? value : changes;
        Object.keys(target).forEach((key) => {
            if (key.startsWith("on")) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace("on", "").toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key.toLowerCase(), target[key] ?? "");
            }
        });
    }
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
        this.node_0_img = null;
        this.node_1_img = null;
        this.elRef0_state_0 = null;
    }
    ngOnInit() {
        this.node_0_img = {
            objectFit: this.backgroundSize || "cover",
            objectPosition: this.backgroundPosition || "center",
        };
        this.node_1_img = (isEditing() && this.imgSrc) || "default-key";
        this.elRef0_state_0 = {};
    }
    ngAfterViewInit() {
        this.setAttributes(this.elRef0?.nativeElement, this.elRef0_state_0);
        this.setAttributes(this.elRef0?.nativeElement, this.attributes);
    }
    ngOnChanges(changes) {
        if (typeof window !== "undefined") {
            this.node_0_img = {
                objectFit: this.backgroundSize || "cover",
                objectPosition: this.backgroundPosition || "center",
            };
            this.node_1_img = (isEditing() && this.imgSrc) || "default-key";
            this.elRef0_state_0 = {};
            this.setAttributes(this.elRef0?.nativeElement, this.elRef0_state_0, changes["elRef0_state_0"]?.currentValue);
            this.setAttributes(this.elRef0?.nativeElement, this.attributes, changes["attributes"]?.currentValue);
        }
    }
    ngOnDestroy() {
        for (const fn of this._listenerFns.values()) {
            fn();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ImgComponent, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: ImgComponent, isStandalone: true, selector: "img-component", inputs: { backgroundSize: "backgroundSize", backgroundPosition: "backgroundPosition", imgSrc: "imgSrc", altText: "altText", image: "image", attributes: "attributes" }, viewQueries: [{ propertyName: "elRef0", first: true, predicate: ["elRef0"], descendants: true }], usesOnChanges: true, ngImport: i0, template: `
    <img
      [ngStyle]="node_0_img"
      [attr.alt]="altText"
      [attr.src]="imgSrc || image"
      #elRef0
    />
  `, isInline: true, styles: [":host{display:contents}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ImgComponent, decorators: [{
            type: Component,
            args: [{ selector: "img-component", template: `
    <img
      [ngStyle]="node_0_img"
      [attr.alt]="altText"
      [attr.src]="imgSrc || image"
      #elRef0
    />
  `, standalone: true, imports: [CommonModule], styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { backgroundSize: [{
                type: Input
            }], backgroundPosition: [{
                type: Input
            }], imgSrc: [{
                type: Input
            }], altText: [{
                type: Input
            }], image: [{
                type: Input
            }], attributes: [{
                type: Input
            }], elRef0: [{
                type: ViewChild,
                args: ["elRef0"]
            }] } });

const componentInfo = {
    name: 'Video',
    canHaveChildren: true,
    defaultStyles: {
        minHeight: '20px',
        minWidth: '20px'
    },
    image: 'https://firebasestorage.googleapis.com/v0/b/builder-3b0a2.appspot.com/o/images%2Fbaseline-videocam-24px%20(1).svg?alt=media&token=49a84e4a-b20e-4977-a650-047f986874bb',
    inputs: [{
            name: 'video',
            type: 'file',
            allowedFileTypes: VIDEO_FILE_TYPES,
            bubble: true,
            defaultValue: 'https://cdn.builder.io/o/assets%2FYJIGb4i01jvw0SRdL5Bt%2Fd27731a526464deba0016216f5f9e570%2Fcompressed?apiKey=YJIGb4i01jvw0SRdL5Bt&token=d27731a526464deba0016216f5f9e570&alt=media&optimized=true',
            required: true
        }, {
            name: 'posterImage',
            type: 'file',
            allowedFileTypes: IMAGE_FILE_TYPES,
            helperText: 'Image to show before the video plays'
        }, {
            name: 'autoPlay',
            type: 'boolean',
            defaultValue: true
        }, {
            name: 'controls',
            type: 'boolean',
            defaultValue: false
        }, {
            name: 'muted',
            type: 'boolean',
            defaultValue: true
        }, {
            name: 'loop',
            type: 'boolean',
            defaultValue: true
        }, {
            name: 'playsInline',
            type: 'boolean',
            defaultValue: true
        }, {
            name: 'fit',
            type: 'text',
            defaultValue: 'cover',
            enum: ['contain', 'cover', 'fill', 'auto']
        }, {
            name: 'preload',
            type: 'text',
            defaultValue: 'metadata',
            enum: ['auto', 'metadata', 'none']
        }, {
            name: 'fitContent',
            type: 'boolean',
            helperText: 'When child blocks are provided, fit to them instead of using the aspect ratio',
            defaultValue: true,
            advanced: true
        }, {
            name: 'position',
            type: 'text',
            defaultValue: 'center',
            enum: ['center', 'top', 'left', 'right', 'bottom', 'top left', 'top right', 'bottom left', 'bottom right']
        }, {
            name: 'height',
            type: 'number',
            advanced: true
        }, {
            name: 'width',
            type: 'number',
            advanced: true
        }, {
            name: 'aspectRatio',
            type: 'number',
            advanced: true,
            defaultValue: 0.7004048582995948
        }, {
            name: 'lazyLoad',
            type: 'boolean',
            helperText: 'Load this video "lazily" - as in only when a user scrolls near the video. Recommended for optmized performance and bandwidth consumption',
            defaultValue: true,
            advanced: true
        }],
    shouldReceiveBuilderProps: {
        builderBlock: true
    }
};

class BuilderVideo {
    get videoProps() {
        return {
            ...(this.autoPlay === true
                ? {
                    autoPlay: true,
                }
                : {}),
            ...(this.muted === true
                ? {
                    muted: true,
                }
                : {}),
            ...(this.controls === true
                ? {
                    controls: true,
                }
                : {}),
            ...(this.loop === true
                ? {
                    loop: true,
                }
                : {}),
            ...(this.playsInline === true
                ? {
                    playsInline: true,
                }
                : {}),
        };
    }
    get spreadProps() {
        return {
            ...this.videoProps,
        };
    }
    setAttributes(el, value, changes) {
        if (!el) {
            return;
        }
        const target = typeof changes === "undefined" ? value : changes;
        Object.keys(target).forEach((key) => {
            if (key.startsWith("on")) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace("on", "").toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key.toLowerCase(), target[key] ?? "");
            }
        });
    }
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
        this.lazyVideoObserver = undefined;
        this.node_0_div = null;
        this.node_1_video = null;
        this.node_2_source = null;
        this.node_3_Show = null;
        this.node_4_div = null;
        this.node_5_div = null;
        this.node_6_div = null;
    }
    ngOnInit() {
        this.node_0_div = {
            position: "relative",
        };
        this.node_1_video = {
            width: "100%",
            height: "100%",
            ...this.attributes?.style,
            objectFit: this.fit,
            objectPosition: this.position,
            // Hack to get object fit to work as expected and
            // not have the video overflow
            borderRadius: "1px",
            ...(this.aspectRatio
                ? {
                    position: "absolute",
                }
                : null),
        };
        this.node_2_source = {
            ...(this.lazyLoad
                ? {
                    "data-src": this.video,
                }
                : {
                    src: this.video,
                }),
        };
        this.node_3_Show =
            this.aspectRatio &&
                !(this.fitContent && this.builderBlock?.children?.length);
        this.node_4_div = {
            width: "100%",
            paddingTop: this.aspectRatio * 100 + "%",
            pointerEvents: "none",
            fontSize: "0px",
        };
        this.node_5_div = {
            display: "flex",
            flexDirection: "column",
            alignItems: "stretch",
        };
        this.node_6_div = {
            pointerEvents: "none",
            display: "flex",
            flexDirection: "column",
            alignItems: "stretch",
            position: "absolute",
            top: "0",
            left: "0",
            width: "100%",
            height: "100%",
        };
    }
    ngAfterViewInit() {
        if (this.lazyLoad) {
            const oberver = new IntersectionObserver(function (entries) {
                entries.forEach(function (entry) {
                    if (!entry.isIntersecting)
                        return;
                    const videoElement = entry.target;
                    try {
                        // Convert HTMLCollection to Array and filter for source elements
                        Array.from(videoElement.children)
                            .filter((child) => child instanceof HTMLElement && child.tagName === "SOURCE")
                            .forEach((source) => {
                            const src = source.dataset.src;
                            if (src) {
                                source.src = src;
                            }
                        });
                        videoElement.load();
                        oberver.unobserve(videoElement);
                    }
                    catch (error) {
                        console.error("Error loading lazy video:", error);
                    }
                });
            });
            if (this.videoRef.nativeElement) {
                oberver.observe(this.videoRef.nativeElement);
            }
            this.lazyVideoObserver = oberver;
        }
        this.setAttributes(this.elRef0?.nativeElement, this.spreadProps);
        this.setAttributes(this.elRef1?.nativeElement, this.node_2_source);
    }
    ngOnChanges(changes) {
        if (typeof window !== "undefined") {
            this.node_0_div = {
                position: "relative",
            };
            this.node_1_video = {
                width: "100%",
                height: "100%",
                ...this.attributes?.style,
                objectFit: this.fit,
                objectPosition: this.position,
                // Hack to get object fit to work as expected and
                // not have the video overflow
                borderRadius: "1px",
                ...(this.aspectRatio
                    ? {
                        position: "absolute",
                    }
                    : null),
            };
            this.node_2_source = {
                ...(this.lazyLoad
                    ? {
                        "data-src": this.video,
                    }
                    : {
                        src: this.video,
                    }),
            };
            this.node_3_Show =
                this.aspectRatio &&
                    !(this.fitContent && this.builderBlock?.children?.length);
            this.node_4_div = {
                width: "100%",
                paddingTop: this.aspectRatio * 100 + "%",
                pointerEvents: "none",
                fontSize: "0px",
            };
            this.node_5_div = {
                display: "flex",
                flexDirection: "column",
                alignItems: "stretch",
            };
            this.node_6_div = {
                pointerEvents: "none",
                display: "flex",
                flexDirection: "column",
                alignItems: "stretch",
                position: "absolute",
                top: "0",
                left: "0",
                width: "100%",
                height: "100%",
            };
            this.setAttributes(this.elRef0?.nativeElement, this.spreadProps, changes["spreadProps"]?.currentValue);
            this.setAttributes(this.elRef1?.nativeElement, this.node_2_source, changes["node_2_source"]?.currentValue);
        }
    }
    ngOnDestroy() {
        if (this.lazyVideoObserver) {
            this.lazyVideoObserver.disconnect();
        }
        for (const fn of this._listenerFns.values()) {
            fn();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: BuilderVideo, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: BuilderVideo, isStandalone: true, selector: "builder-video", inputs: { lazyLoad: "lazyLoad", attributes: "attributes", fit: "fit", position: "position", aspectRatio: "aspectRatio", video: "video", fitContent: "fitContent", builderBlock: "builderBlock", autoPlay: "autoPlay", muted: "muted", controls: "controls", loop: "loop", playsInline: "playsInline", preload: "preload", posterImage: "posterImage" }, viewQueries: [{ propertyName: "videoRef", first: true, predicate: ["videoRef"], descendants: true }, { propertyName: "elRef0", first: true, predicate: ["elRef0"], descendants: true }, { propertyName: "elRef1", first: true, predicate: ["elRef1"], descendants: true }], usesOnChanges: true, ngImport: i0, template: `
    <div [ngStyle]="node_0_div">
      <video
        class="builder-video"
        #videoRef
        [attr.preload]="lazyLoad ? 'none' : preload || 'metadata'"
        [ngStyle]="node_1_video"
        [attr.poster]="posterImage"
        #elRef0
      >
        <source type="video/mp4" #elRef1 />
      </video>
      <ng-container *ngIf="node_3_Show">
        <div [ngStyle]="node_4_div"></div>
      </ng-container>
      <ng-container *ngIf="builderBlock?.children?.length && fitContent">
        <div [ngStyle]="node_5_div"><ng-content></ng-content></div>
      </ng-container>
      <ng-container *ngIf="builderBlock?.children?.length && !fitContent">
        <div [ngStyle]="node_6_div"><ng-content></ng-content></div>
      </ng-container>
    </div>
  `, isInline: true, styles: [":host{display:contents}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: BuilderVideo, decorators: [{
            type: Component,
            args: [{ selector: "builder-video", template: `
    <div [ngStyle]="node_0_div">
      <video
        class="builder-video"
        #videoRef
        [attr.preload]="lazyLoad ? 'none' : preload || 'metadata'"
        [ngStyle]="node_1_video"
        [attr.poster]="posterImage"
        #elRef0
      >
        <source type="video/mp4" #elRef1 />
      </video>
      <ng-container *ngIf="node_3_Show">
        <div [ngStyle]="node_4_div"></div>
      </ng-container>
      <ng-container *ngIf="builderBlock?.children?.length && fitContent">
        <div [ngStyle]="node_5_div"><ng-content></ng-content></div>
      </ng-container>
      <ng-container *ngIf="builderBlock?.children?.length && !fitContent">
        <div [ngStyle]="node_6_div"><ng-content></ng-content></div>
      </ng-container>
    </div>
  `, standalone: true, imports: [CommonModule], styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { lazyLoad: [{
                type: Input
            }], attributes: [{
                type: Input
            }], fit: [{
                type: Input
            }], position: [{
                type: Input
            }], aspectRatio: [{
                type: Input
            }], video: [{
                type: Input
            }], fitContent: [{
                type: Input
            }], builderBlock: [{
                type: Input
            }], autoPlay: [{
                type: Input
            }], muted: [{
                type: Input
            }], controls: [{
                type: Input
            }], loop: [{
                type: Input
            }], playsInline: [{
                type: Input
            }], preload: [{
                type: Input
            }], posterImage: [{
                type: Input
            }], videoRef: [{
                type: ViewChild,
                args: ["videoRef"]
            }], elRef0: [{
                type: ViewChild,
                args: ["elRef0"]
            }], elRef1: [{
                type: ViewChild,
                args: ["elRef1"]
            }] } });

/**
 * These are in a separate file because React Native does not support them (yet).
 * Having them in a separate file allows us to override it to be empty in the
 * React Native SDK.
 */
const getExtraComponents = () => [{
        component: CustomCode,
        ...componentInfo$8
    }, {
        component: BuilderEmbed,
        ...componentInfo$7
    }, ...(TARGET === 'rsc' ? [] : [{
            component: FormComponent,
            ...componentInfo$6
        }, {
            component: FormInputComponent,
            ...componentInfo$5
        }, {
            component: SubmitButton,
            ...componentInfo$3
        }, {
            component: SelectComponent,
            ...componentInfo$4
        }, {
            component: BuilderTextarea,
            ...componentInfo$2
        }]), {
        component: ImgComponent,
        ...componentInfo$1
    }, {
        component: BuilderVideo,
        ...componentInfo
    }];

/**
 * Returns a list of all registered components.
 * NOTE: This needs to be a function to work around ESM circular dependencies.
 */
const getDefaultRegisteredComponents = () => [{
        component: BuilderButton,
        ...componentInfo$i
    }, {
        component: Columns,
        ...componentInfo$h
    }, {
        component: FragmentComponent,
        ...componentInfo$g
    }, {
        component: BuilderImage,
        ...componentInfo$f
    }, {
        component: SectionComponent,
        ...componentInfo$d
    }, {
        component: BuilderSlot,
        ...componentInfo$c
    }, {
        component: BuilderSymbol,
        ...componentInfo$b
    }, {
        component: BuilderText,
        ...componentInfo$9
    }, ...(TARGET === 'react' ? [{
            component: PersonalizationContainer,
            ...componentInfo$e
        }] : []), ...(TARGET === 'rsc' ? [] : [{
            component: Tabs,
            ...componentInfo$a
        }, {
            component: Accordion,
            ...componentInfo$j
        }]), ...getExtraComponents()];

const createRegisterComponentMessage = (info) => ({
    type: 'builder.registerComponent',
    data: serializeIncludingFunctions(info)
});
// eslint-disable-next-line @typescript-eslint/ban-types
const serializeFn = (fnValue) => {
    const fnStr = fnValue.toString().trim();
    // we need to account for a few different fn syntaxes:
    // 1. `function name(args) => {code}`
    // 2. `name(args) => {code}`
    // 3. `(args) => {}`
    // 4. `args => {}`
    // 5. `async function(args) {code}`
    // 6. `async (args) => {}`
    // 7. `async args => {}`
    const isArrowWithoutParens = /^[a-zA-Z0-9_]+\s*=>/i.test(fnStr);
    const appendFunction = !fnStr.startsWith('function') && !fnStr.startsWith('async') && !fnStr.startsWith('(') && !isArrowWithoutParens;
    return `return (${appendFunction ? 'function ' : ''}${fnStr}).apply(this, arguments)`;
};
function serializeIncludingFunctions(info) {
    return JSON.parse(JSON.stringify(info, (key, value) => {
        if (typeof value === 'function') {
            return serializeFn(value);
        }
        return value;
    }));
}

/**
 * WARNING: This file contains functions that get stringified and inlined into the HTML at build-time.
 * They cannot import anything.
 */
/**
 * For more information on how this works,
 * see our [SSR A/B Test Docs](https://github.com/BuilderIO/builder/tree/main/packages/sdks/src/SSR_AB_TEST.md)
 */
/**
 * For more information on how this works,
 * see our [SSR A/B Test Docs](https://github.com/BuilderIO/builder/tree/main/packages/sdks/docs/SSR_AB_TEST.md)
 */
const UPDATE_COOKIES_AND_STYLES_SCRIPT = "function updateCookiesAndStyles(contentId, variants, isHydrationTarget) {\n  function getAndSetVariantId() {\n    function setCookie(name, value, days) {\n      let expires = '';\n      if (days) {\n        const date = new Date();\n        date.setTime(date.getTime() + days * 24 * 60 * 60 * 1000);\n        expires = '; expires=' + date.toUTCString();\n      }\n      document.cookie = name + '=' + (value || '') + expires + '; path=/' + '; Secure; SameSite=None';\n    }\n    function getCookie(name) {\n      const nameEQ = name + '=';\n      const ca = document.cookie.split(';');\n      for (let i = 0; i < ca.length; i++) {\n        let c = ca[i];\n        while (c.charAt(0) === ' ') c = c.substring(1, c.length);\n        if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);\n      }\n      return null;\n    }\n    const cookieName = `builder.tests.${contentId}`;\n    const variantInCookie = getCookie(cookieName);\n    const availableIDs = variants.map(vr => vr.id).concat(contentId);\n    if (variantInCookie && availableIDs.includes(variantInCookie)) {\n      return variantInCookie;\n    }\n    let n = 0;\n    const random = Math.random();\n    for (let i = 0; i < variants.length; i++) {\n      const variant = variants[i];\n      const testRatio = variant.testRatio;\n      n += testRatio;\n      if (random < n) {\n        setCookie(cookieName, variant.id);\n        return variant.id;\n      }\n    }\n    setCookie(cookieName, contentId);\n    return contentId;\n  }\n  const winningVariantId = getAndSetVariantId();\n  const styleEl = document.currentScript?.previousElementSibling;\n  if (isHydrationTarget) {\n    styleEl.remove();\n    const thisScriptEl = document.currentScript;\n    thisScriptEl?.remove();\n  } else {\n    const newStyleStr = variants.concat({\n      id: contentId\n    }).filter(variant => variant.id !== winningVariantId).map(value => {\n      return `.variant-${value.id} {  display: none; }\n        `;\n    }).join('');\n    styleEl.innerHTML = newStyleStr;\n  }\n}";
const UPDATE_VARIANT_VISIBILITY_SCRIPT = "function updateVariantVisibility(variantContentId, defaultContentId, isHydrationTarget) {\n  if (!navigator.cookieEnabled) {\n    return;\n  }\n  function getCookie(name) {\n    const nameEQ = name + '=';\n    const ca = document.cookie.split(';');\n    for (let i = 0; i < ca.length; i++) {\n      let c = ca[i];\n      while (c.charAt(0) === ' ') c = c.substring(1, c.length);\n      if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);\n    }\n    return null;\n  }\n  const cookieName = `builder.tests.${defaultContentId}`;\n  const winningVariant = getCookie(cookieName);\n  const parentDiv = document.currentScript?.parentElement;\n  const isDefaultContent = variantContentId === defaultContentId;\n  const isWinningVariant = winningVariant === variantContentId;\n  if (isWinningVariant && !isDefaultContent) {\n    parentDiv?.removeAttribute('hidden');\n    parentDiv?.removeAttribute('aria-hidden');\n  } else if (!isWinningVariant && isDefaultContent) {\n    parentDiv?.setAttribute('hidden', 'true');\n    parentDiv?.setAttribute('aria-hidden', 'true');\n  }\n  if (isHydrationTarget) {\n    if (!isWinningVariant) {\n      parentDiv?.remove();\n    }\n    const thisScriptEl = document.currentScript;\n    thisScriptEl?.remove();\n  }\n  return;\n}";

/**
 * We hardcode explicit function names here, because the `.toString()` of a function can change depending on the bundler.
 * Some bundlers will minify the fn name, etc.
 *
 * So we hardcode the function names here, and then use those names in the script string to make sure the function names are consistent.
 */
const UPDATE_COOKIES_AND_STYLES_SCRIPT_NAME = 'builderIoAbTest';
const UPDATE_VARIANT_VISIBILITY_SCRIPT_FN_NAME = 'builderIoRenderContent';
const getVariants = (content) => Object.values(content?.variations || {}).map(variant => ({
    ...variant,
    testVariationId: variant.id,
    id: content?.id
}));
const checkShouldRenderVariants = ({ canTrack, content }) => {
    const hasVariants = getVariants(content).length > 0;
    /**
     * We cannot SSR in React-Native.
     */
    if (TARGET === 'reactNative')
        return false;
    if (!hasVariants)
        return false;
    if (!canTrack)
        return false;
    /**
     * For Vue and Svelte, we need to (initially) render the variants. This is to avoid hydration mismatch errors.
     *
     * Unlike React, Vue's hydration checks are shallow and do not check the attributes/contents of each element, so we
     * are able to modify the `hidden` HTML attributes and `display` CSS properties without causing a hydration mismatch error.
     *
     * NOTE: For Solid/Svelte: after the app is hydrated, we strip the variants from the DOM (on mount) to reduce the amount of HTML in the DOM.
     * This isn't necessary, just a nice to have.
     */
    if (TARGET === 'vue' || TARGET === 'svelte')
        return true;
    if (isBrowser())
        return false;
    return true;
};
const getIsHydrationTarget = (target) => target === 'react' || target === 'reactNative';
const isHydrationTarget = getIsHydrationTarget(TARGET);
const getInitVariantsFnsScriptString = () => `
  window.${UPDATE_COOKIES_AND_STYLES_SCRIPT_NAME} = ${UPDATE_COOKIES_AND_STYLES_SCRIPT}
  window.${UPDATE_VARIANT_VISIBILITY_SCRIPT_FN_NAME} = ${UPDATE_VARIANT_VISIBILITY_SCRIPT}
  `;
const getUpdateCookieAndStylesScript = (variants, contentId) => `
  window.${UPDATE_COOKIES_AND_STYLES_SCRIPT_NAME}(
    "${contentId}",${JSON.stringify(variants)}, ${isHydrationTarget}
  )`;
const getUpdateVariantVisibilityScript = ({ contentId, variationId }) => `window.${UPDATE_VARIANT_VISIBILITY_SCRIPT_FN_NAME}(
    "${variationId}", "${contentId}", ${isHydrationTarget}
  )`;

function getPreviewContent(_searchParams) {
    return undefined;
}

const SDK_VERSION = "0.18.0";

const getSdkHeaders = () => ({
    'X-Builder-SDK': TARGET,
    'X-Builder-SDK-GEN': '2',
    'X-Builder-SDK-Version': SDK_VERSION
});

function getGlobalThis() {
    if (typeof globalThis !== 'undefined') {
        return globalThis;
    }
    if (typeof window !== 'undefined') {
        return window;
    }
    if (typeof global !== 'undefined') {
        return global;
    }
    if (typeof self !== 'undefined') {
        return self;
    }
    return globalThis;
}

function getFetch() {
    const globalFetch = getGlobalThis().fetch;
    if (typeof globalFetch === 'undefined') {
        console.warn(`Builder SDK could not find a global fetch function. Make sure you have a polyfill for fetch in your project. 
      For more information, read https://github.com/BuilderIO/this-package-uses-fetch`);
        throw new Error('Builder SDK could not find a global `fetch` function');
    }
    return globalFetch;
}
const fetch$1 = getFetch();

/**
 * Convert deep object to a flat object with dots
 *
 * { foo: { bar: 'baz' }} -> { 'foo.bar': 'baz' }
 */
function flatten(object, path = null, separator = '.') {
    return Object.keys(object).reduce((acc, key) => {
        const value = object[key];
        const newPath = [path, key].filter(Boolean).join(separator);
        const isObject = [typeof value === 'object', value !== null, !(Array.isArray(value) && value.length === 0)].every(Boolean);
        return isObject ? {
            ...acc,
            ...flatten(value, newPath, separator)
        } : {
            ...acc,
            [newPath]: value
        };
    }, {});
}
/**
 * Flatten a nested MongoDB query object into a flat object with dot-separated keys.
 * $ keys are not flattened and are left as is.
 *
 * { foo: { bar: { $gt: 5 }}} -> { 'foo.bar': { '$gt': 5 }}
 * { foo: {'bar.id': { $elemMatch: { 'baz.id': { $in: ['abc', 'bcd'] }}}}} -> { 'foo.bar.id': { '$elemMatch': { 'baz.id': { '$in': ['abc', 'bcd'] }}}}
 */
function flattenMongoQuery(obj, _current, _res = {}) {
    for (const key in obj) {
        const value = obj[key];
        const newKey = _current ? _current + '.' + key : key;
        if (value && typeof value === 'object' && !Array.isArray(value) && !Object.keys(value).find(item => item.startsWith('$'))) {
            flattenMongoQuery(value, newKey, _res);
        }
        else {
            _res[newKey] = value;
        }
    }
    return _res;
}
/**
 * Unflatten a flat object with dot-separated keys back into a nested object.
 *
 * { 'foo.bar': 'baz' } -> { foo: { bar: 'baz' }}
 */
function unflatten(obj) {
    const result = {};
    for (const key in obj) {
        const parts = key.split('.');
        let current = result;
        for (let i = 0; i < parts.length; i++) {
            const part = parts[i];
            if (i === parts.length - 1) {
                current[part] = obj[key];
            }
            else {
                current[part] = current[part] || {};
                current = current[part];
            }
        }
    }
    return result;
}

const DEFAULT_API_VERSION = 'v3';

const BUILDER_SEARCHPARAMS_PREFIX = 'builder.';
const BUILDER_OPTIONS_PREFIX = 'options.';
/**
 * Receives a `URLSearchParams` object or a regular query object, and returns the subset of query params that are
 * relevant to the Builder SDK.
 *
 * @returns
 */
const getBuilderSearchParams = (_options) => {
    if (!_options) {
        return {};
    }
    const options = normalizeSearchParams(_options);
    const newOptions = {};
    Object.keys(options).forEach(key => {
        if (key.startsWith(BUILDER_SEARCHPARAMS_PREFIX)) {
            const trimmedKey = key.replace(BUILDER_SEARCHPARAMS_PREFIX, '').replace(BUILDER_OPTIONS_PREFIX, '');
            newOptions[trimmedKey] = options[key];
        }
    });
    return newOptions;
};
const getBuilderSearchParamsFromWindow = () => {
    if (!isBrowser()) {
        return {};
    }
    const searchParams = new URLSearchParams(window.location.search);
    return getBuilderSearchParams(searchParams);
};

const isPositiveNumber = (thing) => typeof thing === 'number' && !isNaN(thing) && thing >= 0;
const generateContentUrl = (options) => {
    const { limit = 30, userAttributes, query, model, apiKey, enrich, locale, apiVersion = DEFAULT_API_VERSION, fields, omit, offset, cacheSeconds, staleCacheSeconds, sort, includeUnpublished, apiHost } = options;
    if (!apiKey) {
        throw new Error('Missing API key');
    }
    if (!['v3'].includes(apiVersion)) {
        throw new Error(`Invalid apiVersion: expected 'v3', received '${apiVersion}'`);
    }
    // if we are fetching an array of content, we disable noTraverse for perf reasons.
    const noTraverse = limit !== 1;
    const baseUrl = apiHost || 'https://cdn.builder.io';
    const url = new URL(`${baseUrl}/api/${apiVersion}/content/${model}`);
    url.searchParams.set('apiKey', apiKey);
    url.searchParams.set('limit', String(limit));
    url.searchParams.set('noTraverse', String(noTraverse));
    url.searchParams.set('includeRefs', String(true));
    const finalLocale = locale || userAttributes?.locale;
    let finalUserAttributes = userAttributes || {};
    if (finalLocale) {
        url.searchParams.set('locale', finalLocale);
        finalUserAttributes = {
            locale: finalLocale,
            ...finalUserAttributes
        };
    }
    if (enrich)
        url.searchParams.set('enrich', String(enrich));
    url.searchParams.set('omit', omit || 'meta.componentsUsed');
    if (fields) {
        url.searchParams.set('fields', fields);
    }
    if (Number.isFinite(offset) && offset > -1) {
        url.searchParams.set('offset', String(Math.floor(offset)));
    }
    if (typeof includeUnpublished === 'boolean') {
        url.searchParams.set('includeUnpublished', String(includeUnpublished));
    }
    if (cacheSeconds && isPositiveNumber(cacheSeconds)) {
        url.searchParams.set('cacheSeconds', String(cacheSeconds));
    }
    if (staleCacheSeconds && isPositiveNumber(staleCacheSeconds)) {
        url.searchParams.set('staleCacheSeconds', String(staleCacheSeconds));
    }
    if (sort) {
        const flattened = flatten({
            sort
        });
        for (const key in flattened) {
            url.searchParams.set(key, JSON.stringify(flattened[key]));
        }
    }
    // TODO: how to express 'offset' in the url - as direct queryparam or as flattened in options[key] ?
    const queryOptions = {
        ...getBuilderSearchParamsFromWindow(),
        ...normalizeSearchParams(options.options || {})
    };
    finalUserAttributes = {
        ...finalUserAttributes,
        ...getUserAttributesAsJSON(queryOptions)
    };
    const flattened = flatten(queryOptions);
    for (const key in flattened) {
        url.searchParams.set(key, String(flattened[key]));
    }
    if (Object.keys(finalUserAttributes).length > 0) {
        url.searchParams.set('userAttributes', JSON.stringify(finalUserAttributes));
    }
    if (query) {
        const flattened = flattenMongoQuery({
            query
        });
        for (const key in flattened) {
            url.searchParams.set(key, JSON.stringify(flattened[key]));
        }
    }
    return url;
};
const getUserAttributesFromQueryOptions = (queryOptions) => {
    const newUserAttributes = {};
    for (const key in queryOptions) {
        if (key.startsWith('userAttributes.')) {
            newUserAttributes[key] = queryOptions[key];
            delete queryOptions[key];
        }
    }
    return newUserAttributes;
};
const getUserAttributesAsJSON = (queryOptions) => {
    if (isBrowser() && queryOptions['preview'] === 'BUILDER_STUDIO') {
        queryOptions['userAttributes.urlPath'] = window.location.pathname;
        queryOptions['userAttributes.host'] = window.location.host;
        const queryOptionsForUserAttributes = getUserAttributesFromQueryOptions(queryOptions);
        const { userAttributes } = unflatten(queryOptionsForUserAttributes);
        return userAttributes;
    }
    return {};
};

const checkContentHasResults = (content) => 'results' in content;
/**
 * Returns the first content entry that matches the given options.
 */
async function fetchOneEntry(options) {
    const allContent = await fetchEntries({
        ...options,
        limit: 1
    });
    if (allContent) {
        return allContent[0] || null;
    }
    return null;
}
const _fetchContent = async (options) => {
    const url = generateContentUrl(options);
    const _fetch = options.fetch ?? fetch$1;
    const fetchOptions = {
        ...options.fetchOptions,
        headers: {
            ...options.fetchOptions?.headers,
            ...getSdkHeaders()
        }
    };
    const res = await _fetch(url.href, fetchOptions);
    const content = await res.json();
    return content;
};
/**
 * @internal Exported only for testing purposes. Do not use.
 */
const _processContentResult = async (options, content, url = generateContentUrl(options)) => {
    const canTrack = getDefaultCanTrack(options.canTrack);
    const isPreviewing = url.search.includes(`preview=`);
    if (TARGET === 'rsc' && isPreviewing) {
        const newResults = [];
        for (const item of content.results) {
            const previewContent = getPreviewContent(url.searchParams);
            newResults.push(previewContent || item);
        }
        content.results = newResults;
    }
    if (!canTrack)
        return content.results;
    if (!(isBrowser() || TARGET === 'reactNative'))
        return content.results;
    /**
     * For client-side navigations, it is ideal to handle AB testing at this point instead of using our
     * complex multi-rendering variants approach, which is only needed for SSR'd content.
     *
     * This is also where react-native would handle AB testing.
     */
    try {
        const newResults = [];
        for (const item of content.results) {
            newResults.push(await handleABTesting({
                item,
                canTrack
            }));
        }
        content.results = newResults;
    }
    catch (e) {
        logger.error('Could not process A/B tests. ', e);
    }
    return content.results;
};
/**
 * Returns a paginated array of entries that match the given options.
 */
async function fetchEntries(options) {
    const url = generateContentUrl(options);
    const content = await _fetchContent(options);
    if (!checkContentHasResults(content)) {
        logger.error('Error fetching data. ', {
            url,
            content,
            options
        });
        throw content;
    }
    return _processContentResult(options, content);
}

/**
 * @credit https://stackoverflow.com/a/2117523
 */
function uuidv4() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        const r = Math.random() * 16 | 0, v = c == 'x' ? r : r & 0x3 | 0x8;
        return v.toString(16);
    });
}
/**
 * Slightly cleaner and smaller UUIDs
 */
function uuid() {
    return uuidv4().replace(/-/g, '');
}

const SESSION_LOCAL_STORAGE_KEY = 'builderSessionId';
const getSessionId = async ({ canTrack }) => {
    if (!canTrack) {
        return undefined;
    }
    const sessionId = await getCookie({
        name: SESSION_LOCAL_STORAGE_KEY,
        canTrack
    });
    if (checkIsDefined(sessionId)) {
        return sessionId;
    }
    else {
        const newSessionId = createSessionId();
        setSessionId({
            id: newSessionId,
            canTrack
        });
        return newSessionId;
    }
};
const createSessionId = () => uuid();
const setSessionId = ({ id, canTrack }) => setCookie({
    name: SESSION_LOCAL_STORAGE_KEY,
    value: id,
    canTrack
});

const getLocalStorage = () => isBrowser() && typeof localStorage !== 'undefined' ? localStorage : undefined;
const getLocalStorageItem = ({ key, canTrack }) => {
    try {
        if (canTrack) {
            return getLocalStorage()?.getItem(key);
        }
        return undefined;
    }
    catch (err) {
        console.debug('[LocalStorage] GET error: ', err);
        return undefined;
    }
};
const setLocalStorageItem = ({ key, canTrack, value }) => {
    try {
        if (canTrack) {
            getLocalStorage()?.setItem(key, value);
        }
    }
    catch (err) {
        console.debug('[LocalStorage] SET error: ', err);
    }
};

const VISITOR_LOCAL_STORAGE_KEY = 'builderVisitorId';
const getVisitorId = ({ canTrack }) => {
    if (!canTrack) {
        return undefined;
    }
    const visitorId = getLocalStorageItem({
        key: VISITOR_LOCAL_STORAGE_KEY,
        canTrack
    });
    if (checkIsDefined(visitorId)) {
        return visitorId;
    }
    else {
        const newVisitorId = createVisitorId();
        setVisitorId({
            id: newVisitorId,
            canTrack
        });
        return newVisitorId;
    }
};
const createVisitorId = () => uuid();
const setVisitorId = ({ id, canTrack }) => setLocalStorageItem({
    key: VISITOR_LOCAL_STORAGE_KEY,
    value: id,
    canTrack
});

const getTrackingEventData = async ({ canTrack }) => {
    if (!canTrack) {
        return {
            visitorId: undefined,
            sessionId: undefined
        };
    }
    const sessionId = await getSessionId({
        canTrack
    });
    const visitorId = getVisitorId({
        canTrack
    });
    return {
        sessionId,
        visitorId
    };
};
const createEvent = async ({ type: eventType, canTrack, apiKey, metadata, ...properties }) => ({
    type: eventType,
    data: {
        ...properties,
        metadata: {
            url: location.href,
            ...metadata
        },
        ...(await getTrackingEventData({
            canTrack
        })),
        userAttributes: getUserAttributes(),
        ownerId: apiKey
    }
});
async function _track({ apiHost, ...eventProps }) {
    if (!eventProps.apiKey) {
        logger.error('Missing API key for track call. Please provide your API key.');
        return;
    }
    if (!eventProps.canTrack) {
        return;
    }
    if (isEditing()) {
        return;
    }
    if (!(isBrowser() || TARGET === 'reactNative')) {
        return;
    }
    const baseUrl = apiHost || 'https://cdn.builder.io';
    const url = `${baseUrl}/api/v1/track`;
    logFetch(url);
    return fetch(url, {
        method: 'POST',
        body: JSON.stringify({
            events: [await createEvent(eventProps)]
        }),
        headers: {
            'content-type': 'application/json',
            ...getSdkHeaders()
        },
        mode: 'cors'
    }).catch(err => {
        console.error('Failed to track: ', err);
    });
}
const track = (args) => _track({
    ...args,
    canTrack: true
});

function round(num) {
    return Math.round(num * 1000) / 1000;
}
const findParentElement = (target, callback, checkElement = true) => {
    if (!(target instanceof HTMLElement)) {
        return null;
    }
    let parent = checkElement ? target : target.parentElement;
    do {
        if (!parent) {
            return null;
        }
        const matches = callback(parent);
        if (matches) {
            return parent;
        }
    } while (parent = parent.parentElement);
    return null;
};
const findBuilderParent = (target) => findParentElement(target, el => {
    const id = el.getAttribute('builder-id') || el.id;
    return Boolean(id?.indexOf('builder-') === 0);
});
const computeOffset = ({ event, target }) => {
    const targetRect = target.getBoundingClientRect();
    const xOffset = event.clientX - targetRect.left;
    const yOffset = event.clientY - targetRect.top;
    const xRatio = round(xOffset / targetRect.width);
    const yRatio = round(yOffset / targetRect.height);
    return {
        x: xRatio,
        y: yRatio
    };
};
const getInteractionPropertiesForEvent = (event) => {
    const target = event.target;
    const targetBuilderElement = target && findBuilderParent(target);
    const builderId = targetBuilderElement?.getAttribute('builder-id') || targetBuilderElement?.id;
    return {
        targetBuilderElement: builderId || undefined,
        metadata: {
            targetOffset: target ? computeOffset({
                event,
                target
            }) : undefined,
            builderTargetOffset: targetBuilderElement ? computeOffset({
                event,
                target: targetBuilderElement
            }) : undefined,
            builderElementIndex: targetBuilderElement && builderId ? [].slice.call(document.getElementsByClassName(builderId)).indexOf(targetBuilderElement) : undefined
        }
    };
};

const DEFAULT_TRUSTED_HOSTS = ['*.beta.builder.io', 'beta.builder.io', 'builder.io', 'localhost', 'qa.builder.io'];
function isFromTrustedHost(trustedHosts, e) {
    if (!e.origin.startsWith('http') && !e.origin.startsWith('https')) {
        return false;
    }
    const url = new URL(e.origin), hostname = url.hostname;
    return (trustedHosts || DEFAULT_TRUSTED_HOSTS).findIndex(trustedHost => trustedHost.startsWith('*.') ? hostname.endsWith(trustedHost.slice(1)) : trustedHost === hostname) > -1;
}

const registry = {};
function register(type, info) {
    if (type === 'plugin') {
        info = serializeIncludingFunctions(info);
    }
    let typeList = registry[type];
    if (!typeList) {
        typeList = registry[type] = [];
    }
    typeList.push(info);
    if (isBrowser()) {
        const message = {
            type: 'builder.register',
            data: {
                type,
                info
            }
        };
        try {
            parent.postMessage(message, '*');
            if (parent !== window) {
                window.postMessage(message, '*');
            }
        }
        catch (err) {
            console.debug('Could not postmessage', err);
        }
    }
}

const registerInsertMenu = () => {
    register('insertMenu', {
        name: '_default',
        default: true,
        items: [{
                name: 'Box'
            }, {
                name: 'Text'
            }, {
                name: 'Image'
            }, {
                name: 'Columns'
            }, ...(TARGET === 'reactNative' ? [] : [{
                    name: 'Core:Section'
                }, {
                    name: 'Core:Button'
                }, {
                    name: 'Embed'
                }, {
                    name: 'Custom Code'
                }])]
    });
};
let isSetupForEditing = false;
const setupBrowserForEditing = (options) => {
    if (isSetupForEditing) {
        return;
    }
    isSetupForEditing = true;
    if (isBrowser()) {
        window.parent?.postMessage({
            type: 'builder.sdkInfo',
            data: {
                target: TARGET,
                version: SDK_VERSION,
                supportsPatchUpdates: false,
                // Supports builder-model="..." attribute which is needed to
                // scope our '+ add block' button styling
                supportsAddBlockScoping: true,
                supportsCustomBreakpoints: true,
                modelName: options.modelName,
                apiKey: options.apiKey,
                supportsXSmallBreakpoint: TARGET === 'reactNative' ? false : true,
                blockLevelPersonalization: true
            }
        }, '*');
        window.parent?.postMessage({
            type: 'builder.updateContent',
            data: {
                options
            }
        }, '*');
        window.addEventListener('message', (event) => {
            if (!isFromTrustedHost(options.trustedHosts, event)) {
                return;
            }
            const { data } = event;
            if (!data?.type) {
                return;
            }
            switch (data.type) {
                case 'builder.evaluate':
                    {
                        const text = data.data.text;
                        const args = data.data.arguments || [];
                        const id = data.data.id;
                        // tslint:disable-next-line:no-function-constructor-with-string-args
                        const fn = new Function(text);
                        let result;
                        let error = null;
                        try {
                            // eslint-disable-next-line prefer-spread
                            result = fn.apply(null, args);
                        }
                        catch (err) {
                            error = err;
                        }
                        if (error) {
                            window.parent?.postMessage({
                                type: 'builder.evaluateError',
                                data: {
                                    id,
                                    error: error.message
                                }
                            }, '*');
                        }
                        else {
                            if (result && typeof result.then === 'function') {
                                result.then(finalResult => {
                                    window.parent?.postMessage({
                                        type: 'builder.evaluateResult',
                                        data: {
                                            id,
                                            result: finalResult
                                        }
                                    }, '*');
                                }).catch(console.error);
                            }
                            else {
                                window.parent?.postMessage({
                                    type: 'builder.evaluateResult',
                                    data: {
                                        result,
                                        id
                                    }
                                }, '*');
                            }
                        }
                        break;
                    }
            }
        });
    }
};

const createEditorListener = ({ model, trustedHosts, callbacks }) => {
    return (event) => {
        if (!isFromTrustedHost(trustedHosts, event)) {
            return;
        }
        const { data } = event;
        if (data) {
            switch (data.type) {
                case 'builder.configureSdk':
                    {
                        callbacks.configureSdk(data.data);
                        break;
                    }
                case 'builder.triggerAnimation':
                    {
                        callbacks.animation(data.data);
                        break;
                    }
                case 'builder.contentUpdate':
                    {
                        const messageContent = data.data;
                        const key = messageContent.key || messageContent.alias || messageContent.entry || messageContent.modelName;
                        const contentData = messageContent.data;
                        if (key === model) {
                            callbacks.contentUpdate(contentData);
                        }
                        break;
                    }
            }
        }
    };
};
/**
 * Subscribes to the Builder editor and listens to `content` updates of a certain `model`.
 * Sends the updated `content` to the `callback` function.
 */
const subscribeToEditor = ({ model, apiKey, callback, trustedHosts }) => {
    if (!isBrowser) {
        logger.warn('`subscribeToEditor` only works in the browser. It currently seems to be running on the server.');
        return () => { };
    }
    setupBrowserForEditing({
        modelName: model,
        apiKey
    });
    const listener = createEditorListener({
        callbacks: {
            contentUpdate: callback,
            animation: () => { },
            configureSdk: () => { }
        },
        model,
        trustedHosts
    });
    window.addEventListener('message', listener);
    return () => {
        window.removeEventListener('message', listener);
    };
};

/**
 * SDKS that use the elementRef approach to enable visual editing.
 * We don't need to render the div for other SDKs as they attach event listeners to the window.
 */
const SDKS_USING_ELEMENT_REF_APPROACH = ['svelte', 'qwik', 'vue'];
/**
 * We need to attach this div only when content exists or isPreviewing/isEditing even when content is null,
 * as we need to set the elementRef and allow previewing and visual editing
 */
const needsElementRefDivForEditing = () => {
    return SDKS_USING_ELEMENT_REF_APPROACH.includes(TARGET) && (isEditing() || isPreviewing());
};

const getCssFromFont = (font) => {
    // TODO: compute what font sizes are used and only load those.......
    const family = font.family + (font.kind && !font.kind.includes('#') ? ', ' + font.kind : '');
    const name = family.split(',')[0];
    const url = font.fileUrl ?? font?.files?.regular;
    let str = '';
    if (url && family && name) {
        str += `
@font-face {
font-family: "${family}";
src: local("${name}"), url('${url}') format('woff2');
font-display: fallback;
font-weight: 400;
}
      `.trim();
    }
    if (font.files) {
        for (const weight in font.files) {
            const isNumber = String(Number(weight)) === weight;
            if (!isNumber) {
                continue;
            }
            // TODO: maybe limit number loaded
            const weightUrl = font.files[weight];
            if (weightUrl && weightUrl !== url) {
                str += `
@font-face {
font-family: "${family}";
src: url('${weightUrl}') format('woff2');
font-display: fallback;
font-weight: ${weight};
}
        `.trim();
            }
        }
    }
    return str;
};
const getFontCss = ({ customFonts }) => {
    // TODO: flag for this
    // if (!this.builder.allowCustomFonts) {
    //   return '';
    // }
    // TODO: separate internal data from external
    return customFonts?.map(font => getCssFromFont(font))?.join(' ') || '';
};
const getCss = ({ cssCode, contentId }) => {
    if (!cssCode) {
        return '';
    }
    if (!contentId) {
        return cssCode;
    }
    // Allow using `&` in custom CSS code like @emotion
    // E.g. `& .foobar { ... }` to scope CSS
    // TODO: handle if '&' is within a string like `content: "&"`
    return cssCode?.replace(/&/g, `div[builder-content-id="${contentId}"]`) || '';
};
const DEFAULT_STYLES = `
.builder-button {
  all: unset;
}

.builder-text > p:first-of-type, .builder-text > .builder-paragraph:first-of-type {
  margin: 0;
}
.builder-text > p, .builder-text > .builder-paragraph {
  color: inherit;
  line-height: inherit;
  letter-spacing: inherit;
  font-weight: inherit;
  font-size: inherit;
  text-align: inherit;
  font-family: inherit;
}
`;
const getDefaultStyles = (isNested) => {
    return !isNested ? DEFAULT_STYLES : '';
};
const getWrapperClassName = (variationId) => {
    return `variant-${variationId}`;
};

class EnableEditor {
    mergeNewRootState(newData) {
        const combinedState = {
            ...this.builderContextSignal.rootState,
            ...newData,
        };
        if (this.builderContextSignal.rootSetState) {
            this.builderContextSignal.rootSetState?.(combinedState);
        }
        else {
            this.builderContextSignal.rootState = combinedState;
        }
    }
    mergeNewContent(newContent) {
        const newContentValue = {
            ...this.builderContextSignal.content,
            ...newContent,
            data: {
                ...this.builderContextSignal.content?.data,
                ...newContent?.data,
            },
            meta: {
                ...this.builderContextSignal.content?.meta,
                ...newContent?.meta,
                breakpoints: newContent?.meta?.breakpoints ||
                    this.builderContextSignal.content?.meta?.breakpoints,
            },
        };
        this.builderContextSignal.content = newContentValue;
    }
    get showContentProps() {
        return this.showContent
            ? {}
            : {
                hidden: true,
                "aria-hidden": true,
            };
    }
    processMessage(event) {
        return createEditorListener({
            model: this.model,
            trustedHosts: this.trustedHosts,
            callbacks: {
                configureSdk: (messageContent) => {
                    const { breakpoints, contentId } = messageContent;
                    if (!contentId ||
                        contentId !== this.builderContextSignal.content?.id) {
                        return;
                    }
                    if (breakpoints) {
                        this.mergeNewContent({
                            meta: {
                                breakpoints,
                            },
                        });
                    }
                },
                animation: (animation) => {
                    triggerAnimation(animation);
                },
                contentUpdate: (newContent) => {
                    this.mergeNewContent(newContent);
                },
            },
        })(event);
    }
    onClick(event) {
        if (this.builderContextSignal.content) {
            const variationId = this.builderContextSignal.content?.testVariationId;
            const contentId = this.builderContextSignal.content?.id;
            _track({
                apiHost: this.apiHost,
                type: "click",
                canTrack: getDefaultCanTrack(this.canTrack),
                contentId,
                apiKey: this.apiKey,
                variationId: variationId !== contentId ? variationId : undefined,
                ...getInteractionPropertiesForEvent(event),
                unique: !this.clicked,
            });
        }
        if (!this.clicked) {
            this.clicked = true;
        }
    }
    runHttpRequests() {
        const requests = this.builderContextSignal.content?.data?.httpRequests ?? {};
        Object.entries(requests).forEach(([key, url]) => {
            if (!url)
                return;
            // request already in progress
            if (this.httpReqsPending[key])
                return;
            // request already completed, and not in edit mode
            if (this.httpReqsData[key] && !isEditing())
                return;
            this.httpReqsPending[key] = true;
            const evaluatedUrl = url.replace(/{{([^}]+)}}/g, (_match, group) => String(evaluate({
                code: group,
                context: this.context || {},
                localState: undefined,
                rootState: this.builderContextSignal.rootState,
                rootSetState: this.builderContextSignal.rootSetState,
            })));
            logFetch(evaluatedUrl);
            fetch(evaluatedUrl)
                .then((response) => response.json())
                .then((json) => {
                this.mergeNewRootState({
                    [key]: json,
                });
                this.httpReqsData[key] = true;
            })
                .catch((err) => {
                console.error("error fetching dynamic data", url, err);
            })
                .finally(() => {
                this.httpReqsPending[key] = false;
            });
        });
    }
    emitStateUpdate() {
        if (isEditing()) {
            window.dispatchEvent(new CustomEvent("builder:component:stateChange", {
                detail: {
                    state: fastClone(this.builderContextSignal.rootState),
                    ref: {
                        name: this.model,
                    },
                },
            }));
        }
    }
    constructor(vcRef) {
        this.vcRef = vcRef;
        this.builderContext = BuilderContext;
        this.ContentWrapper = null;
        this.httpReqsData = {};
        this.httpReqsPending = {};
        this.clicked = false;
        this.node_0_Show = null;
        this.node_2_state_ContentWrapper = null;
        this.node_3_state_ContentWrapper = null;
        this.mergedInputs_ekawrq = {};
    }
    ngOnInit() {
        this.ContentWrapper = this.contentWrapper || DynamicDiv;
        this.runHttpRequests();
        this.emitStateUpdate();
        this.node_0_Show =
            this.builderContextSignal.content || needsElementRefDivForEditing();
        this.node_2_state_ContentWrapper = getWrapperClassName(this.content?.testVariationId || this.content?.id);
        this.node_3_state_ContentWrapper = {
            display: !this.builderContextSignal.content && needsElementRefDivForEditing()
                ? "none"
                : undefined,
        };
        this.mergedInputs_ekawrq = {
            ref: this.elementRef,
            onClick: this.onClick.bind(this),
            "builder-content-id": this.builderContextSignal.content?.id,
            "builder-model": this.model,
            className: this.node_2_state_ContentWrapper,
            style: this.node_3_state_ContentWrapper,
            ...this.showContentProps,
            ...this.contentWrapperProps,
        };
        if (typeof window !== "undefined") {
            if (isBrowser()) {
                if (isEditing() && !this.isNestedRender) {
                    window.addEventListener("message", this.processMessage.bind(this));
                    registerInsertMenu();
                    setupBrowserForEditing({
                        ...(this.locale
                            ? {
                                locale: this.locale,
                            }
                            : {}),
                        ...(this.enrich
                            ? {
                                enrich: this.enrich,
                            }
                            : {}),
                        ...(this.trustedHosts
                            ? {
                                trustedHosts: this.trustedHosts,
                            }
                            : {}),
                        modelName: this.model ?? "",
                        apiKey: this.apiKey,
                    });
                    Object.values(this.builderContextSignal.componentInfos).forEach((registeredComponent) => {
                        if (!registeredComponent.models?.length ||
                            registeredComponent.models.includes(this.model)) {
                            const message = createRegisterComponentMessage(registeredComponent);
                            window.parent?.postMessage(message, "*");
                        }
                    });
                    window.addEventListener("builder:component:stateChangeListenerActivated", this.emitStateUpdate
                        .bind(this));
                }
                const shouldTrackImpression = this.builderContextSignal.content &&
                    getDefaultCanTrack(this.canTrack);
                if (shouldTrackImpression) {
                    const variationId = this.builderContextSignal.content?.testVariationId;
                    const contentId = this.builderContextSignal.content?.id;
                    const apiKeyProp = this.apiKey;
                    _track({
                        apiHost: this.apiHost,
                        type: "impression",
                        canTrack: true,
                        contentId,
                        apiKey: apiKeyProp,
                        variationId: variationId !== contentId ? variationId : undefined,
                    });
                }
                /**
                 * Override normal content in preview mode.
                 * We ignore this when editing, since the edited content is already being sent from the editor via post messages.
                 */
                if (isPreviewing() && !isEditing()) {
                    const searchParams = new URL(location.href).searchParams;
                    const searchParamPreviewModel = searchParams.get("builder.preview");
                    const searchParamPreviewId = searchParams.get(`builder.overrides.${searchParamPreviewModel}`);
                    const previewApiKey = searchParams.get("apiKey") || searchParams.get("builder.space");
                    /**
                     * Make sure that:
                     * - the preview model name is the same as the one we're rendering, since there can be multiple models rendered
                     *  at the same time, e.g. header/page/footer.
                     * - the API key is the same, since we don't want to preview content from other organizations.
                     * - if there is content, that the preview ID is the same as that of the one we receive.
                     *
                     * TO-DO: should we only update the state when there is a change?
                     **/
                    if (searchParamPreviewModel === "BUILDER_STUDIO" ||
                        (searchParamPreviewModel === this.model &&
                            previewApiKey === this.apiKey &&
                            (!this.content || searchParamPreviewId === this.content.id))) {
                        fetchOneEntry({
                            model: this.model,
                            apiKey: this.apiKey,
                            apiVersion: this.builderContextSignal.apiVersion,
                            ...(searchParamPreviewModel === "BUILDER_STUDIO" &&
                                this.context?.symbolId
                                ? {
                                    query: {
                                        id: this.context.symbolId,
                                    },
                                }
                                : {}),
                        }).then((content) => {
                            if (content) {
                                this.mergeNewContent(content);
                            }
                        });
                    }
                }
            }
        }
        this.myContent = [
            this.vcRef.createEmbeddedView(this.contentwrapperTemplateRef).rootNodes,
        ];
    }
    ngOnChanges(changes) {
        if (typeof window !== "undefined") {
            if (this.content) {
                this.mergeNewContent(this.content);
            }
            this.emitStateUpdate();
            if (this.data) {
                this.mergeNewRootState(this.data);
            }
            if (this.locale) {
                this.mergeNewRootState({
                    locale: this.locale,
                });
            }
            this.node_0_Show =
                this.builderContextSignal.content || needsElementRefDivForEditing();
            this.node_2_state_ContentWrapper = getWrapperClassName(this.content?.testVariationId || this.content?.id);
            this.node_3_state_ContentWrapper = {
                display: !this.builderContextSignal.content && needsElementRefDivForEditing()
                    ? "none"
                    : undefined,
            };
            this.mergedInputs_ekawrq = {
                ref: this.elementRef,
                onClick: this.onClick.bind(this),
                "builder-content-id": this.builderContextSignal.content?.id,
                "builder-model": this.model,
                className: this.node_2_state_ContentWrapper,
                style: this.node_3_state_ContentWrapper,
                ...this.showContentProps,
                ...this.contentWrapperProps,
            };
        }
    }
    ngOnDestroy() {
        if (isBrowser()) {
            window.removeEventListener("message", this.processMessage.bind(this));
            window.removeEventListener("builder:component:stateChangeListenerActivated", this.emitStateUpdate
                .bind(this));
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: EnableEditor, deps: [{ token: i0.ViewContainerRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: EnableEditor, isStandalone: true, selector: "enable-editor", inputs: { isNestedRender: "isNestedRender", locale: "locale", enrich: "enrich", trustedHosts: "trustedHosts", model: "model", apiKey: "apiKey", builderContextSignal: "builderContextSignal", canTrack: "canTrack", apiHost: "apiHost", content: "content", context: "context", data: "data", showContent: "showContent", contentWrapper: "contentWrapper", contentWrapperProps: "contentWrapperProps" }, viewQueries: [{ propertyName: "elementRef", first: true, predicate: ["elementRef"], descendants: true }, { propertyName: "contentwrapperTemplateRef", first: true, predicate: ["contentwrapperTemplate"], descendants: true, static: true }], usesOnChanges: true, ngImport: i0, template: `
    <ng-template #contentwrapperTemplate><ng-content></ng-content></ng-template>
    <ng-container *ngIf="node_0_Show">
      <ng-container
        *ngComponentOutlet="
              ContentWrapper;
              inputs: mergedInputs_ekawrq;
              content: myContent;
              "
      ></ng-container>
    </ng-container>
  `, isInline: true, styles: [":host{display:contents}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgComponentOutlet, selector: "[ngComponentOutlet]", inputs: ["ngComponentOutlet", "ngComponentOutletInputs", "ngComponentOutletInjector", "ngComponentOutletContent", "ngComponentOutletNgModule", "ngComponentOutletNgModuleFactory"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: EnableEditor, decorators: [{
            type: Component,
            args: [{ selector: "enable-editor", template: `
    <ng-template #contentwrapperTemplate><ng-content></ng-content></ng-template>
    <ng-container *ngIf="node_0_Show">
      <ng-container
        *ngComponentOutlet="
              ContentWrapper;
              inputs: mergedInputs_ekawrq;
              content: myContent;
              "
      ></ng-container>
    </ng-container>
  `, standalone: true, imports: [CommonModule], styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.ViewContainerRef }]; }, propDecorators: { isNestedRender: [{
                type: Input
            }], locale: [{
                type: Input
            }], enrich: [{
                type: Input
            }], trustedHosts: [{
                type: Input
            }], model: [{
                type: Input
            }], apiKey: [{
                type: Input
            }], builderContextSignal: [{
                type: Input
            }], canTrack: [{
                type: Input
            }], apiHost: [{
                type: Input
            }], content: [{
                type: Input
            }], context: [{
                type: Input
            }], data: [{
                type: Input
            }], showContent: [{
                type: Input
            }], contentWrapper: [{
                type: Input
            }], contentWrapperProps: [{
                type: Input
            }], elementRef: [{
                type: ViewChild,
                args: ["elementRef"]
            }], contentwrapperTemplateRef: [{
                type: ViewChild,
                args: ["contentwrapperTemplate", { static: true }]
            }] } });

class ContentStyles {
    constructor() {
        this.injectedStyles = null;
    }
    ngOnInit() {
        this.injectedStyles = `
${getCss({
            cssCode: this.cssCode,
            contentId: this.contentId,
        })}
${getFontCss({
            customFonts: this.customFonts,
        })}
${getDefaultStyles(this.isNestedRender)}
`.trim();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ContentStyles, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: ContentStyles, isStandalone: true, selector: "content-styles", inputs: { cssCode: "cssCode", contentId: "contentId", customFonts: "customFonts", isNestedRender: "isNestedRender", nonce: "nonce" }, ngImport: i0, template: `
    <inlined-styles
      id="builderio-content"
      [styles]="injectedStyles"
      [nonce]="nonce"
    ></inlined-styles>
  `, isInline: true, styles: [":host{display:contents}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "component", type: InlinedStyles, selector: "inlined-styles, InlinedStyles", inputs: ["styles", "id", "nonce"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ContentStyles, decorators: [{
            type: Component,
            args: [{ selector: "content-styles", template: `
    <inlined-styles
      id="builderio-content"
      [styles]="injectedStyles"
      [nonce]="nonce"
    ></inlined-styles>
  `, standalone: true, imports: [CommonModule, InlinedStyles], styles: [":host{display:contents}\n"] }]
        }], propDecorators: { cssCode: [{
                type: Input
            }], contentId: [{
                type: Input
            }], customFonts: [{
                type: Input
            }], isNestedRender: [{
                type: Input
            }], nonce: [{
                type: Input
            }] } });

const getRootStateInitialValue = ({ content, data, locale }) => {
    const defaultValues = {};
    const initialState = content?.data?.state || {};
    // set default values for content state inputs
    content?.data?.inputs?.forEach(input => {
        if (input.name && input.defaultValue !== undefined) {
            defaultValues[input.name] = input.defaultValue;
        }
    });
    return {
        ...defaultValues,
        ...initialState,
        ...data,
        ...(locale ? {
            locale
        } : {})
    };
};
const getContentInitialValue = ({ content, data }) => {
    return !content ? undefined : {
        ...content,
        data: {
            ...content?.data,
            ...data
        },
        meta: content?.meta
    };
};

class ContentComponent {
    constructor() {
        this.TARGET = TARGET;
        this.scriptStr = null;
        this.registeredComponents = null;
        this.builderContextSignal = null;
    }
    contentSetState(newRootState) {
        this.builderContextSignal.rootState = newRootState;
    }
    ngOnInit() {
        this.scriptStr = getUpdateVariantVisibilityScript({
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion, @typescript-eslint/no-non-null-asserted-optional-chain
            variationId: this.content?.testVariationId,
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion, @typescript-eslint/no-non-null-asserted-optional-chain
            contentId: this.content?.id,
        });
        this.registeredComponents = [
            ...getDefaultRegisteredComponents(),
            ...(this.customComponents || []),
        ].reduce((acc, { component, ...info }) => ({
            ...acc,
            [info.name]: {
                component: component,
                ...serializeIncludingFunctions(info),
            },
        }), {});
        this.builderContextSignal = {
            content: getContentInitialValue({
                content: this.content,
                data: this.data,
            }),
            localState: undefined,
            rootState: getRootStateInitialValue({
                content: this.content,
                data: this.data,
                locale: this.locale,
            }),
            rootSetState: this.contentSetState.bind(this),
            context: this.context || {},
            canTrack: this.canTrack,
            apiKey: this.apiKey,
            apiVersion: this.apiVersion,
            componentInfos: [
                ...getDefaultRegisteredComponents(),
                ...(this.customComponents || []),
            ].reduce((acc, { component: _, ...info }) => ({
                ...acc,
                [info.name]: serializeIncludingFunctions(info),
            }), {}),
            inheritedStyles: {},
            BlocksWrapper: this.blocksWrapper || DynamicDiv,
            BlocksWrapperProps: this.blocksWrapperProps || {},
            nonce: this.nonce || "",
            model: this.model,
        };
        if (!this.apiKey) {
            logger.error("No API key provided to `Content` component. This can cause issues. Please provide an API key using the `apiKey` prop.");
        }
        // run any dynamic JS code attached to content
        const jsCode = this.builderContextSignal.content?.data?.jsCode;
        if (jsCode) {
            evaluate({
                code: jsCode,
                context: this.context || {},
                localState: undefined,
                rootState: this.builderContextSignal.rootState,
                rootSetState: (newState) => {
                    this.builderContextSignal.rootSetState?.(newState);
                },
                isExpression: false,
            });
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ContentComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: ContentComponent, isStandalone: true, selector: "content-component", inputs: { apiKey: "apiKey", context: "context", content: "content", customComponents: "customComponents", data: "data", locale: "locale", canTrack: "canTrack", apiVersion: "apiVersion", blocksWrapper: "blocksWrapper", blocksWrapperProps: "blocksWrapperProps", nonce: "nonce", model: "model", apiHost: "apiHost", enrich: "enrich", showContent: "showContent", contentWrapper: "contentWrapper", contentWrapperProps: "contentWrapperProps", trustedHosts: "trustedHosts", isNestedRender: "isNestedRender", isSsrAbTest: "isSsrAbTest", linkComponent: "linkComponent" }, host: { attributes: { "ngSkipHydration": "true" } }, ngImport: i0, template: `
    <enable-editor
      [apiHost]="apiHost"
      [nonce]="nonce"
      [content]="content"
      [data]="data"
      [model]="model"
      [context]="context"
      [apiKey]="apiKey"
      [canTrack]="canTrack"
      [locale]="locale"
      [enrich]="enrich"
      [showContent]="showContent"
      [builderContextSignal]="builderContextSignal"
      [contentWrapper]="contentWrapper"
      [contentWrapperProps]="contentWrapperProps"
      [trustedHosts]="trustedHosts"
      [isNestedRender]="isNestedRender"
    >
      <ng-container *ngIf="isSsrAbTest">
        <inlined-script
          id="builderio-variant-visibility"
          [scriptStr]="scriptStr"
          [nonce]="nonce || ''"
        ></inlined-script>
      </ng-container>
      <ng-container *ngIf="TARGET !== 'reactNative'">
        <content-styles
          [nonce]="nonce || ''"
          [isNestedRender]="isNestedRender"
          [contentId]="builderContextSignal.content?.id"
          [cssCode]="builderContextSignal.content?.data?.cssCode"
          [customFonts]="builderContextSignal.content?.data?.customFonts"
        ></content-styles>
      </ng-container>
      <blocks
        [blocks]="builderContextSignal.content?.data?.blocks"
        [context]="builderContextSignal"
        [registeredComponents]="registeredComponents"
        [linkComponent]="linkComponent"
      ></blocks>
    </enable-editor>
  `, isInline: true, styles: [":host{display:contents}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: EnableEditor, selector: "enable-editor", inputs: ["isNestedRender", "locale", "enrich", "trustedHosts", "model", "apiKey", "builderContextSignal", "canTrack", "apiHost", "content", "context", "data", "showContent", "contentWrapper", "contentWrapperProps"] }, { kind: "component", type: InlinedScript, selector: "inlined-script, InlinedScript", inputs: ["scriptStr", "id", "nonce"] }, { kind: "component", type: ContentStyles, selector: "content-styles", inputs: ["cssCode", "contentId", "customFonts", "isNestedRender", "nonce"] }, { kind: "component", type: Blocks, selector: "blocks", inputs: ["blocks", "parent", "path", "styleProp", "className", "context", "linkComponent", "registeredComponents"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ContentComponent, decorators: [{
            type: Component,
            args: [{ host: { ngSkipHydration: "true" }, selector: "content-component", template: `
    <enable-editor
      [apiHost]="apiHost"
      [nonce]="nonce"
      [content]="content"
      [data]="data"
      [model]="model"
      [context]="context"
      [apiKey]="apiKey"
      [canTrack]="canTrack"
      [locale]="locale"
      [enrich]="enrich"
      [showContent]="showContent"
      [builderContextSignal]="builderContextSignal"
      [contentWrapper]="contentWrapper"
      [contentWrapperProps]="contentWrapperProps"
      [trustedHosts]="trustedHosts"
      [isNestedRender]="isNestedRender"
    >
      <ng-container *ngIf="isSsrAbTest">
        <inlined-script
          id="builderio-variant-visibility"
          [scriptStr]="scriptStr"
          [nonce]="nonce || ''"
        ></inlined-script>
      </ng-container>
      <ng-container *ngIf="TARGET !== 'reactNative'">
        <content-styles
          [nonce]="nonce || ''"
          [isNestedRender]="isNestedRender"
          [contentId]="builderContextSignal.content?.id"
          [cssCode]="builderContextSignal.content?.data?.cssCode"
          [customFonts]="builderContextSignal.content?.data?.customFonts"
        ></content-styles>
      </ng-container>
      <blocks
        [blocks]="builderContextSignal.content?.data?.blocks"
        [context]="builderContextSignal"
        [registeredComponents]="registeredComponents"
        [linkComponent]="linkComponent"
      ></blocks>
    </enable-editor>
  `, standalone: true, imports: [CommonModule, EnableEditor, InlinedScript, ContentStyles, Blocks], styles: [":host{display:contents}\n"] }]
        }], propDecorators: { apiKey: [{
                type: Input
            }], context: [{
                type: Input
            }], content: [{
                type: Input
            }], customComponents: [{
                type: Input
            }], data: [{
                type: Input
            }], locale: [{
                type: Input
            }], canTrack: [{
                type: Input
            }], apiVersion: [{
                type: Input
            }], blocksWrapper: [{
                type: Input
            }], blocksWrapperProps: [{
                type: Input
            }], nonce: [{
                type: Input
            }], model: [{
                type: Input
            }], apiHost: [{
                type: Input
            }], enrich: [{
                type: Input
            }], showContent: [{
                type: Input
            }], contentWrapper: [{
                type: Input
            }], contentWrapperProps: [{
                type: Input
            }], trustedHosts: [{
                type: Input
            }], isNestedRender: [{
                type: Input
            }], isSsrAbTest: [{
                type: Input
            }], linkComponent: [{
                type: Input
            }] } });

class ContentVariants {
    constructor() {
        this.TARGET = TARGET;
        this.getVariants = getVariants;
        this.shouldRenderVariants = null;
        this.node_0_InlinedScript = null;
    }
    get updateCookieAndStylesScriptStr() {
        return getUpdateCookieAndStylesScript(getVariants(this.content).map((value) => ({
            id: value.testVariationId,
            testRatio: value.testRatio,
        })), this.content?.id || "");
    }
    get hideVariantsStyleString() {
        return getVariants(this.content)
            .map((value) => `.variant-${value.testVariationId} { display: none; } `)
            .join("");
    }
    get defaultContent() {
        return this.shouldRenderVariants
            ? {
                ...this.content,
                testVariationId: this.content?.id,
            }
            : handleABTestingSync({
                item: this.content,
                canTrack: getDefaultCanTrack(this.canTrack),
            });
    }
    trackByVariant0(_, variant) {
        return variant.testVariationId;
    }
    ngOnInit() {
        this.shouldRenderVariants = checkShouldRenderVariants({
            canTrack: getDefaultCanTrack(this.canTrack),
            content: this.content,
        });
        this.node_0_InlinedScript = getInitVariantsFnsScriptString();
        if (typeof window !== "undefined") {
            /**
             * For Solid/Svelte: we unmount the non-winning variants post-hydration.
             */
        }
    }
    ngOnChanges(changes) {
        if (typeof window !== "undefined") {
            this.node_0_InlinedScript = getInitVariantsFnsScriptString();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ContentVariants, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: ContentVariants, isStandalone: true, selector: "builder-content, content-variants", inputs: { canTrack: "canTrack", content: "content", isNestedRender: "isNestedRender", nonce: "nonce", apiHost: "apiHost", model: "model", data: "data", context: "context", apiKey: "apiKey", apiVersion: "apiVersion", customComponents: "customComponents", linkComponent: "linkComponent", locale: "locale", enrich: "enrich", blocksWrapper: "blocksWrapper", blocksWrapperProps: "blocksWrapperProps", contentWrapper: "contentWrapper", contentWrapperProps: "contentWrapperProps", trustedHosts: "trustedHosts" }, usesOnChanges: true, ngImport: i0, template: `
    <ng-container>
      <ng-container *ngIf="!isNestedRender && TARGET !== 'reactNative'">
        <inlined-script
          id="builderio-init-variants-fns"
          [scriptStr]="node_0_InlinedScript"
          [nonce]="nonce || ''"
        ></inlined-script>
      </ng-container>
      <ng-container *ngIf="shouldRenderVariants">
        <inlined-styles
          id="builderio-variants"
          [styles]="hideVariantsStyleString"
          [nonce]="nonce || ''"
        ></inlined-styles>
        <inlined-script
          id="builderio-variants-visibility"
          [scriptStr]="updateCookieAndStylesScriptStr"
          [nonce]="nonce || ''"
        ></inlined-script>
        <ng-container
          *ngFor="let variant of getVariants(content); trackBy: trackByVariant0"
        >
          <content-component
            [apiHost]="apiHost"
            [isNestedRender]="isNestedRender"
            [nonce]="nonce"
            [content]="variant"
            [showContent]="false"
            [model]="model"
            [data]="data"
            [context]="context"
            [apiKey]="apiKey"
            [apiVersion]="apiVersion"
            [customComponents]="customComponents"
            [linkComponent]="linkComponent"
            [canTrack]="canTrack"
            [locale]="locale"
            [enrich]="enrich"
            [isSsrAbTest]="shouldRenderVariants"
            [blocksWrapper]="blocksWrapper"
            [blocksWrapperProps]="blocksWrapperProps"
            [contentWrapper]="contentWrapper"
            [contentWrapperProps]="contentWrapperProps"
            [trustedHosts]="trustedHosts"
          ></content-component>
        </ng-container>
      </ng-container>
      <content-component
        [apiHost]="apiHost"
        [nonce]="nonce"
        [isNestedRender]="isNestedRender"
        [content]="defaultContent"
        [showContent]="true"
        [model]="model"
        [data]="data"
        [context]="context"
        [apiKey]="apiKey"
        [apiVersion]="apiVersion"
        [customComponents]="customComponents"
        [linkComponent]="linkComponent"
        [canTrack]="canTrack"
        [locale]="locale"
        [enrich]="enrich"
        [isSsrAbTest]="shouldRenderVariants"
        [blocksWrapper]="blocksWrapper"
        [blocksWrapperProps]="blocksWrapperProps"
        [contentWrapper]="contentWrapper"
        [contentWrapperProps]="contentWrapperProps"
        [trustedHosts]="trustedHosts"
      ></content-component>
    </ng-container>
  `, isInline: true, styles: [":host{display:contents}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: InlinedScript, selector: "inlined-script, InlinedScript", inputs: ["scriptStr", "id", "nonce"] }, { kind: "component", type: InlinedStyles, selector: "inlined-styles, InlinedStyles", inputs: ["styles", "id", "nonce"] }, { kind: "component", type: ContentComponent, selector: "content-component", inputs: ["apiKey", "context", "content", "customComponents", "data", "locale", "canTrack", "apiVersion", "blocksWrapper", "blocksWrapperProps", "nonce", "model", "apiHost", "enrich", "showContent", "contentWrapper", "contentWrapperProps", "trustedHosts", "isNestedRender", "isSsrAbTest", "linkComponent"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ContentVariants, decorators: [{
            type: Component,
            args: [{ selector: "builder-content, content-variants", template: `
    <ng-container>
      <ng-container *ngIf="!isNestedRender && TARGET !== 'reactNative'">
        <inlined-script
          id="builderio-init-variants-fns"
          [scriptStr]="node_0_InlinedScript"
          [nonce]="nonce || ''"
        ></inlined-script>
      </ng-container>
      <ng-container *ngIf="shouldRenderVariants">
        <inlined-styles
          id="builderio-variants"
          [styles]="hideVariantsStyleString"
          [nonce]="nonce || ''"
        ></inlined-styles>
        <inlined-script
          id="builderio-variants-visibility"
          [scriptStr]="updateCookieAndStylesScriptStr"
          [nonce]="nonce || ''"
        ></inlined-script>
        <ng-container
          *ngFor="let variant of getVariants(content); trackBy: trackByVariant0"
        >
          <content-component
            [apiHost]="apiHost"
            [isNestedRender]="isNestedRender"
            [nonce]="nonce"
            [content]="variant"
            [showContent]="false"
            [model]="model"
            [data]="data"
            [context]="context"
            [apiKey]="apiKey"
            [apiVersion]="apiVersion"
            [customComponents]="customComponents"
            [linkComponent]="linkComponent"
            [canTrack]="canTrack"
            [locale]="locale"
            [enrich]="enrich"
            [isSsrAbTest]="shouldRenderVariants"
            [blocksWrapper]="blocksWrapper"
            [blocksWrapperProps]="blocksWrapperProps"
            [contentWrapper]="contentWrapper"
            [contentWrapperProps]="contentWrapperProps"
            [trustedHosts]="trustedHosts"
          ></content-component>
        </ng-container>
      </ng-container>
      <content-component
        [apiHost]="apiHost"
        [nonce]="nonce"
        [isNestedRender]="isNestedRender"
        [content]="defaultContent"
        [showContent]="true"
        [model]="model"
        [data]="data"
        [context]="context"
        [apiKey]="apiKey"
        [apiVersion]="apiVersion"
        [customComponents]="customComponents"
        [linkComponent]="linkComponent"
        [canTrack]="canTrack"
        [locale]="locale"
        [enrich]="enrich"
        [isSsrAbTest]="shouldRenderVariants"
        [blocksWrapper]="blocksWrapper"
        [blocksWrapperProps]="blocksWrapperProps"
        [contentWrapper]="contentWrapper"
        [contentWrapperProps]="contentWrapperProps"
        [trustedHosts]="trustedHosts"
      ></content-component>
    </ng-container>
  `, standalone: true, imports: [CommonModule, InlinedScript, InlinedStyles, ContentComponent], styles: [":host{display:contents}\n"] }]
        }], propDecorators: { canTrack: [{
                type: Input
            }], content: [{
                type: Input
            }], isNestedRender: [{
                type: Input
            }], nonce: [{
                type: Input
            }], apiHost: [{
                type: Input
            }], model: [{
                type: Input
            }], data: [{
                type: Input
            }], context: [{
                type: Input
            }], apiKey: [{
                type: Input
            }], apiVersion: [{
                type: Input
            }], customComponents: [{
                type: Input
            }], linkComponent: [{
                type: Input
            }], locale: [{
                type: Input
            }], enrich: [{
                type: Input
            }], blocksWrapper: [{
                type: Input
            }], blocksWrapperProps: [{
                type: Input
            }], contentWrapper: [{
                type: Input
            }], contentWrapperProps: [{
                type: Input
            }], trustedHosts: [{
                type: Input
            }] } });

const fetchSymbolContent = async ({ builderContextValue, symbol }) => {
    /**
     * If:
     * - we have a symbol prop
     * - yet it does not have any content
     * - and we have not already stored content from before
     * - and it has a model name
     *
     * then we want to re-fetch the symbol content.
     */
    if (symbol?.model &&
        // This is a hack, we should not need to check for this, but it is needed for Svelte.
        builderContextValue?.apiKey) {
        return fetchOneEntry({
            model: symbol.model,
            apiKey: builderContextValue.apiKey,
            apiVersion: builderContextValue.apiVersion,
            ...(symbol?.entry && {
                query: {
                    id: symbol.entry
                }
            })
        }).catch(err => {
            logger.error('Could not fetch symbol content: ', err);
            return undefined;
        });
    }
    return undefined;
};

class BuilderSymbol {
    get blocksWrapper() {
        return DynamicDiv;
    }
    get contentWrapper() {
        return DynamicDiv;
    }
    get className() {
        return [
            ...[this.attributes[getClassPropName()]],
            "builder-symbol",
            this.symbol?.inline ? "builder-inline-symbol" : undefined,
            this.symbol?.dynamic || this.dynamic
                ? "builder-dynamic-symbol"
                : undefined,
        ]
            .filter(Boolean)
            .join(" ");
    }
    setContent() {
        if (this.contentToUse)
            return;
        fetchSymbolContent({
            symbol: this.symbol,
            builderContextValue: this.builderContext,
        }).then((newContent) => {
            if (newContent) {
                this.contentToUse = newContent;
            }
        });
    }
    setAttributes(el, value, changes) {
        if (!el) {
            return;
        }
        const target = typeof changes === "undefined" ? value : changes;
        Object.keys(target).forEach((key) => {
            if (key.startsWith("on")) {
                if (this._listenerFns.has(key)) {
                    this._listenerFns.get(key)();
                }
                this._listenerFns.set(key, this.renderer.listen(el, key.replace("on", "").toLowerCase(), target[key]));
            }
            else {
                this.renderer.setAttribute(el, key.toLowerCase(), target[key] ?? "");
            }
        });
    }
    constructor(renderer) {
        this.renderer = renderer;
        this._listenerFns = new Map();
        this.contentToUse = null;
        this.node_0_ContentVariants = null;
        this.node_1_ContentVariants = null;
        this.node_2_ContentVariants = null;
        this.elRef0_state_0 = null;
        this.elRef0_state_1 = null;
    }
    ngOnInit() {
        this.contentToUse = this.symbol?.content;
        this.node_0_ContentVariants = {
            ...this.builderContext.context,
            symbolId: this.builderBlock?.id,
        };
        this.node_1_ContentVariants = Object.values(this.builderComponents);
        this.node_2_ContentVariants = {
            ...this.symbol?.data,
            ...this.builderContext.localState,
            ...this.contentToUse?.data?.state,
        };
        this.elRef0_state_0 = {};
        this.elRef0_state_1 = {};
        if (typeof window !== "undefined") {
        }
    }
    ngAfterViewInit() {
        this.setAttributes(this.elRef0?.nativeElement, this.elRef0_state_0);
        this.setAttributes(this.elRef0?.nativeElement, this.attributes);
        this.setAttributes(this.elRef0?.nativeElement, this.elRef0_state_1);
    }
    ngOnChanges(changes) {
        if (typeof window !== "undefined") {
            if (changes.symbol) {
                this.setContent();
            }
            this.node_0_ContentVariants = {
                ...this.builderContext.context,
                symbolId: this.builderBlock?.id,
            };
            this.node_1_ContentVariants = Object.values(this.builderComponents);
            this.node_2_ContentVariants = {
                ...this.symbol?.data,
                ...this.builderContext.localState,
                ...this.contentToUse?.data?.state,
            };
            this.elRef0_state_0 = {};
            this.setAttributes(this.elRef0?.nativeElement, this.elRef0_state_0, changes["elRef0_state_0"]?.currentValue);
            this.setAttributes(this.elRef0?.nativeElement, this.attributes, changes["attributes"]?.currentValue);
            this.elRef0_state_1 = {};
            this.setAttributes(this.elRef0?.nativeElement, this.elRef0_state_1, changes["elRef0_state_1"]?.currentValue);
        }
    }
    ngOnDestroy() {
        for (const fn of this._listenerFns.values()) {
            fn();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: BuilderSymbol, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: BuilderSymbol, isStandalone: true, selector: "builder-symbol", inputs: { symbol: "symbol", builderContext: "builderContext", builderBlock: "builderBlock", builderComponents: "builderComponents", attributes: "attributes", dynamic: "dynamic", builderLinkComponent: "builderLinkComponent" }, viewQueries: [{ propertyName: "elRef0", first: true, predicate: ["elRef0"], descendants: true }], usesOnChanges: true, ngImport: i0, template: `
    <div [class]="className" #elRef0>
      <content-variants
        [nonce]="builderContext.nonce"
        [isNestedRender]="true"
        [apiVersion]="builderContext.apiVersion"
        [apiKey]="builderContext.apiKey!"
        [context]="node_0_ContentVariants"
        [customComponents]="node_1_ContentVariants"
        [data]="node_2_ContentVariants"
        [canTrack]="builderContext.canTrack"
        [model]="symbol?.model ?? ''"
        [content]="contentToUse"
        [linkComponent]="builderLinkComponent"
        [blocksWrapper]="blocksWrapper"
        [contentWrapper]="contentWrapper"
      ></content-variants>
    </div>
  `, isInline: true, styles: [":host{display:contents}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "component", type: ContentVariants, selector: "builder-content, content-variants", inputs: ["canTrack", "content", "isNestedRender", "nonce", "apiHost", "model", "data", "context", "apiKey", "apiVersion", "customComponents", "linkComponent", "locale", "enrich", "blocksWrapper", "blocksWrapperProps", "contentWrapper", "contentWrapperProps", "trustedHosts"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: BuilderSymbol, decorators: [{
            type: Component,
            args: [{ selector: "builder-symbol", template: `
    <div [class]="className" #elRef0>
      <content-variants
        [nonce]="builderContext.nonce"
        [isNestedRender]="true"
        [apiVersion]="builderContext.apiVersion"
        [apiKey]="builderContext.apiKey!"
        [context]="node_0_ContentVariants"
        [customComponents]="node_1_ContentVariants"
        [data]="node_2_ContentVariants"
        [canTrack]="builderContext.canTrack"
        [model]="symbol?.model ?? ''"
        [content]="contentToUse"
        [linkComponent]="builderLinkComponent"
        [blocksWrapper]="blocksWrapper"
        [contentWrapper]="contentWrapper"
      ></content-variants>
    </div>
  `, standalone: true, imports: [CommonModule, ContentVariants], styles: [":host{display:contents}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { symbol: [{
                type: Input
            }], builderContext: [{
                type: Input
            }], builderBlock: [{
                type: Input
            }], builderComponents: [{
                type: Input
            }], attributes: [{
                type: Input
            }], dynamic: [{
                type: Input
            }], builderLinkComponent: [{
                type: Input
            }], elRef0: [{
                type: ViewChild,
                args: ["elRef0"]
            }] } });

const settings = {};
function setEditorSettings(newSettings) {
    if (isBrowser()) {
        Object.assign(settings, newSettings);
        const message = {
            type: 'builder.settingsChange',
            data: settings
        };
        parent.postMessage(message, '*');
    }
}

/**
 * Given an `apiKey` and `url` (or `path` + `searchParams`), provides all props that `Content` needs to render Builder Content.
 *
 * @example
 * ```jsx
 * const builderProps = await fetchBuilderProps({
 *    apiKey: 'API_KEY',
 *    // provide `url`
 *    url: yourPageUrl,
 *    // OR provide `path` + `searchParams`
 *    path: yourPath,
 *    searchParams: yourSearchParams,
 * });
 *
 * return <Content {...builderProps} />;
 * ```
 */
const fetchBuilderProps = async (_args) => {
    const urlPath = _args.path || _args.url?.pathname || _args.userAttributes?.urlPath;
    const getContentArgs = {
        ..._args,
        apiKey: _args.apiKey,
        model: _args.model || 'page',
        userAttributes: {
            ..._args.userAttributes,
            ...(urlPath ? {
                urlPath
            } : {})
        },
        options: getBuilderSearchParams(_args.searchParams || _args.url?.searchParams || _args.options)
    };
    return {
        apiKey: getContentArgs.apiKey,
        model: getContentArgs.model,
        content: await fetchOneEntry(getContentArgs)
    };
};

// ignore prettier formatting for this file because the order of exports is meaningful
// prettier-ignore

/**
 * Generated bundle index. Do not edit.
 */

export { Blocks, BuilderContext, BuilderButton as Button, Columns, ContentVariants as Content, FragmentComponent as Fragment, BuilderImage as Image, SectionComponent as Section, BuilderSymbol as Symbol, BuilderText as Text, BuilderVideo as Video, _processContentResult, createRegisterComponentMessage, fetchBuilderProps, fetchEntries, fetchOneEntry, getBuilderSearchParams, isEditing, isPreviewing, register, setClientUserAttributes, setEditorSettings, subscribeToEditor, track };
//# sourceMappingURL=builder.io-sdk-angular.mjs.map
